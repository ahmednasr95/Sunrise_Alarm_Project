
Kylian_Tech_Alarm.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000de  00000000  00000000  000001d4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  000000de  00000353  2**0
                  ALLOC
  2 .bss          0000000c  00800060  00800060  000022c1  2**0
                  ALLOC
  3 .comment      0000002f  00000000  00000000  000022c1  2**0
                  CONTENTS, READONLY
  4 .stack.descriptors.hdr 0000007e  00000000  00000000  000022f0  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 00000450  00000000  00000000  0000236e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00008796  00000000  00000000  000027be  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001841  00000000  00000000  0000af54  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002abb  00000000  00000000  0000c795  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000009c0  00000000  00000000  0000f250  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000854  00000000  00000000  0000fc10  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000267e  00000000  00000000  00010464  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000370  00000000  00000000  00012ae2  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .text         00000004  000020da  000020da  000022ae  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00012e54  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .text.modifyAlarm 000003a8  00000230  00000230  00000404  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .text.alarm_scheduler_init 0000002c  00001d52  00001d52  00001f26  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 17 .text.printAlarm 000000bc  00001242  00001242  00001416  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 18 .text.Check_Button_Update 0000008a  0000179c  0000179c  00001970  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 19 .text.Display_Action_Buttons 00000066  00001a90  00001a90  00001c64  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 20 .progmemx.data 00000079  0000017f  0000017f  00000353  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, PROGMEMX
 21 .text.modify_set_alarm 000001aa  00000a70  00000a70  00000c44  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 22 .text.alarm_scheduler 000002c8  000005d8  000005d8  000007ac  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 23 .data.cursor_loc.2149 00000001  00800070  000020ea  000022be  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 24 .bss.usr_def_alarms 00000001  00800071  00800071  000022c1  2**0
                  ALLOC
 25 .bss.five_sec_timeout 00000001  00800072  00800072  000022c1  2**0
                  ALLOC
 26 .text.ALL_LEDS_TGL 00000012  00001fa2  00001fa2  00002176  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 27 .text.ALL_LEDS_ON 00000016  00001f24  00001f24  000020f8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 28 .text.ALL_LEDS_OFF 00000016  00001f3a  00001f3a  0000210e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 29 .text.ALL_LEDS_Initialize 0000001e  00001e84  00001e84  00002058  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 30 .text.ALL_LEDS_dimming 00000006  000020d4  000020d4  000022a8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 31 .text.__vector_10 00000048  00001bb4  00001bb4  00001d88  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 32 .text.__vector_11 000000cc  000010b2  000010b2  00001286  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 33 .data.DUTY_CYCLE 00000001  00800073  000020eb  000022bf  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 34 .bss.OVF_COUNTER 00000001  00800074  00800074  000022c1  2**0
                  ALLOC
 35 .bss.DECELERATE 00000001  00800075  00800075  000022c1  2**0
                  ALLOC
 36 .data.ACCELERATE 00000001  00800076  000020ec  000022c0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 37 .text.app_init 00000018  00001edc  00001edc  000020b0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 38 .text.app_main 00000008  000020cc  000020cc  000022a0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 39 .progmemx.data 000000a1  000000de  000000de  000002b2  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, PROGMEMX
 40 .text.LCD_Runable_Page 000000ae  000013ba  000013ba  0000158e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 41 .text.LCD_Second_Page 000000c4  0000117e  0000117e  00001352  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 42 .text.LCD_First_Page 0000005c  00001b58  00001b58  00001d2c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 43 .text.__vector_7 000000a8  000015bc  000015bc  00001790  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 44 .bss.Alarm_3_Fire_Flag 00000001  00800077  00800077  000022c1  2**0
                  ALLOC
 45 .bss.Alarm_2_Fire_Flag 00000001  00800078  00800078  000022c1  2**0
                  ALLOC
 46 .bss.Alarm_1_Fire_Flag 00000001  00800079  00800079  000022c1  2**0
                  ALLOC
 47 .progmemx.data 0000000c  00000224  00000224  000003f8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, PROGMEMX
 48 .text.Alarm_Action 000000bc  000012fe  000012fe  000014d2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 49 .text.swap    00000042  00001c44  00001c44  00001e18  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 50 .text.customSort 000000aa  00001468  00001468  0000163c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 51 .text.Nearest_Time_Display 00000096  00001706  00001706  000018da  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 52 .data.TEN_Secs_Counter 00000002  0080006c  000020e8  000022bc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 53 .bss.Current_Time 00000002  0080006e  0080006e  000022c1  2**0
                  ALLOC
 54 .progmemx.data 0000002c  000001f8  000001f8  000003cc  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, PROGMEMX
 55 .text.Show_Alarms 000000aa  00001512  00001512  000016e6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 56 .text.erase   000000f4  00000e16  00000e16  00000fea  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 57 .text.Remove_Alarm 0000008a  00001826  00001826  000019fa  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 58 .text.BLUE_LED_Initializ 0000000e  00001fc4  00001fc4  00002198  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 59 .text.BLUE_LED_ON 0000000e  00001fd2  00001fd2  000021a6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 60 .text.BLUE_LED_OFF 0000000e  00001fe0  00001fe0  000021b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 61 .text.BLUE_LED_TGL 0000000c  00002018  00002018  000021ec  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 62 .text.BTN_Initialization 0000000a  00002090  00002090  00002264  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 63 .text.BTN_pressed 0000007c  000018b0  000018b0  00001a84  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 64 .text.BUZZER_Initialize 0000000e  00001fee  00001fee  000021c2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 65 .text.BUZZER_ON 0000000e  00001ffc  00001ffc  000021d0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 66 .text.BUZZER_OFF 0000000e  0000200a  0000200a  000021de  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 67 .text.GREEN_LED_Initializ 0000000c  00002024  00002024  000021f8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 68 .text.GREEN_LED_ON 0000000c  00002030  00002030  00002204  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 69 .text.GREEN_LED_OFF 0000000c  0000203c  0000203c  00002210  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 70 .text.GREEN_LED_TGL 0000000a  0000209a  0000209a  0000226e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 71 .text.LCD_Write_Command 000000d4  00000f0a  00000f0a  000010de  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 72 .text.LCD_Initialize 0000007c  0000192c  0000192c  00001b00  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 73 .text.LCD_Clear 0000000a  000020a4  000020a4  00002278  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 74 .text.LCD_Write_Character 000000d4  00000fde  00000fde  000011b2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 75 .text.LCD_Write_String 0000002e  00001d24  00001d24  00001ef8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 76 .text.LCD_Write_Number 000001d0  000008a0  000008a0  00000a74  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 77 .text.LCD_LINE_position 00000048  00001bfc  00001bfc  00001dd0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 78 .text.LDR_init 00000010  00001fb4  00001fb4  00002188  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 79 .text.LDR_Read 00000014  00001f66  00001f66  0000213a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 80 .text.RED_LED_Initializ 0000000c  00002048  00002048  0000221c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 81 .text.RED_LED_ON 0000000c  00002054  00002054  00002228  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 82 .text.RED_LED_OFF 0000000c  00002060  00002060  00002234  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 83 .text.RED_LED_TGL 0000000a  000020ae  000020ae  00002282  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 84 .text.YELLOW_LED_Initializ 0000000c  0000206c  0000206c  00002240  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 85 .text.YELLOW_LED_ON 0000000c  00002078  00002078  0000224c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 86 .text.YELLOW_LED_OFF 0000000c  00002084  00002084  00002258  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 87 .text.YELLOW_LED_TGL 0000000a  000020b8  000020b8  0000228c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 88 .text.main    0000000a  000020c2  000020c2  00002296  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 89 .text.ADC_Initialize 00000028  00001daa  00001daa  00001f7e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 90 .text.ADC_Read 00000030  00001cf4  00001cf4  00001ec8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 91 .text.DIO_SetPin_Direction 000000fe  00000c1a  00000c1a  00000dee  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 92 .text.DIO_SetPin_Value 000000fe  00000d18  00000d18  00000eec  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 93 .text.DIO_TglPin_Value 00000074  000019a8  000019a8  00001b7c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 94 .text.DIO_GetPin_Value 00000074  00001a1c  00001a1c  00001bf0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 95 .text.Set_Global_Initialize 0000002c  00001d7e  00001d7e  00001f52  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 96 .text.Timer0_Initialize 00000018  00001ef4  00001ef4  000020c8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 97 .text.SET_DUTY_CYCLE 00000020  00001e44  00001e44  00002018  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 98 .text.Timer0_STOP 00000014  00001f7a  00001f7a  0000214e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 99 .text.Timer0_ON 00000014  00001f8e  00001f8e  00002162  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
100 .text.Timer1_Initialize 00000022  00001e22  00001e22  00001ff6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
101 .text.libgcc.div 00000028  00001dd2  00001dd2  00001fa6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
102 .text.libgcc.mul 0000001e  00001ea2  00001ea2  00002076  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
103 .text.libgcc.div 00000062  00001af6  00001af6  00001cca  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
104 .text.libgcc.div 0000001c  00001ec0  00001ec0  00002094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
105 .text.libgcc.div 000000a2  00001664  00001664  00001838  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
106 .text.libgcc  00000020  00001e64  00001e64  00002038  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
107 .text.libgcc.prologue 00000038  00001c86  00001c86  00001e5a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
108 .text.libgcc.prologue 00000036  00001cbe  00001cbe  00001e92  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
109 .text.libgcc  00000018  00001f0c  00001f0c  000020e0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
110 .text.libgcc.div 00000028  00001dfa  00001dfa  00001fce  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
111 .text.__dummy_fini 00000002  000020e2  000020e2  000022b6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
112 .text.__dummy_funcs_on_exit 00000002  000020e4  000020e4  000022b8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
113 .text.__dummy_simulator_exit 00000002  000020e6  000020e6  000022ba  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
114 .text.exit    00000016  00001f50  00001f50  00002124  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
115 .text._Exit   00000004  000020de  000020de  000022b2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 45 00 	jmp	0x8a	; 0x8a <__ctors_end>
   4:	0c 94 6d 10 	jmp	0x20da	; 0x20da <__bad_interrupt>
   8:	0c 94 6d 10 	jmp	0x20da	; 0x20da <__bad_interrupt>
   c:	0c 94 6d 10 	jmp	0x20da	; 0x20da <__bad_interrupt>
  10:	0c 94 6d 10 	jmp	0x20da	; 0x20da <__bad_interrupt>
  14:	0c 94 6d 10 	jmp	0x20da	; 0x20da <__bad_interrupt>
  18:	0c 94 6d 10 	jmp	0x20da	; 0x20da <__bad_interrupt>
  1c:	0c 94 de 0a 	jmp	0x15bc	; 0x15bc <__vector_7>
  20:	0c 94 6d 10 	jmp	0x20da	; 0x20da <__bad_interrupt>
  24:	0c 94 6d 10 	jmp	0x20da	; 0x20da <__bad_interrupt>
  28:	0c 94 da 0d 	jmp	0x1bb4	; 0x1bb4 <__vector_10>
  2c:	0c 94 59 08 	jmp	0x10b2	; 0x10b2 <__vector_11>
  30:	0c 94 6d 10 	jmp	0x20da	; 0x20da <__bad_interrupt>
  34:	0c 94 6d 10 	jmp	0x20da	; 0x20da <__bad_interrupt>
  38:	0c 94 6d 10 	jmp	0x20da	; 0x20da <__bad_interrupt>
  3c:	0c 94 6d 10 	jmp	0x20da	; 0x20da <__bad_interrupt>
  40:	0c 94 6d 10 	jmp	0x20da	; 0x20da <__bad_interrupt>
  44:	0c 94 6d 10 	jmp	0x20da	; 0x20da <__bad_interrupt>
  48:	0c 94 6d 10 	jmp	0x20da	; 0x20da <__bad_interrupt>
  4c:	0c 94 6d 10 	jmp	0x20da	; 0x20da <__bad_interrupt>
  50:	0c 94 6d 10 	jmp	0x20da	; 0x20da <__bad_interrupt>

00000054 <.dinit>:
  54:	00 60       	ori	r16, 0x00	; 0
  56:	00 6c       	ori	r16, 0xC0	; 192
  58:	80 00       	.word	0x0080	; ????
  5a:	6c 00       	.word	0x006c	; ????
  5c:	6e 00       	.word	0x006e	; ????
  5e:	20 e8       	ldi	r18, 0x80	; 128
  60:	00 6e       	ori	r16, 0xE0	; 224
  62:	00 70       	andi	r16, 0x00	; 0
  64:	80 00       	.word	0x0080	; ????
  66:	70 00       	.word	0x0070	; ????
  68:	71 00       	.word	0x0071	; ????
  6a:	20 ea       	ldi	r18, 0xA0	; 160
  6c:	00 71       	andi	r16, 0x10	; 16
  6e:	00 73       	andi	r16, 0x30	; 48
  70:	80 00       	.word	0x0080	; ????
  72:	73 00       	.word	0x0073	; ????
  74:	74 00       	.word	0x0074	; ????
  76:	20 eb       	ldi	r18, 0xB0	; 176
  78:	00 74       	andi	r16, 0x40	; 64
  7a:	00 76       	andi	r16, 0x60	; 96
  7c:	80 00       	.word	0x0080	; ????
  7e:	76 00       	.word	0x0076	; ????
  80:	77 00       	.word	0x0077	; ????
  82:	20 ec       	ldi	r18, 0xC0	; 192
  84:	00 77       	andi	r16, 0x70	; 112
  86:	00 7a       	andi	r16, 0xA0	; 160
  88:	80 00       	.word	0x0080	; ????

0000008a <__ctors_end>:
  8a:	11 24       	eor	r1, r1
  8c:	1f be       	out	0x3f, r1	; 63
  8e:	cf e5       	ldi	r28, 0x5F	; 95
  90:	d8 e0       	ldi	r29, 0x08	; 8
  92:	de bf       	out	0x3e, r29	; 62
  94:	cd bf       	out	0x3d, r28	; 61

00000096 <__do_copy_data>:
  96:	e4 e5       	ldi	r30, 0x54	; 84
  98:	f0 e0       	ldi	r31, 0x00	; 0
  9a:	40 e0       	ldi	r20, 0x00	; 0
  9c:	17 c0       	rjmp	.+46     	; 0xcc <__do_clear_bss+0x8>
  9e:	b5 91       	lpm	r27, Z+
  a0:	a5 91       	lpm	r26, Z+
  a2:	35 91       	lpm	r19, Z+
  a4:	25 91       	lpm	r18, Z+
  a6:	05 91       	lpm	r16, Z+
  a8:	07 fd       	sbrc	r16, 7
  aa:	0c c0       	rjmp	.+24     	; 0xc4 <__do_clear_bss>
  ac:	95 91       	lpm	r25, Z+
  ae:	85 91       	lpm	r24, Z+
  b0:	ef 01       	movw	r28, r30
  b2:	f9 2f       	mov	r31, r25
  b4:	e8 2f       	mov	r30, r24
  b6:	05 90       	lpm	r0, Z+
  b8:	0d 92       	st	X+, r0
  ba:	a2 17       	cp	r26, r18
  bc:	b3 07       	cpc	r27, r19
  be:	d9 f7       	brne	.-10     	; 0xb6 <__do_copy_data+0x20>
  c0:	fe 01       	movw	r30, r28
  c2:	04 c0       	rjmp	.+8      	; 0xcc <__do_clear_bss+0x8>

000000c4 <__do_clear_bss>:
  c4:	1d 92       	st	X+, r1
  c6:	a2 17       	cp	r26, r18
  c8:	b3 07       	cpc	r27, r19
  ca:	e1 f7       	brne	.-8      	; 0xc4 <__do_clear_bss>
  cc:	e9 38       	cpi	r30, 0x89	; 137
  ce:	f4 07       	cpc	r31, r20
  d0:	31 f7       	brne	.-52     	; 0x9e <__do_copy_data+0x8>
  d2:	0e 94 61 10 	call	0x20c2	; 0x20c2 <main>
  d6:	0c 94 a8 0f 	jmp	0x1f50	; 0x1f50 <exit>

000000da <_exit>:
  da:	f8 94       	cli

000000dc <__stop_program>:
  dc:	ff cf       	rjmp	.-2      	; 0xdc <__stop_program>

Disassembly of section .text:

000020da <__bad_interrupt>:
    20da:	0c 94 00 00 	jmp	0	; 0x0 <__TEXT_REGION_ORIGIN__>

Disassembly of section .text.modifyAlarm:

00000230 <modifyAlarm>:
/*
*	Inputs:	addresses of tens and ones units of both minutes and seconds.
*	Outputs: either success or fail.
*	Description: The function modifies the alarm value and outputs the modified value to the LCD.
*/
ERROR_STATE modifyAlarm(UINT8_t* minutes_tens, UINT8_t* minutes_ones, UINT8_t* seconds_tens, UINT8_t* seconds_ones){
 230:	af 92       	push	r10
 232:	bf 92       	push	r11
 234:	cf 92       	push	r12
 236:	df 92       	push	r13
 238:	ef 92       	push	r14
 23a:	ff 92       	push	r15
 23c:	0f 93       	push	r16
 23e:	1f 93       	push	r17
 240:	cf 93       	push	r28
 242:	df 93       	push	r29
 244:	00 d0       	rcall	.+0      	; 0x246 <modifyAlarm+0x16>
 246:	00 d0       	rcall	.+0      	; 0x248 <modifyAlarm+0x18>
 248:	cd b7       	in	r28, 0x3d	; 61
 24a:	de b7       	in	r29, 0x3e	; 62
 24c:	7c 01       	movw	r14, r24
 24e:	5b 01       	movw	r10, r22
 250:	8a 01       	movw	r16, r20
 252:	69 01       	movw	r12, r18
	
	/*Local Initializations*/
	bool move_left = 0;
 254:	19 82       	std	Y+1, r1	; 0x01
	bool increment = 0;
 256:	1a 82       	std	Y+2, r1	; 0x02
	bool decrement = 0;
 258:	1b 82       	std	Y+3, r1	; 0x03
	bool move_right = 0;
 25a:	1c 82       	std	Y+4, r1	; 0x04
	static UINT8_t cursor_loc = MODIFY_ALARM_CURSOR_LOC;
	ERROR_STATE state_error = SUCCESS;
	/************************************************************************/
	/*if the move left button is pressed...*/
	BTN_pressed(DIO_PORTD, DIO_PIN3, &move_left);
 25c:	ae 01       	movw	r20, r28
 25e:	4f 5f       	subi	r20, 0xFF	; 255
 260:	5f 4f       	sbci	r21, 0xFF	; 255
 262:	63 e0       	ldi	r22, 0x03	; 3
 264:	83 e0       	ldi	r24, 0x03	; 3
 266:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <BTN_pressed>
	if(move_left){
 26a:	89 81       	ldd	r24, Y+1	; 0x01
 26c:	88 23       	and	r24, r24
 26e:	b9 f0       	breq	.+46     	; 0x29e <modifyAlarm+0x6e>
		/*modify cursor location*/
		cursor_loc++;
 270:	80 91 70 00 	lds	r24, 0x0070	; 0x800070 <cursor_loc.2149>
 274:	8f 5f       	subi	r24, 0xFF	; 255
 276:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <cursor_loc.2149>
		/*to avoid writing over the colon*/
		if(COLON_LOC == cursor_loc){
 27a:	8a 30       	cpi	r24, 0x0A	; 10
 27c:	21 f4       	brne	.+8      	; 0x286 <modifyAlarm+0x56>
			cursor_loc = SECONDS_TENS_LOC;
 27e:	8b e0       	ldi	r24, 0x0B	; 11
 280:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <cursor_loc.2149>
 284:	05 c0       	rjmp	.+10     	; 0x290 <modifyAlarm+0x60>
			/*to get back to the  start location*/
			} else if((SECONDS_ONES_LOC + 1) == cursor_loc){
 286:	8d 30       	cpi	r24, 0x0D	; 13
 288:	19 f4       	brne	.+6      	; 0x290 <modifyAlarm+0x60>
			cursor_loc = MINUTES_TENS_LOC;
 28a:	88 e0       	ldi	r24, 0x08	; 8
 28c:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <cursor_loc.2149>
			} else{
			/*do nothing*/;
		}
		/*move the cursor*/
		LCD_LINE_position(MODIFY_ALARM_LINE, cursor_loc);
 290:	60 91 70 00 	lds	r22, 0x0070	; 0x800070 <cursor_loc.2149>
 294:	81 e0       	ldi	r24, 0x01	; 1
 296:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
		five_sec_timeout = 0;
 29a:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <five_sec_timeout>
		}else{
		/*do nothing*/;
	}
	/************************************************************************/
	/*if the increment button is pressed...*/
	BTN_pressed(DIO_PORTD, DIO_PIN5, &increment);
 29e:	ae 01       	movw	r20, r28
 2a0:	4e 5f       	subi	r20, 0xFE	; 254
 2a2:	5f 4f       	sbci	r21, 0xFF	; 255
 2a4:	65 e0       	ldi	r22, 0x05	; 5
 2a6:	83 e0       	ldi	r24, 0x03	; 3
 2a8:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <BTN_pressed>
	if(increment){
 2ac:	8a 81       	ldd	r24, Y+2	; 0x02
 2ae:	88 23       	and	r24, r24
 2b0:	09 f4       	brne	.+2      	; 0x2b4 <modifyAlarm+0x84>
 2b2:	a8 c0       	rjmp	.+336    	; 0x404 <__EEPROM_REGION_LENGTH__+0x4>
		/*check on which digit the cursor is standing*/
		switch(cursor_loc){
 2b4:	60 91 70 00 	lds	r22, 0x0070	; 0x800070 <cursor_loc.2149>
 2b8:	69 30       	cpi	r22, 0x09	; 9
 2ba:	29 f1       	breq	.+74     	; 0x306 <modifyAlarm+0xd6>
 2bc:	18 f4       	brcc	.+6      	; 0x2c4 <modifyAlarm+0x94>
 2be:	68 30       	cpi	r22, 0x08	; 8
 2c0:	41 f0       	breq	.+16     	; 0x2d2 <modifyAlarm+0xa2>
 2c2:	9e c0       	rjmp	.+316    	; 0x400 <__EEPROM_REGION_LENGTH__>
 2c4:	6b 30       	cpi	r22, 0x0B	; 11
 2c6:	09 f4       	brne	.+2      	; 0x2ca <modifyAlarm+0x9a>
 2c8:	50 c0       	rjmp	.+160    	; 0x36a <modifyAlarm+0x13a>
 2ca:	6c 30       	cpi	r22, 0x0C	; 12
 2cc:	09 f4       	brne	.+2      	; 0x2d0 <modifyAlarm+0xa0>
 2ce:	67 c0       	rjmp	.+206    	; 0x39e <modifyAlarm+0x16e>
 2d0:	97 c0       	rjmp	.+302    	; 0x400 <__EEPROM_REGION_LENGTH__>
			/********************first case*********************/
			case MINUTES_TENS_LOC:
			/*to keep values between 0 and 9*/
			if(8 < *minutes_tens){
 2d2:	f7 01       	movw	r30, r14
 2d4:	80 81       	ld	r24, Z
 2d6:	89 30       	cpi	r24, 0x09	; 9
 2d8:	10 f0       	brcs	.+4      	; 0x2de <modifyAlarm+0xae>
				*minutes_tens = 0;
 2da:	10 82       	st	Z, r1
 2dc:	03 c0       	rjmp	.+6      	; 0x2e4 <modifyAlarm+0xb4>
				}else{
				(*minutes_tens)++;
 2de:	8f 5f       	subi	r24, 0xFF	; 255
 2e0:	f7 01       	movw	r30, r14
 2e2:	80 83       	st	Z, r24
			}
			LCD_Write_Number(*minutes_tens);
 2e4:	f7 01       	movw	r30, r14
 2e6:	20 81       	ld	r18, Z
 2e8:	30 e0       	ldi	r19, 0x00	; 0
 2ea:	40 e0       	ldi	r20, 0x00	; 0
 2ec:	50 e0       	ldi	r21, 0x00	; 0
 2ee:	60 e0       	ldi	r22, 0x00	; 0
 2f0:	70 e0       	ldi	r23, 0x00	; 0
 2f2:	80 e0       	ldi	r24, 0x00	; 0
 2f4:	90 e0       	ldi	r25, 0x00	; 0
 2f6:	0e 94 50 04 	call	0x8a0	; 0x8a0 <LCD_Write_Number>
			/*to keep the cursor from modifying other digits*/
			LCD_LINE_position(MODIFY_ALARM_LINE, cursor_loc);
 2fa:	60 91 70 00 	lds	r22, 0x0070	; 0x800070 <cursor_loc.2149>
 2fe:	81 e0       	ldi	r24, 0x01	; 1
 300:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
			break;
 304:	7d c0       	rjmp	.+250    	; 0x400 <__EEPROM_REGION_LENGTH__>
			/********************second case*********************/
			case MINUTES_ONES_LOC:
			/*to keep values between 0 and 9*/
			if(8 < *minutes_ones){
 306:	f5 01       	movw	r30, r10
 308:	80 81       	ld	r24, Z
 30a:	89 30       	cpi	r24, 0x09	; 9
 30c:	d0 f0       	brcs	.+52     	; 0x342 <modifyAlarm+0x112>
				*minutes_ones = 0;
 30e:	10 82       	st	Z, r1
				/*this increments the tens digit when the ones digit reaches 9*/
				if(8 < *minutes_tens){
 310:	f7 01       	movw	r30, r14
 312:	80 81       	ld	r24, Z
 314:	89 30       	cpi	r24, 0x09	; 9
 316:	10 f0       	brcs	.+4      	; 0x31c <modifyAlarm+0xec>
					*minutes_tens = 0;
 318:	10 82       	st	Z, r1
 31a:	03 c0       	rjmp	.+6      	; 0x322 <modifyAlarm+0xf2>
					}else{
					(*minutes_tens)++;
 31c:	8f 5f       	subi	r24, 0xFF	; 255
 31e:	f7 01       	movw	r30, r14
 320:	80 83       	st	Z, r24
				}
				/*update the tens digit*/
				LCD_LINE_position(MODIFY_ALARM_LINE, cursor_loc - 1);
 322:	61 50       	subi	r22, 0x01	; 1
 324:	81 e0       	ldi	r24, 0x01	; 1
 326:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
				LCD_Write_Number(*minutes_tens);
 32a:	f7 01       	movw	r30, r14
 32c:	20 81       	ld	r18, Z
 32e:	30 e0       	ldi	r19, 0x00	; 0
 330:	40 e0       	ldi	r20, 0x00	; 0
 332:	50 e0       	ldi	r21, 0x00	; 0
 334:	60 e0       	ldi	r22, 0x00	; 0
 336:	70 e0       	ldi	r23, 0x00	; 0
 338:	80 e0       	ldi	r24, 0x00	; 0
 33a:	90 e0       	ldi	r25, 0x00	; 0
 33c:	0e 94 50 04 	call	0x8a0	; 0x8a0 <LCD_Write_Number>
 340:	03 c0       	rjmp	.+6      	; 0x348 <modifyAlarm+0x118>
				}else{
				(*minutes_ones)++;
 342:	8f 5f       	subi	r24, 0xFF	; 255
 344:	f5 01       	movw	r30, r10
 346:	80 83       	st	Z, r24
			}
			LCD_Write_Number(*minutes_ones);
 348:	f5 01       	movw	r30, r10
 34a:	20 81       	ld	r18, Z
 34c:	30 e0       	ldi	r19, 0x00	; 0
 34e:	40 e0       	ldi	r20, 0x00	; 0
 350:	50 e0       	ldi	r21, 0x00	; 0
 352:	60 e0       	ldi	r22, 0x00	; 0
 354:	70 e0       	ldi	r23, 0x00	; 0
 356:	80 e0       	ldi	r24, 0x00	; 0
 358:	90 e0       	ldi	r25, 0x00	; 0
 35a:	0e 94 50 04 	call	0x8a0	; 0x8a0 <LCD_Write_Number>
			/*to keep the cursor from modifying other digits*/
			LCD_LINE_position(MODIFY_ALARM_LINE, cursor_loc);
 35e:	60 91 70 00 	lds	r22, 0x0070	; 0x800070 <cursor_loc.2149>
 362:	81 e0       	ldi	r24, 0x01	; 1
 364:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
			break;
 368:	4b c0       	rjmp	.+150    	; 0x400 <__EEPROM_REGION_LENGTH__>
			/********************third case*********************/
			case SECONDS_TENS_LOC:
			/*to keep values between 0 and 5*/
			if(4 < *seconds_tens){
 36a:	f8 01       	movw	r30, r16
 36c:	80 81       	ld	r24, Z
 36e:	85 30       	cpi	r24, 0x05	; 5
 370:	10 f0       	brcs	.+4      	; 0x376 <modifyAlarm+0x146>
				*seconds_tens = 0;
 372:	10 82       	st	Z, r1
 374:	03 c0       	rjmp	.+6      	; 0x37c <modifyAlarm+0x14c>
				}else{
				(*seconds_tens)++;
 376:	8f 5f       	subi	r24, 0xFF	; 255
 378:	f8 01       	movw	r30, r16
 37a:	80 83       	st	Z, r24
			}
			LCD_Write_Number(*seconds_tens);
 37c:	f8 01       	movw	r30, r16
 37e:	20 81       	ld	r18, Z
 380:	30 e0       	ldi	r19, 0x00	; 0
 382:	40 e0       	ldi	r20, 0x00	; 0
 384:	50 e0       	ldi	r21, 0x00	; 0
 386:	60 e0       	ldi	r22, 0x00	; 0
 388:	70 e0       	ldi	r23, 0x00	; 0
 38a:	80 e0       	ldi	r24, 0x00	; 0
 38c:	90 e0       	ldi	r25, 0x00	; 0
 38e:	0e 94 50 04 	call	0x8a0	; 0x8a0 <LCD_Write_Number>
			/*to keep the cursor from modifying other digits*/
			LCD_LINE_position(MODIFY_ALARM_LINE, cursor_loc);
 392:	60 91 70 00 	lds	r22, 0x0070	; 0x800070 <cursor_loc.2149>
 396:	81 e0       	ldi	r24, 0x01	; 1
 398:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
			break;
 39c:	31 c0       	rjmp	.+98     	; 0x400 <__EEPROM_REGION_LENGTH__>
			/********************fourth case*********************/
			case SECONDS_ONES_LOC:
			/*to keep values between 0 and 9*/
			if(8 < *seconds_ones){
 39e:	f6 01       	movw	r30, r12
 3a0:	80 81       	ld	r24, Z
 3a2:	89 30       	cpi	r24, 0x09	; 9
 3a4:	d0 f0       	brcs	.+52     	; 0x3da <modifyAlarm+0x1aa>
				*seconds_ones = 0;
 3a6:	10 82       	st	Z, r1
				/*this increments the tens digit when the ones digit reaches 9*/
				if(4 < *seconds_tens){
 3a8:	f8 01       	movw	r30, r16
 3aa:	80 81       	ld	r24, Z
 3ac:	85 30       	cpi	r24, 0x05	; 5
 3ae:	10 f0       	brcs	.+4      	; 0x3b4 <modifyAlarm+0x184>
					*seconds_tens = 0;
 3b0:	10 82       	st	Z, r1
 3b2:	03 c0       	rjmp	.+6      	; 0x3ba <modifyAlarm+0x18a>
					}else{
					(*seconds_tens)++;
 3b4:	8f 5f       	subi	r24, 0xFF	; 255
 3b6:	f8 01       	movw	r30, r16
 3b8:	80 83       	st	Z, r24
				}
				/*update the tens digit*/
				LCD_LINE_position(MODIFY_ALARM_LINE, cursor_loc - 1);
 3ba:	61 50       	subi	r22, 0x01	; 1
 3bc:	81 e0       	ldi	r24, 0x01	; 1
 3be:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
				LCD_Write_Number(*seconds_tens);
 3c2:	f8 01       	movw	r30, r16
 3c4:	20 81       	ld	r18, Z
 3c6:	30 e0       	ldi	r19, 0x00	; 0
 3c8:	40 e0       	ldi	r20, 0x00	; 0
 3ca:	50 e0       	ldi	r21, 0x00	; 0
 3cc:	60 e0       	ldi	r22, 0x00	; 0
 3ce:	70 e0       	ldi	r23, 0x00	; 0
 3d0:	80 e0       	ldi	r24, 0x00	; 0
 3d2:	90 e0       	ldi	r25, 0x00	; 0
 3d4:	0e 94 50 04 	call	0x8a0	; 0x8a0 <LCD_Write_Number>
 3d8:	03 c0       	rjmp	.+6      	; 0x3e0 <modifyAlarm+0x1b0>
				}else{
				(*seconds_ones)++;
 3da:	8f 5f       	subi	r24, 0xFF	; 255
 3dc:	f6 01       	movw	r30, r12
 3de:	80 83       	st	Z, r24
			}
			LCD_Write_Number(*seconds_ones);
 3e0:	f6 01       	movw	r30, r12
 3e2:	20 81       	ld	r18, Z
 3e4:	30 e0       	ldi	r19, 0x00	; 0
 3e6:	40 e0       	ldi	r20, 0x00	; 0
 3e8:	50 e0       	ldi	r21, 0x00	; 0
 3ea:	60 e0       	ldi	r22, 0x00	; 0
 3ec:	70 e0       	ldi	r23, 0x00	; 0
 3ee:	80 e0       	ldi	r24, 0x00	; 0
 3f0:	90 e0       	ldi	r25, 0x00	; 0
 3f2:	0e 94 50 04 	call	0x8a0	; 0x8a0 <LCD_Write_Number>
			/*to keep the cursor from modifying other digits*/
			LCD_LINE_position(MODIFY_ALARM_LINE, cursor_loc);
 3f6:	60 91 70 00 	lds	r22, 0x0070	; 0x800070 <cursor_loc.2149>
 3fa:	81 e0       	ldi	r24, 0x01	; 1
 3fc:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
			break;
			/********************default*********************/
			default:
			break;
		}
		five_sec_timeout = 0;
 400:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <five_sec_timeout>
		}else{
		/*do nothing*/;
	}
	/************************************************************************/
	/*if the decrement button is pressed...*/
	BTN_pressed(DIO_PORTD, DIO_PIN6, &decrement);
 404:	ae 01       	movw	r20, r28
 406:	4d 5f       	subi	r20, 0xFD	; 253
 408:	5f 4f       	sbci	r21, 0xFF	; 255
 40a:	66 e0       	ldi	r22, 0x06	; 6
 40c:	83 e0       	ldi	r24, 0x03	; 3
 40e:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <BTN_pressed>
	if(decrement){
 412:	8b 81       	ldd	r24, Y+3	; 0x03
 414:	88 23       	and	r24, r24
 416:	09 f4       	brne	.+2      	; 0x41a <__EEPROM_REGION_LENGTH__+0x1a>
 418:	ae c0       	rjmp	.+348    	; 0x576 <__EEPROM_REGION_LENGTH__+0x176>
		/*check on which digit the cursor is standing*/
		switch(cursor_loc){
 41a:	60 91 70 00 	lds	r22, 0x0070	; 0x800070 <cursor_loc.2149>
 41e:	69 30       	cpi	r22, 0x09	; 9
 420:	31 f1       	breq	.+76     	; 0x46e <__EEPROM_REGION_LENGTH__+0x6e>
 422:	18 f4       	brcc	.+6      	; 0x42a <__EEPROM_REGION_LENGTH__+0x2a>
 424:	68 30       	cpi	r22, 0x08	; 8
 426:	41 f0       	breq	.+16     	; 0x438 <__EEPROM_REGION_LENGTH__+0x38>
 428:	a4 c0       	rjmp	.+328    	; 0x572 <__EEPROM_REGION_LENGTH__+0x172>
 42a:	6b 30       	cpi	r22, 0x0B	; 11
 42c:	09 f4       	brne	.+2      	; 0x430 <__EEPROM_REGION_LENGTH__+0x30>
 42e:	53 c0       	rjmp	.+166    	; 0x4d6 <__EEPROM_REGION_LENGTH__+0xd6>
 430:	6c 30       	cpi	r22, 0x0C	; 12
 432:	09 f4       	brne	.+2      	; 0x436 <__EEPROM_REGION_LENGTH__+0x36>
 434:	6b c0       	rjmp	.+214    	; 0x50c <__EEPROM_REGION_LENGTH__+0x10c>
 436:	9d c0       	rjmp	.+314    	; 0x572 <__EEPROM_REGION_LENGTH__+0x172>
			/********************first case*********************/
			case MINUTES_TENS_LOC:
			/*to keep values between 0 and 9*/
			if(0 == *minutes_tens){
 438:	f7 01       	movw	r30, r14
 43a:	80 81       	ld	r24, Z
 43c:	81 11       	cpse	r24, r1
 43e:	03 c0       	rjmp	.+6      	; 0x446 <__EEPROM_REGION_LENGTH__+0x46>
				*minutes_tens = 9;
 440:	89 e0       	ldi	r24, 0x09	; 9
 442:	80 83       	st	Z, r24
 444:	03 c0       	rjmp	.+6      	; 0x44c <__EEPROM_REGION_LENGTH__+0x4c>
				}else{
				(*minutes_tens)--;
 446:	81 50       	subi	r24, 0x01	; 1
 448:	f7 01       	movw	r30, r14
 44a:	80 83       	st	Z, r24
			}
			LCD_Write_Number(*minutes_tens);
 44c:	f7 01       	movw	r30, r14
 44e:	20 81       	ld	r18, Z
 450:	30 e0       	ldi	r19, 0x00	; 0
 452:	40 e0       	ldi	r20, 0x00	; 0
 454:	50 e0       	ldi	r21, 0x00	; 0
 456:	60 e0       	ldi	r22, 0x00	; 0
 458:	70 e0       	ldi	r23, 0x00	; 0
 45a:	80 e0       	ldi	r24, 0x00	; 0
 45c:	90 e0       	ldi	r25, 0x00	; 0
 45e:	0e 94 50 04 	call	0x8a0	; 0x8a0 <LCD_Write_Number>
			/*to keep the cursor from modifying other digits*/
			LCD_LINE_position(MODIFY_ALARM_LINE, cursor_loc);
 462:	60 91 70 00 	lds	r22, 0x0070	; 0x800070 <cursor_loc.2149>
 466:	81 e0       	ldi	r24, 0x01	; 1
 468:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
			break;
 46c:	82 c0       	rjmp	.+260    	; 0x572 <__EEPROM_REGION_LENGTH__+0x172>
			/********************second case*********************/
			case MINUTES_ONES_LOC:
			/*to keep values between 0 and 9*/
			if(0 == *minutes_ones){
 46e:	f5 01       	movw	r30, r10
 470:	80 81       	ld	r24, Z
 472:	81 11       	cpse	r24, r1
 474:	1c c0       	rjmp	.+56     	; 0x4ae <__EEPROM_REGION_LENGTH__+0xae>
				*minutes_ones = 9;
 476:	89 e0       	ldi	r24, 0x09	; 9
 478:	80 83       	st	Z, r24
				/*this decrements the tens digit when the ones digit reaches 0*/
				if(0 == *minutes_tens){
 47a:	f7 01       	movw	r30, r14
 47c:	80 81       	ld	r24, Z
 47e:	81 11       	cpse	r24, r1
 480:	03 c0       	rjmp	.+6      	; 0x488 <__EEPROM_REGION_LENGTH__+0x88>
					*minutes_tens = 9;
 482:	89 e0       	ldi	r24, 0x09	; 9
 484:	80 83       	st	Z, r24
 486:	03 c0       	rjmp	.+6      	; 0x48e <__EEPROM_REGION_LENGTH__+0x8e>
					}else{
					(*minutes_tens)--;
 488:	81 50       	subi	r24, 0x01	; 1
 48a:	f7 01       	movw	r30, r14
 48c:	80 83       	st	Z, r24
				}
				/*update the tens digit*/
				LCD_LINE_position(MODIFY_ALARM_LINE, cursor_loc - 1);
 48e:	61 50       	subi	r22, 0x01	; 1
 490:	81 e0       	ldi	r24, 0x01	; 1
 492:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
				LCD_Write_Number(*minutes_tens);
 496:	f7 01       	movw	r30, r14
 498:	20 81       	ld	r18, Z
 49a:	30 e0       	ldi	r19, 0x00	; 0
 49c:	40 e0       	ldi	r20, 0x00	; 0
 49e:	50 e0       	ldi	r21, 0x00	; 0
 4a0:	60 e0       	ldi	r22, 0x00	; 0
 4a2:	70 e0       	ldi	r23, 0x00	; 0
 4a4:	80 e0       	ldi	r24, 0x00	; 0
 4a6:	90 e0       	ldi	r25, 0x00	; 0
 4a8:	0e 94 50 04 	call	0x8a0	; 0x8a0 <LCD_Write_Number>
 4ac:	03 c0       	rjmp	.+6      	; 0x4b4 <__EEPROM_REGION_LENGTH__+0xb4>
				}else{
				(*minutes_ones)--;
 4ae:	81 50       	subi	r24, 0x01	; 1
 4b0:	f5 01       	movw	r30, r10
 4b2:	80 83       	st	Z, r24
			}
			LCD_Write_Number(*minutes_ones);
 4b4:	f5 01       	movw	r30, r10
 4b6:	20 81       	ld	r18, Z
 4b8:	30 e0       	ldi	r19, 0x00	; 0
 4ba:	40 e0       	ldi	r20, 0x00	; 0
 4bc:	50 e0       	ldi	r21, 0x00	; 0
 4be:	60 e0       	ldi	r22, 0x00	; 0
 4c0:	70 e0       	ldi	r23, 0x00	; 0
 4c2:	80 e0       	ldi	r24, 0x00	; 0
 4c4:	90 e0       	ldi	r25, 0x00	; 0
 4c6:	0e 94 50 04 	call	0x8a0	; 0x8a0 <LCD_Write_Number>
			/*to keep the cursor from modifying other digits*/
			LCD_LINE_position(MODIFY_ALARM_LINE, cursor_loc);
 4ca:	60 91 70 00 	lds	r22, 0x0070	; 0x800070 <cursor_loc.2149>
 4ce:	81 e0       	ldi	r24, 0x01	; 1
 4d0:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
			break;
 4d4:	4e c0       	rjmp	.+156    	; 0x572 <__EEPROM_REGION_LENGTH__+0x172>
			/********************third case*********************/
			case SECONDS_TENS_LOC:
			/*to keep values between 0 and 5*/
			if(0 == *seconds_tens){
 4d6:	f8 01       	movw	r30, r16
 4d8:	80 81       	ld	r24, Z
 4da:	81 11       	cpse	r24, r1
 4dc:	03 c0       	rjmp	.+6      	; 0x4e4 <__EEPROM_REGION_LENGTH__+0xe4>
				*seconds_tens = 5;
 4de:	85 e0       	ldi	r24, 0x05	; 5
 4e0:	80 83       	st	Z, r24
 4e2:	03 c0       	rjmp	.+6      	; 0x4ea <__EEPROM_REGION_LENGTH__+0xea>
				}else{
				(*seconds_tens)--;
 4e4:	81 50       	subi	r24, 0x01	; 1
 4e6:	f8 01       	movw	r30, r16
 4e8:	80 83       	st	Z, r24
			}
			LCD_Write_Number(*seconds_tens);
 4ea:	f8 01       	movw	r30, r16
 4ec:	20 81       	ld	r18, Z
 4ee:	30 e0       	ldi	r19, 0x00	; 0
 4f0:	40 e0       	ldi	r20, 0x00	; 0
 4f2:	50 e0       	ldi	r21, 0x00	; 0
 4f4:	60 e0       	ldi	r22, 0x00	; 0
 4f6:	70 e0       	ldi	r23, 0x00	; 0
 4f8:	80 e0       	ldi	r24, 0x00	; 0
 4fa:	90 e0       	ldi	r25, 0x00	; 0
 4fc:	0e 94 50 04 	call	0x8a0	; 0x8a0 <LCD_Write_Number>
			/*to keep the cursor from modifying other digits*/
			LCD_LINE_position(MODIFY_ALARM_LINE, cursor_loc);
 500:	60 91 70 00 	lds	r22, 0x0070	; 0x800070 <cursor_loc.2149>
 504:	81 e0       	ldi	r24, 0x01	; 1
 506:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
			break;
 50a:	33 c0       	rjmp	.+102    	; 0x572 <__EEPROM_REGION_LENGTH__+0x172>
			/********************fourth case*********************/
			case SECONDS_ONES_LOC:
			/*to keep values between 0 and 9*/
			if(0 == *seconds_ones){
 50c:	f6 01       	movw	r30, r12
 50e:	80 81       	ld	r24, Z
 510:	81 11       	cpse	r24, r1
 512:	1c c0       	rjmp	.+56     	; 0x54c <__EEPROM_REGION_LENGTH__+0x14c>
				*seconds_ones = 9;
 514:	89 e0       	ldi	r24, 0x09	; 9
 516:	80 83       	st	Z, r24
				/*this decrements the tens digit when the ones digit reaches 0*/
				if(0 == *seconds_tens){
 518:	f8 01       	movw	r30, r16
 51a:	80 81       	ld	r24, Z
 51c:	81 11       	cpse	r24, r1
 51e:	03 c0       	rjmp	.+6      	; 0x526 <__EEPROM_REGION_LENGTH__+0x126>
					*seconds_tens = 5;
 520:	85 e0       	ldi	r24, 0x05	; 5
 522:	80 83       	st	Z, r24
 524:	03 c0       	rjmp	.+6      	; 0x52c <__EEPROM_REGION_LENGTH__+0x12c>
					}else{
					(*seconds_tens)--;
 526:	81 50       	subi	r24, 0x01	; 1
 528:	f8 01       	movw	r30, r16
 52a:	80 83       	st	Z, r24
				}
				/*update the tens digit*/
				LCD_LINE_position(MODIFY_ALARM_LINE, cursor_loc - 1);
 52c:	61 50       	subi	r22, 0x01	; 1
 52e:	81 e0       	ldi	r24, 0x01	; 1
 530:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
				LCD_Write_Number(*seconds_tens);
 534:	f8 01       	movw	r30, r16
 536:	20 81       	ld	r18, Z
 538:	30 e0       	ldi	r19, 0x00	; 0
 53a:	40 e0       	ldi	r20, 0x00	; 0
 53c:	50 e0       	ldi	r21, 0x00	; 0
 53e:	60 e0       	ldi	r22, 0x00	; 0
 540:	70 e0       	ldi	r23, 0x00	; 0
 542:	80 e0       	ldi	r24, 0x00	; 0
 544:	90 e0       	ldi	r25, 0x00	; 0
 546:	0e 94 50 04 	call	0x8a0	; 0x8a0 <LCD_Write_Number>
 54a:	03 c0       	rjmp	.+6      	; 0x552 <__EEPROM_REGION_LENGTH__+0x152>
				}else{
				(*seconds_ones)--;
 54c:	81 50       	subi	r24, 0x01	; 1
 54e:	f6 01       	movw	r30, r12
 550:	80 83       	st	Z, r24
			}
			LCD_Write_Number(*seconds_ones);
 552:	f6 01       	movw	r30, r12
 554:	20 81       	ld	r18, Z
 556:	30 e0       	ldi	r19, 0x00	; 0
 558:	40 e0       	ldi	r20, 0x00	; 0
 55a:	50 e0       	ldi	r21, 0x00	; 0
 55c:	60 e0       	ldi	r22, 0x00	; 0
 55e:	70 e0       	ldi	r23, 0x00	; 0
 560:	80 e0       	ldi	r24, 0x00	; 0
 562:	90 e0       	ldi	r25, 0x00	; 0
 564:	0e 94 50 04 	call	0x8a0	; 0x8a0 <LCD_Write_Number>
			/*to keep the cursor from modifying other digits*/
			LCD_LINE_position(MODIFY_ALARM_LINE, cursor_loc);
 568:	60 91 70 00 	lds	r22, 0x0070	; 0x800070 <cursor_loc.2149>
 56c:	81 e0       	ldi	r24, 0x01	; 1
 56e:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
			break;
			/********************default*********************/
			default:
			break;
		}
		five_sec_timeout = 0;
 572:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <five_sec_timeout>
		}else{
		/*do nothing*/;
	}
	/************************************************************************/
	/*if the move right button is pressed...*/
	BTN_pressed(DIO_PORTD, DIO_PIN7, &move_right);
 576:	ae 01       	movw	r20, r28
 578:	4c 5f       	subi	r20, 0xFC	; 252
 57a:	5f 4f       	sbci	r21, 0xFF	; 255
 57c:	67 e0       	ldi	r22, 0x07	; 7
 57e:	83 e0       	ldi	r24, 0x03	; 3
 580:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <BTN_pressed>
	if(move_right){
 584:	8c 81       	ldd	r24, Y+4	; 0x04
 586:	88 23       	and	r24, r24
 588:	b9 f0       	breq	.+46     	; 0x5b8 <__EEPROM_REGION_LENGTH__+0x1b8>
		/*modify cursor location*/
		cursor_loc--;
 58a:	80 91 70 00 	lds	r24, 0x0070	; 0x800070 <cursor_loc.2149>
 58e:	81 50       	subi	r24, 0x01	; 1
 590:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <cursor_loc.2149>
		if(COLON_LOC == cursor_loc){
 594:	8a 30       	cpi	r24, 0x0A	; 10
 596:	21 f4       	brne	.+8      	; 0x5a0 <__EEPROM_REGION_LENGTH__+0x1a0>
			cursor_loc = MINUTES_ONES_LOC;
 598:	89 e0       	ldi	r24, 0x09	; 9
 59a:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <cursor_loc.2149>
 59e:	05 c0       	rjmp	.+10     	; 0x5aa <__EEPROM_REGION_LENGTH__+0x1aa>
			/*to get back to the  start location*/
			} else if((MINUTES_TENS_LOC - 1) == cursor_loc){
 5a0:	87 30       	cpi	r24, 0x07	; 7
 5a2:	19 f4       	brne	.+6      	; 0x5aa <__EEPROM_REGION_LENGTH__+0x1aa>
			cursor_loc = SECONDS_ONES_LOC;
 5a4:	8c e0       	ldi	r24, 0x0C	; 12
 5a6:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <cursor_loc.2149>
			} else{
			/*do nothing*/;
		}
		/*move the cursor*/
		LCD_LINE_position(MODIFY_ALARM_LINE, cursor_loc);
 5aa:	60 91 70 00 	lds	r22, 0x0070	; 0x800070 <cursor_loc.2149>
 5ae:	81 e0       	ldi	r24, 0x01	; 1
 5b0:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
		five_sec_timeout = 0;
 5b4:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <five_sec_timeout>
		}else{
		/*do nothing*/;
	}
	return state_error;
}
 5b8:	81 e0       	ldi	r24, 0x01	; 1
 5ba:	0f 90       	pop	r0
 5bc:	0f 90       	pop	r0
 5be:	0f 90       	pop	r0
 5c0:	0f 90       	pop	r0
 5c2:	df 91       	pop	r29
 5c4:	cf 91       	pop	r28
 5c6:	1f 91       	pop	r17
 5c8:	0f 91       	pop	r16
 5ca:	ff 90       	pop	r15
 5cc:	ef 90       	pop	r14
 5ce:	df 90       	pop	r13
 5d0:	cf 90       	pop	r12
 5d2:	bf 90       	pop	r11
 5d4:	af 90       	pop	r10
 5d6:	08 95       	ret

Disassembly of section .text.alarm_scheduler_init:

00001d52 <alarm_scheduler_init>:
*	Description: Initializes required drivers.
*/
ERROR_STATE alarm_scheduler_init(){
	ERROR_STATE state_error = SUCCESS;
	/*Buttons*/
	BTN_Initialization(DIO_PORTD, DIO_PIN3);
    1d52:	63 e0       	ldi	r22, 0x03	; 3
    1d54:	83 e0       	ldi	r24, 0x03	; 3
    1d56:	0e 94 48 10 	call	0x2090	; 0x2090 <BTN_Initialization>
	BTN_Initialization(DIO_PORTD, DIO_PIN5);
    1d5a:	65 e0       	ldi	r22, 0x05	; 5
    1d5c:	83 e0       	ldi	r24, 0x03	; 3
    1d5e:	0e 94 48 10 	call	0x2090	; 0x2090 <BTN_Initialization>
	BTN_Initialization(DIO_PORTD, DIO_PIN6);
    1d62:	66 e0       	ldi	r22, 0x06	; 6
    1d64:	83 e0       	ldi	r24, 0x03	; 3
    1d66:	0e 94 48 10 	call	0x2090	; 0x2090 <BTN_Initialization>
	BTN_Initialization(DIO_PORTD, DIO_PIN7);
    1d6a:	67 e0       	ldi	r22, 0x07	; 7
    1d6c:	83 e0       	ldi	r24, 0x03	; 3
    1d6e:	0e 94 48 10 	call	0x2090	; 0x2090 <BTN_Initialization>
	/*LCD*/
	LCD_Initialize();
    1d72:	0e 94 96 0c 	call	0x192c	; 0x192c <LCD_Initialize>
	/*Timers*/
	Timer1_Initialize();
    1d76:	0e 94 11 0f 	call	0x1e22	; 0x1e22 <Timer1_Initialize>
	return state_error;
}
    1d7a:	81 e0       	ldi	r24, 0x01	; 1
    1d7c:	08 95       	ret

Disassembly of section .text.printAlarm:

00001242 <printAlarm>:
*	Inputs: minutes, seconds, and the location to print the alarm.
*	Outputs: either success or fail.
*	Description: Prints the alarm on the LCD and returns the cursor to its original location.
*	The alarm is printed in the following format 'MM:SS'
*/
ERROR_STATE printAlarm(UINT8_t minutes, UINT8_t seconds,LCD_LINES Line_Pos, UINT8_t cursor_loc){
    1242:	ef 92       	push	r14
    1244:	ff 92       	push	r15
    1246:	0f 93       	push	r16
    1248:	1f 93       	push	r17
    124a:	cf 93       	push	r28
    124c:	df 93       	push	r29
    124e:	08 2f       	mov	r16, r24
    1250:	16 2f       	mov	r17, r22
    1252:	f4 2e       	mov	r15, r20
    1254:	e2 2e       	mov	r14, r18
	ERROR_STATE state_error = SUCCESS;
	/*modify cursor position*/
	LCD_LINE_position(Line_Pos, cursor_loc);
    1256:	62 2f       	mov	r22, r18
    1258:	84 2f       	mov	r24, r20
    125a:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
	/*print the alarm*/
	LCD_Write_Number(minutes / 10);
    125e:	cd ec       	ldi	r28, 0xCD	; 205
    1260:	0c 9f       	mul	r16, r28
    1262:	d1 2d       	mov	r29, r1
    1264:	11 24       	eor	r1, r1
    1266:	d6 95       	lsr	r29
    1268:	d6 95       	lsr	r29
    126a:	d6 95       	lsr	r29
    126c:	2d 2f       	mov	r18, r29
    126e:	30 e0       	ldi	r19, 0x00	; 0
    1270:	40 e0       	ldi	r20, 0x00	; 0
    1272:	50 e0       	ldi	r21, 0x00	; 0
    1274:	60 e0       	ldi	r22, 0x00	; 0
    1276:	70 e0       	ldi	r23, 0x00	; 0
    1278:	80 e0       	ldi	r24, 0x00	; 0
    127a:	90 e0       	ldi	r25, 0x00	; 0
    127c:	0e 94 50 04 	call	0x8a0	; 0x8a0 <LCD_Write_Number>
	LCD_Write_Number(minutes % 10);
    1280:	dd 0f       	add	r29, r29
    1282:	8d 2f       	mov	r24, r29
    1284:	88 0f       	add	r24, r24
    1286:	88 0f       	add	r24, r24
    1288:	d8 0f       	add	r29, r24
    128a:	20 2f       	mov	r18, r16
    128c:	2d 1b       	sub	r18, r29
    128e:	30 e0       	ldi	r19, 0x00	; 0
    1290:	40 e0       	ldi	r20, 0x00	; 0
    1292:	50 e0       	ldi	r21, 0x00	; 0
    1294:	60 e0       	ldi	r22, 0x00	; 0
    1296:	70 e0       	ldi	r23, 0x00	; 0
    1298:	80 e0       	ldi	r24, 0x00	; 0
    129a:	90 e0       	ldi	r25, 0x00	; 0
    129c:	0e 94 50 04 	call	0x8a0	; 0x8a0 <LCD_Write_Number>
	LCD_Write_Character(':');
    12a0:	8a e3       	ldi	r24, 0x3A	; 58
    12a2:	0e 94 ef 07 	call	0xfde	; 0xfde <LCD_Write_Character>
	LCD_Write_Number(seconds / 10);
    12a6:	1c 9f       	mul	r17, r28
    12a8:	c1 2d       	mov	r28, r1
    12aa:	11 24       	eor	r1, r1
    12ac:	c6 95       	lsr	r28
    12ae:	c6 95       	lsr	r28
    12b0:	c6 95       	lsr	r28
    12b2:	2c 2f       	mov	r18, r28
    12b4:	30 e0       	ldi	r19, 0x00	; 0
    12b6:	40 e0       	ldi	r20, 0x00	; 0
    12b8:	50 e0       	ldi	r21, 0x00	; 0
    12ba:	60 e0       	ldi	r22, 0x00	; 0
    12bc:	70 e0       	ldi	r23, 0x00	; 0
    12be:	80 e0       	ldi	r24, 0x00	; 0
    12c0:	90 e0       	ldi	r25, 0x00	; 0
    12c2:	0e 94 50 04 	call	0x8a0	; 0x8a0 <LCD_Write_Number>
	LCD_Write_Number(seconds % 10);
    12c6:	cc 0f       	add	r28, r28
    12c8:	8c 2f       	mov	r24, r28
    12ca:	88 0f       	add	r24, r24
    12cc:	88 0f       	add	r24, r24
    12ce:	c8 0f       	add	r28, r24
    12d0:	21 2f       	mov	r18, r17
    12d2:	2c 1b       	sub	r18, r28
    12d4:	30 e0       	ldi	r19, 0x00	; 0
    12d6:	40 e0       	ldi	r20, 0x00	; 0
    12d8:	50 e0       	ldi	r21, 0x00	; 0
    12da:	60 e0       	ldi	r22, 0x00	; 0
    12dc:	70 e0       	ldi	r23, 0x00	; 0
    12de:	80 e0       	ldi	r24, 0x00	; 0
    12e0:	90 e0       	ldi	r25, 0x00	; 0
    12e2:	0e 94 50 04 	call	0x8a0	; 0x8a0 <LCD_Write_Number>
	/*return to th original location*/
	LCD_LINE_position(Line_Pos, cursor_loc);
    12e6:	6e 2d       	mov	r22, r14
    12e8:	8f 2d       	mov	r24, r15
    12ea:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
	
	return state_error;
}
    12ee:	81 e0       	ldi	r24, 0x01	; 1
    12f0:	df 91       	pop	r29
    12f2:	cf 91       	pop	r28
    12f4:	1f 91       	pop	r17
    12f6:	0f 91       	pop	r16
    12f8:	ff 90       	pop	r15
    12fa:	ef 90       	pop	r14
    12fc:	08 95       	ret

Disassembly of section .text.Check_Button_Update:

0000179c <Check_Button_Update>:
/*
*	Inputs: addresses to boolean variables in which the button status will be stored.
*	Outputs: None
*	Description: stores sets the variable when the relative button is pressed.
*/
void Check_Button_Update(bool* button_1_val,bool* button_2_val,bool* button_3_val,bool* button_4_val){
    179c:	cf 92       	push	r12
    179e:	df 92       	push	r13
    17a0:	ef 92       	push	r14
    17a2:	ff 92       	push	r15
    17a4:	0f 93       	push	r16
    17a6:	1f 93       	push	r17
    17a8:	cf 93       	push	r28
    17aa:	df 93       	push	r29
    17ac:	7c 01       	movw	r14, r24
    17ae:	8b 01       	movw	r16, r22
    17b0:	6a 01       	movw	r12, r20
    17b2:	e9 01       	movw	r28, r18
	while(!(*button_1_val) && !(*button_2_val) && !(*button_3_val) && !(*button_4_val)){
    17b4:	20 c0       	rjmp	.+64     	; 0x17f6 <Check_Button_Update+0x5a>
		if(usr_def_alarms > 0){
    17b6:	80 91 71 00 	lds	r24, 0x0071	; 0x800071 <usr_def_alarms>
    17ba:	88 23       	and	r24, r24
    17bc:	29 f0       	breq	.+10     	; 0x17c8 <Check_Button_Update+0x2c>
			BTN_pressed(DIO_PORTD, DIO_PIN7, button_1_val);
    17be:	a7 01       	movw	r20, r14
    17c0:	67 e0       	ldi	r22, 0x07	; 7
    17c2:	83 e0       	ldi	r24, 0x03	; 3
    17c4:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <BTN_pressed>
			}else{
			/*do nothing*/;
		}
		if(usr_def_alarms > 1){
    17c8:	80 91 71 00 	lds	r24, 0x0071	; 0x800071 <usr_def_alarms>
    17cc:	82 30       	cpi	r24, 0x02	; 2
    17ce:	28 f0       	brcs	.+10     	; 0x17da <Check_Button_Update+0x3e>
			BTN_pressed(DIO_PORTD, DIO_PIN6, button_2_val);
    17d0:	a8 01       	movw	r20, r16
    17d2:	66 e0       	ldi	r22, 0x06	; 6
    17d4:	83 e0       	ldi	r24, 0x03	; 3
    17d6:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <BTN_pressed>
			}else{
			/*do nothing*/;
		}
		if(usr_def_alarms > 2){
    17da:	80 91 71 00 	lds	r24, 0x0071	; 0x800071 <usr_def_alarms>
    17de:	83 30       	cpi	r24, 0x03	; 3
    17e0:	28 f0       	brcs	.+10     	; 0x17ec <Check_Button_Update+0x50>
			BTN_pressed(DIO_PORTD, DIO_PIN5, button_3_val);
    17e2:	a6 01       	movw	r20, r12
    17e4:	65 e0       	ldi	r22, 0x05	; 5
    17e6:	83 e0       	ldi	r24, 0x03	; 3
    17e8:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <BTN_pressed>
			}else{
			/*do nothing*/;
		}
		BTN_pressed(DIO_PORTD, DIO_PIN3, button_4_val);
    17ec:	ae 01       	movw	r20, r28
    17ee:	63 e0       	ldi	r22, 0x03	; 3
    17f0:	83 e0       	ldi	r24, 0x03	; 3
    17f2:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <BTN_pressed>
*	Inputs: addresses to boolean variables in which the button status will be stored.
*	Outputs: None
*	Description: stores sets the variable when the relative button is pressed.
*/
void Check_Button_Update(bool* button_1_val,bool* button_2_val,bool* button_3_val,bool* button_4_val){
	while(!(*button_1_val) && !(*button_2_val) && !(*button_3_val) && !(*button_4_val)){
    17f6:	f7 01       	movw	r30, r14
    17f8:	80 81       	ld	r24, Z
    17fa:	81 11       	cpse	r24, r1
    17fc:	0b c0       	rjmp	.+22     	; 0x1814 <Check_Button_Update+0x78>
    17fe:	f8 01       	movw	r30, r16
    1800:	80 81       	ld	r24, Z
    1802:	81 11       	cpse	r24, r1
    1804:	07 c0       	rjmp	.+14     	; 0x1814 <Check_Button_Update+0x78>
    1806:	f6 01       	movw	r30, r12
    1808:	80 81       	ld	r24, Z
    180a:	81 11       	cpse	r24, r1
    180c:	03 c0       	rjmp	.+6      	; 0x1814 <Check_Button_Update+0x78>
    180e:	88 81       	ld	r24, Y
    1810:	88 23       	and	r24, r24
    1812:	89 f2       	breq	.-94     	; 0x17b6 <Check_Button_Update+0x1a>
			}else{
			/*do nothing*/;
		}
		BTN_pressed(DIO_PORTD, DIO_PIN3, button_4_val);
	}
}
    1814:	df 91       	pop	r29
    1816:	cf 91       	pop	r28
    1818:	1f 91       	pop	r17
    181a:	0f 91       	pop	r16
    181c:	ff 90       	pop	r15
    181e:	ef 90       	pop	r14
    1820:	df 90       	pop	r13
    1822:	cf 90       	pop	r12
    1824:	08 95       	ret

Disassembly of section .text.Display_Action_Buttons:

00001a90 <Display_Action_Buttons>:
/*
*	Inputs: number of buttons to be displayed
*	Outputs: None
*	Description: Displays the action buttons at the bottom of the screen.
*/
void Display_Action_Buttons(Buttons_Display Num_Of_Buttons){
    1a90:	cf 93       	push	r28
    1a92:	c8 2f       	mov	r28, r24
	LCD_LINE_position(LCD_LINE4, 5);
    1a94:	65 e0       	ldi	r22, 0x05	; 5
    1a96:	83 e0       	ldi	r24, 0x03	; 3
    1a98:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
	LCD_Write_Character('1');
    1a9c:	81 e3       	ldi	r24, 0x31	; 49
    1a9e:	0e 94 ef 07 	call	0xfde	; 0xfde <LCD_Write_Character>
	LCD_LINE_position(LCD_LINE4, 8);
    1aa2:	68 e0       	ldi	r22, 0x08	; 8
    1aa4:	83 e0       	ldi	r24, 0x03	; 3
    1aa6:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
	LCD_Write_Character('2');
    1aaa:	82 e3       	ldi	r24, 0x32	; 50
    1aac:	0e 94 ef 07 	call	0xfde	; 0xfde <LCD_Write_Character>
	LCD_LINE_position(LCD_LINE4, 11);
    1ab0:	6b e0       	ldi	r22, 0x0B	; 11
    1ab2:	83 e0       	ldi	r24, 0x03	; 3
    1ab4:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
	if(Num_Of_Buttons == Three_Buttons){
    1ab8:	c3 30       	cpi	r28, 0x03	; 3
    1aba:	21 f4       	brne	.+8      	; 0x1ac4 <Display_Action_Buttons+0x34>
		LCD_Write_Character('X');
    1abc:	88 e5       	ldi	r24, 0x58	; 88
    1abe:	0e 94 ef 07 	call	0xfde	; 0xfde <LCD_Write_Character>
    1ac2:	17 c0       	rjmp	.+46     	; 0x1af2 <Display_Action_Buttons+0x62>
		}else{
		if(Num_Of_Buttons == Three_Buttons_No_X){
    1ac4:	c2 30       	cpi	r28, 0x02	; 2
    1ac6:	59 f4       	brne	.+22     	; 0x1ade <Display_Action_Buttons+0x4e>
			LCD_Write_Character('3');
    1ac8:	83 e3       	ldi	r24, 0x33	; 51
    1aca:	0e 94 ef 07 	call	0xfde	; 0xfde <LCD_Write_Character>
			LCD_LINE_position(LCD_LINE4,14);
    1ace:	6e e0       	ldi	r22, 0x0E	; 14
    1ad0:	83 e0       	ldi	r24, 0x03	; 3
    1ad2:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
			LCD_Write_Character('|');
    1ad6:	8c e7       	ldi	r24, 0x7C	; 124
    1ad8:	0e 94 ef 07 	call	0xfde	; 0xfde <LCD_Write_Character>
    1adc:	0a c0       	rjmp	.+20     	; 0x1af2 <Display_Action_Buttons+0x62>
			}else{
			LCD_Write_Character('3');
    1ade:	83 e3       	ldi	r24, 0x33	; 51
    1ae0:	0e 94 ef 07 	call	0xfde	; 0xfde <LCD_Write_Character>
			LCD_LINE_position(LCD_LINE4, 14);
    1ae4:	6e e0       	ldi	r22, 0x0E	; 14
    1ae6:	83 e0       	ldi	r24, 0x03	; 3
    1ae8:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
			LCD_Write_Character('X');
    1aec:	88 e5       	ldi	r24, 0x58	; 88
    1aee:	0e 94 ef 07 	call	0xfde	; 0xfde <LCD_Write_Character>
		}
	}
}
    1af2:	cf 91       	pop	r28
    1af4:	08 95       	ret

Disassembly of section .text.modify_set_alarm:

00000a70 <modify_set_alarm>:
/*
*	Inputs: alarm number and addresses of tens and ones units of both minutes and seconds.
*	Outputs: None
*	Description: Modifies the alarm provided set by the user.
*/
void modify_set_alarm(alarms alarm_num, UINT8_t* minutes_tens, UINT8_t* minutes_ones, UINT8_t* seconds_tens, UINT8_t* seconds_ones){
 a70:	8f 92       	push	r8
 a72:	9f 92       	push	r9
 a74:	af 92       	push	r10
 a76:	bf 92       	push	r11
 a78:	cf 92       	push	r12
 a7a:	df 92       	push	r13
 a7c:	ef 92       	push	r14
 a7e:	ff 92       	push	r15
 a80:	0f 93       	push	r16
 a82:	1f 93       	push	r17
 a84:	cf 93       	push	r28
 a86:	df 93       	push	r29
 a88:	98 2e       	mov	r9, r24
 a8a:	5b 01       	movw	r10, r22
 a8c:	6a 01       	movw	r12, r20
 a8e:	79 01       	movw	r14, r18
 a90:	e8 01       	movw	r28, r16
	LCD_Clear();
 a92:	0e 94 52 10 	call	0x20a4	; 0x20a4 <LCD_Clear>
	LCD_Write_String(" **Modify alarm ");
 a96:	6f e7       	ldi	r22, 0x7F	; 127
 a98:	71 e0       	ldi	r23, 0x01	; 1
 a9a:	80 e0       	ldi	r24, 0x00	; 0
 a9c:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <LCD_Write_String>
	LCD_Write_Number(alarm_num + 1);
 aa0:	09 2d       	mov	r16, r9
 aa2:	10 e0       	ldi	r17, 0x00	; 0
 aa4:	a8 01       	movw	r20, r16
 aa6:	4f 5f       	subi	r20, 0xFF	; 255
 aa8:	5f 4f       	sbci	r21, 0xFF	; 255
 aaa:	95 2f       	mov	r25, r21
 aac:	99 0f       	add	r25, r25
 aae:	99 0b       	sbc	r25, r25
 ab0:	24 2f       	mov	r18, r20
 ab2:	35 2f       	mov	r19, r21
 ab4:	49 2f       	mov	r20, r25
 ab6:	59 2f       	mov	r21, r25
 ab8:	69 2f       	mov	r22, r25
 aba:	79 2f       	mov	r23, r25
 abc:	89 2f       	mov	r24, r25
 abe:	0e 94 50 04 	call	0x8a0	; 0x8a0 <LCD_Write_Number>
	LCD_Write_String("**");
 ac2:	60 e9       	ldi	r22, 0x90	; 144
 ac4:	71 e0       	ldi	r23, 0x01	; 1
 ac6:	80 e0       	ldi	r24, 0x00	; 0
 ac8:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <LCD_Write_String>
	/*print buttons action*/
	LCD_LINE_position(LCD_LINE4, 5);
 acc:	65 e0       	ldi	r22, 0x05	; 5
 ace:	83 e0       	ldi	r24, 0x03	; 3
 ad0:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
	LCD_Write_Character(0x7F);
 ad4:	8f e7       	ldi	r24, 0x7F	; 127
 ad6:	0e 94 ef 07 	call	0xfde	; 0xfde <LCD_Write_Character>
	LCD_LINE_position(LCD_LINE4, 8);
 ada:	68 e0       	ldi	r22, 0x08	; 8
 adc:	83 e0       	ldi	r24, 0x03	; 3
 ade:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
	LCD_Write_Character(0x2D);
 ae2:	8d e2       	ldi	r24, 0x2D	; 45
 ae4:	0e 94 ef 07 	call	0xfde	; 0xfde <LCD_Write_Character>
	LCD_LINE_position(LCD_LINE4, 11);
 ae8:	6b e0       	ldi	r22, 0x0B	; 11
 aea:	83 e0       	ldi	r24, 0x03	; 3
 aec:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
	LCD_Write_Character(0x2B);
 af0:	8b e2       	ldi	r24, 0x2B	; 43
 af2:	0e 94 ef 07 	call	0xfde	; 0xfde <LCD_Write_Character>
	LCD_LINE_position(LCD_LINE4, 14);
 af6:	6e e0       	ldi	r22, 0x0E	; 14
 af8:	83 e0       	ldi	r24, 0x03	; 3
 afa:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
	LCD_Write_Character(0x7E);
 afe:	8e e7       	ldi	r24, 0x7E	; 126
 b00:	0e 94 ef 07 	call	0xfde	; 0xfde <LCD_Write_Character>
	/*print old alarm values*/
	printAlarm(alarm_ptr_arr[alarm_num].minutes, alarm_ptr_arr[alarm_num].seconds,LCD_LINE2, 8);
 b04:	c8 01       	movw	r24, r16
 b06:	88 0f       	add	r24, r24
 b08:	99 1f       	adc	r25, r25
 b0a:	88 0f       	add	r24, r24
 b0c:	99 1f       	adc	r25, r25
 b0e:	9c 01       	movw	r18, r24
 b10:	20 5a       	subi	r18, 0xA0	; 160
 b12:	3f 4f       	sbci	r19, 0xFF	; 255
 b14:	49 01       	movw	r8, r18
 b16:	28 e0       	ldi	r18, 0x08	; 8
 b18:	41 e0       	ldi	r20, 0x01	; 1
 b1a:	f4 01       	movw	r30, r8
 b1c:	61 81       	ldd	r22, Z+1	; 0x01
 b1e:	80 81       	ld	r24, Z
 b20:	0e 94 21 09 	call	0x1242	; 0x1242 <printAlarm>
	/*retrieve old alarm values*/
	*minutes_tens = (alarm_ptr_arr[alarm_num].minutes) / 10;
 b24:	f4 01       	movw	r30, r8
 b26:	90 81       	ld	r25, Z
 b28:	8d ec       	ldi	r24, 0xCD	; 205
 b2a:	98 9f       	mul	r25, r24
 b2c:	91 2d       	mov	r25, r1
 b2e:	11 24       	eor	r1, r1
 b30:	96 95       	lsr	r25
 b32:	96 95       	lsr	r25
 b34:	96 95       	lsr	r25
 b36:	f5 01       	movw	r30, r10
 b38:	90 83       	st	Z, r25
	*minutes_ones = (alarm_ptr_arr[alarm_num].minutes) % 10;
 b3a:	f4 01       	movw	r30, r8
 b3c:	20 81       	ld	r18, Z
 b3e:	28 9f       	mul	r18, r24
 b40:	91 2d       	mov	r25, r1
 b42:	11 24       	eor	r1, r1
 b44:	96 95       	lsr	r25
 b46:	96 95       	lsr	r25
 b48:	96 95       	lsr	r25
 b4a:	99 0f       	add	r25, r25
 b4c:	39 2f       	mov	r19, r25
 b4e:	33 0f       	add	r19, r19
 b50:	33 0f       	add	r19, r19
 b52:	93 0f       	add	r25, r19
 b54:	29 1b       	sub	r18, r25
 b56:	f6 01       	movw	r30, r12
 b58:	20 83       	st	Z, r18
	*seconds_tens = (alarm_ptr_arr[alarm_num].seconds) / 10;
 b5a:	f4 01       	movw	r30, r8
 b5c:	91 81       	ldd	r25, Z+1	; 0x01
 b5e:	98 9f       	mul	r25, r24
 b60:	91 2d       	mov	r25, r1
 b62:	11 24       	eor	r1, r1
 b64:	96 95       	lsr	r25
 b66:	96 95       	lsr	r25
 b68:	96 95       	lsr	r25
 b6a:	f7 01       	movw	r30, r14
 b6c:	90 83       	st	Z, r25
	*seconds_ones = (alarm_ptr_arr[alarm_num].seconds) % 10;
 b6e:	f4 01       	movw	r30, r8
 b70:	91 81       	ldd	r25, Z+1	; 0x01
 b72:	98 9f       	mul	r25, r24
 b74:	81 2d       	mov	r24, r1
 b76:	11 24       	eor	r1, r1
 b78:	86 95       	lsr	r24
 b7a:	86 95       	lsr	r24
 b7c:	86 95       	lsr	r24
 b7e:	88 0f       	add	r24, r24
 b80:	28 2f       	mov	r18, r24
 b82:	22 0f       	add	r18, r18
 b84:	22 0f       	add	r18, r18
 b86:	82 0f       	add	r24, r18
 b88:	98 1b       	sub	r25, r24
 b8a:	98 83       	st	Y, r25
	/*wait for user to set alarm*/
	five_sec_timeout = 0;
 b8c:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <five_sec_timeout>
	while(5 > five_sec_timeout){
 b90:	06 c0       	rjmp	.+12     	; 0xb9e <modify_set_alarm+0x12e>
		modifyAlarm(minutes_tens, minutes_ones, seconds_tens, seconds_ones);
 b92:	9e 01       	movw	r18, r28
 b94:	a7 01       	movw	r20, r14
 b96:	b6 01       	movw	r22, r12
 b98:	c5 01       	movw	r24, r10
 b9a:	0e 94 18 01 	call	0x230	; 0x230 <modifyAlarm>
	*minutes_ones = (alarm_ptr_arr[alarm_num].minutes) % 10;
	*seconds_tens = (alarm_ptr_arr[alarm_num].seconds) / 10;
	*seconds_ones = (alarm_ptr_arr[alarm_num].seconds) % 10;
	/*wait for user to set alarm*/
	five_sec_timeout = 0;
	while(5 > five_sec_timeout){
 b9e:	90 91 72 00 	lds	r25, 0x0072	; 0x800072 <five_sec_timeout>
 ba2:	95 30       	cpi	r25, 0x05	; 5
 ba4:	b0 f3       	brcs	.-20     	; 0xb92 <modify_set_alarm+0x122>
		modifyAlarm(minutes_tens, minutes_ones, seconds_tens, seconds_ones);
	}
	UINT8_t min=(*minutes_tens * (UINT8_t)10) + *minutes_ones;
 ba6:	f5 01       	movw	r30, r10
 ba8:	20 81       	ld	r18, Z
 baa:	f6 01       	movw	r30, r12
 bac:	80 81       	ld	r24, Z
 bae:	22 0f       	add	r18, r18
 bb0:	92 2f       	mov	r25, r18
 bb2:	99 0f       	add	r25, r25
 bb4:	99 0f       	add	r25, r25
 bb6:	29 0f       	add	r18, r25
 bb8:	28 0f       	add	r18, r24
	UINT8_t sec =(*seconds_tens * (UINT8_t)10) + *seconds_ones;
 bba:	f7 01       	movw	r30, r14
 bbc:	80 81       	ld	r24, Z
 bbe:	98 81       	ld	r25, Y
 bc0:	88 0f       	add	r24, r24
 bc2:	38 2f       	mov	r19, r24
 bc4:	33 0f       	add	r19, r19
 bc6:	33 0f       	add	r19, r19
 bc8:	83 0f       	add	r24, r19
 bca:	89 0f       	add	r24, r25
	/*store alarm values*/
	if((min!= 0) || (sec != 0)){
 bcc:	21 11       	cpse	r18, r1
 bce:	01 c0       	rjmp	.+2      	; 0xbd2 <modify_set_alarm+0x162>
 bd0:	b9 f0       	breq	.+46     	; 0xc00 <modify_set_alarm+0x190>
		alarm_ptr_arr[alarm_num].minutes = min;
 bd2:	00 0f       	add	r16, r16
 bd4:	11 1f       	adc	r17, r17
 bd6:	00 0f       	add	r16, r16
 bd8:	11 1f       	adc	r17, r17
 bda:	f8 01       	movw	r30, r16
 bdc:	e0 5a       	subi	r30, 0xA0	; 160
 bde:	ff 4f       	sbci	r31, 0xFF	; 255
 be0:	20 83       	st	Z, r18
		alarm_ptr_arr[alarm_num].seconds = sec;
 be2:	81 83       	std	Z+1, r24	; 0x01
		alarm_ptr_arr[alarm_num].Fire_Time=(((UINT16_t)min*60)+(UINT16_t)sec)+Current_Time;
 be4:	90 e0       	ldi	r25, 0x00	; 0
 be6:	3c e3       	ldi	r19, 0x3C	; 60
 be8:	23 9f       	mul	r18, r19
 bea:	80 0d       	add	r24, r0
 bec:	91 1d       	adc	r25, r1
 bee:	11 24       	eor	r1, r1
 bf0:	20 91 6e 00 	lds	r18, 0x006E	; 0x80006e <Current_Time>
 bf4:	30 91 6f 00 	lds	r19, 0x006F	; 0x80006f <Current_Time+0x1>
 bf8:	82 0f       	add	r24, r18
 bfa:	93 1f       	adc	r25, r19
 bfc:	93 83       	std	Z+3, r25	; 0x03
 bfe:	82 83       	std	Z+2, r24	; 0x02
	}

}
 c00:	df 91       	pop	r29
 c02:	cf 91       	pop	r28
 c04:	1f 91       	pop	r17
 c06:	0f 91       	pop	r16
 c08:	ff 90       	pop	r15
 c0a:	ef 90       	pop	r14
 c0c:	df 90       	pop	r13
 c0e:	cf 90       	pop	r12
 c10:	bf 90       	pop	r11
 c12:	af 90       	pop	r10
 c14:	9f 90       	pop	r9
 c16:	8f 90       	pop	r8
 c18:	08 95       	ret

Disassembly of section .text.alarm_scheduler:

000005d8 <alarm_scheduler>:
*	Inputs: None
*	Outputs: either success or fail.
*	Description: main function that handles switching between setting new alarms and modifying
*	set alarms. This function is called in the main.
*/
ERROR_STATE alarm_scheduler(){
 5d8:	0f 93       	push	r16
 5da:	1f 93       	push	r17
 5dc:	cf 93       	push	r28
 5de:	df 93       	push	r29
 5e0:	cd b7       	in	r28, 0x3d	; 61
 5e2:	de b7       	in	r29, 0x3e	; 62
 5e4:	28 97       	sbiw	r28, 0x08	; 8
 5e6:	0f b6       	in	r0, 0x3f	; 63
 5e8:	f8 94       	cli
 5ea:	de bf       	out	0x3e, r29	; 62
 5ec:	0f be       	out	0x3f, r0	; 63
 5ee:	cd bf       	out	0x3d, r28	; 61
	/*local initializations*/
	ERROR_STATE state_error = SUCCESS;
	/*buttons*/
	bool button_1_val = FALSE;
 5f0:	19 82       	std	Y+1, r1	; 0x01
	bool button_2_val = FALSE;
 5f2:	1a 82       	std	Y+2, r1	; 0x02
	bool button_3_val = FALSE;
 5f4:	1b 82       	std	Y+3, r1	; 0x03
	bool button_4_val = FALSE;
 5f6:	1c 82       	std	Y+4, r1	; 0x04
	/*cursor*/
	UINT8_t cursor_loc = 1;
	/*alarm values*/
	UINT8_t minutes_tens = 0;
 5f8:	1d 82       	std	Y+5, r1	; 0x05
	UINT8_t minutes_ones = 0;
 5fa:	1e 82       	std	Y+6, r1	; 0x06
	UINT8_t seconds_tens = 0;
 5fc:	1f 82       	std	Y+7, r1	; 0x07
	UINT8_t seconds_ones = 0;
 5fe:	18 86       	std	Y+8, r1	; 0x08
	/**********************************Operations page**************************************/
	/*print available operations*/
	LCD_Clear();
 600:	0e 94 52 10 	call	0x20a4	; 0x20a4 <LCD_Clear>
	LCD_LINE_position(LCD_LINE1, 1);
 604:	61 e0       	ldi	r22, 0x01	; 1
 606:	80 e0       	ldi	r24, 0x00	; 0
 608:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
	LCD_Write_String("1) New Alarm");
 60c:	63 e9       	ldi	r22, 0x93	; 147
 60e:	71 e0       	ldi	r23, 0x01	; 1
 610:	80 e0       	ldi	r24, 0x00	; 0
 612:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <LCD_Write_String>
	LCD_LINE_position(LCD_LINE2, 1);
 616:	61 e0       	ldi	r22, 0x01	; 1
 618:	81 e0       	ldi	r24, 0x01	; 1
 61a:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
	LCD_Write_String("2) Modify Alarm");
 61e:	60 ea       	ldi	r22, 0xA0	; 160
 620:	71 e0       	ldi	r23, 0x01	; 1
 622:	80 e0       	ldi	r24, 0x00	; 0
 624:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <LCD_Write_String>
	/*print buttons action*/
	Display_Action_Buttons(Three_Buttons);
 628:	83 e0       	ldi	r24, 0x03	; 3
 62a:	0e 94 48 0d 	call	0x1a90	; 0x1a90 <Display_Action_Buttons>
	/*wait for a user response*/
	while(!button_1_val && !button_2_val && !button_3_val){
 62e:	15 c0       	rjmp	.+42     	; 0x65a <alarm_scheduler+0x82>
		BTN_pressed(DIO_PORTD, DIO_PIN7, &button_1_val);
 630:	ae 01       	movw	r20, r28
 632:	4f 5f       	subi	r20, 0xFF	; 255
 634:	5f 4f       	sbci	r21, 0xFF	; 255
 636:	67 e0       	ldi	r22, 0x07	; 7
 638:	83 e0       	ldi	r24, 0x03	; 3
 63a:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <BTN_pressed>
		BTN_pressed(DIO_PORTD, DIO_PIN6, &button_2_val);
 63e:	ae 01       	movw	r20, r28
 640:	4e 5f       	subi	r20, 0xFE	; 254
 642:	5f 4f       	sbci	r21, 0xFF	; 255
 644:	66 e0       	ldi	r22, 0x06	; 6
 646:	83 e0       	ldi	r24, 0x03	; 3
 648:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <BTN_pressed>
		BTN_pressed(DIO_PORTD, DIO_PIN5, &button_3_val);
 64c:	ae 01       	movw	r20, r28
 64e:	4d 5f       	subi	r20, 0xFD	; 253
 650:	5f 4f       	sbci	r21, 0xFF	; 255
 652:	65 e0       	ldi	r22, 0x05	; 5
 654:	83 e0       	ldi	r24, 0x03	; 3
 656:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <BTN_pressed>
	LCD_LINE_position(LCD_LINE2, 1);
	LCD_Write_String("2) Modify Alarm");
	/*print buttons action*/
	Display_Action_Buttons(Three_Buttons);
	/*wait for a user response*/
	while(!button_1_val && !button_2_val && !button_3_val){
 65a:	89 81       	ldd	r24, Y+1	; 0x01
 65c:	81 11       	cpse	r24, r1
 65e:	06 c0       	rjmp	.+12     	; 0x66c <alarm_scheduler+0x94>
 660:	9a 81       	ldd	r25, Y+2	; 0x02
 662:	91 11       	cpse	r25, r1
 664:	03 c0       	rjmp	.+6      	; 0x66c <alarm_scheduler+0x94>
 666:	9b 81       	ldd	r25, Y+3	; 0x03
 668:	99 23       	and	r25, r25
 66a:	11 f3       	breq	.-60     	; 0x630 <alarm_scheduler+0x58>
		BTN_pressed(DIO_PORTD, DIO_PIN7, &button_1_val);
		BTN_pressed(DIO_PORTD, DIO_PIN6, &button_2_val);
		BTN_pressed(DIO_PORTD, DIO_PIN5, &button_3_val);
	}
	/**********************************Set new alarm page**************************************/
	if(button_1_val){
 66c:	88 23       	and	r24, r24
 66e:	09 f4       	brne	.+2      	; 0x672 <alarm_scheduler+0x9a>
 670:	80 c0       	rjmp	.+256    	; 0x772 <alarm_scheduler+0x19a>
		/*to limit available alarms to only 3*/
		if(3 > usr_def_alarms){
 672:	80 91 71 00 	lds	r24, 0x0071	; 0x800071 <usr_def_alarms>
 676:	83 30       	cpi	r24, 0x03	; 3
 678:	08 f0       	brcs	.+2      	; 0x67c <alarm_scheduler+0xa4>
 67a:	6f c0       	rjmp	.+222    	; 0x75a <alarm_scheduler+0x182>
			LCD_Clear();
 67c:	0e 94 52 10 	call	0x20a4	; 0x20a4 <LCD_Clear>
			LCD_Write_String("*Setting new alarm*");
 680:	60 eb       	ldi	r22, 0xB0	; 176
 682:	71 e0       	ldi	r23, 0x01	; 1
 684:	80 e0       	ldi	r24, 0x00	; 0
 686:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <LCD_Write_String>
			/*print buttons action*/
			LCD_LINE_position(LCD_LINE4, 5);
 68a:	65 e0       	ldi	r22, 0x05	; 5
 68c:	83 e0       	ldi	r24, 0x03	; 3
 68e:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
			LCD_Write_Character(0x7F);
 692:	8f e7       	ldi	r24, 0x7F	; 127
 694:	0e 94 ef 07 	call	0xfde	; 0xfde <LCD_Write_Character>
			LCD_LINE_position(LCD_LINE4, 8);
 698:	68 e0       	ldi	r22, 0x08	; 8
 69a:	83 e0       	ldi	r24, 0x03	; 3
 69c:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
			LCD_Write_Character(0x2D);
 6a0:	8d e2       	ldi	r24, 0x2D	; 45
 6a2:	0e 94 ef 07 	call	0xfde	; 0xfde <LCD_Write_Character>
			LCD_LINE_position(LCD_LINE4, 11);
 6a6:	6b e0       	ldi	r22, 0x0B	; 11
 6a8:	83 e0       	ldi	r24, 0x03	; 3
 6aa:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
			LCD_Write_Character(0x2B);
 6ae:	8b e2       	ldi	r24, 0x2B	; 43
 6b0:	0e 94 ef 07 	call	0xfde	; 0xfde <LCD_Write_Character>
			LCD_LINE_position(LCD_LINE4, 14);
 6b4:	6e e0       	ldi	r22, 0x0E	; 14
 6b6:	83 e0       	ldi	r24, 0x03	; 3
 6b8:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
			LCD_Write_Character(0x7E);
 6bc:	8e e7       	ldi	r24, 0x7E	; 126
 6be:	0e 94 ef 07 	call	0xfde	; 0xfde <LCD_Write_Character>
			/*print default alarm*/
			printAlarm(0, 0,LCD_LINE2, 8);
 6c2:	28 e0       	ldi	r18, 0x08	; 8
 6c4:	41 e0       	ldi	r20, 0x01	; 1
 6c6:	60 e0       	ldi	r22, 0x00	; 0
 6c8:	80 e0       	ldi	r24, 0x00	; 0
 6ca:	0e 94 21 09 	call	0x1242	; 0x1242 <printAlarm>
			five_sec_timeout = 0;
 6ce:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <five_sec_timeout>
			/*wait for user to set alarm*/
			while(5 > five_sec_timeout){
 6d2:	0d c0       	rjmp	.+26     	; 0x6ee <alarm_scheduler+0x116>
				/*if user is idle for 5 seconds, th alarm values will be saved*/
				modifyAlarm(&minutes_tens, &minutes_ones, &seconds_tens, &seconds_ones);
 6d4:	9e 01       	movw	r18, r28
 6d6:	28 5f       	subi	r18, 0xF8	; 248
 6d8:	3f 4f       	sbci	r19, 0xFF	; 255
 6da:	ae 01       	movw	r20, r28
 6dc:	49 5f       	subi	r20, 0xF9	; 249
 6de:	5f 4f       	sbci	r21, 0xFF	; 255
 6e0:	be 01       	movw	r22, r28
 6e2:	6a 5f       	subi	r22, 0xFA	; 250
 6e4:	7f 4f       	sbci	r23, 0xFF	; 255
 6e6:	ce 01       	movw	r24, r28
 6e8:	05 96       	adiw	r24, 0x05	; 5
 6ea:	0e 94 18 01 	call	0x230	; 0x230 <modifyAlarm>
			LCD_Write_Character(0x7E);
			/*print default alarm*/
			printAlarm(0, 0,LCD_LINE2, 8);
			five_sec_timeout = 0;
			/*wait for user to set alarm*/
			while(5 > five_sec_timeout){
 6ee:	80 91 72 00 	lds	r24, 0x0072	; 0x800072 <five_sec_timeout>
 6f2:	85 30       	cpi	r24, 0x05	; 5
 6f4:	78 f3       	brcs	.-34     	; 0x6d4 <alarm_scheduler+0xfc>
				/*if user is idle for 5 seconds, th alarm values will be saved*/
				modifyAlarm(&minutes_tens, &minutes_ones, &seconds_tens, &seconds_ones);
			}
			UINT8_t min=(minutes_tens * (UINT8_t)10) + minutes_ones;
 6f6:	8d 81       	ldd	r24, Y+5	; 0x05
 6f8:	88 0f       	add	r24, r24
 6fa:	28 2f       	mov	r18, r24
 6fc:	22 0f       	add	r18, r18
 6fe:	22 0f       	add	r18, r18
 700:	28 0f       	add	r18, r24
 702:	8e 81       	ldd	r24, Y+6	; 0x06
 704:	28 0f       	add	r18, r24
			UINT8_t sec =(seconds_tens * (UINT8_t)10) + seconds_ones;
 706:	8f 81       	ldd	r24, Y+7	; 0x07
 708:	88 0f       	add	r24, r24
 70a:	98 2f       	mov	r25, r24
 70c:	99 0f       	add	r25, r25
 70e:	99 0f       	add	r25, r25
 710:	89 0f       	add	r24, r25
 712:	98 85       	ldd	r25, Y+8	; 0x08
 714:	89 0f       	add	r24, r25
			/*store alarm values*/
			if((min!= 0) || (sec != 0)){
 716:	21 11       	cpse	r18, r1
 718:	02 c0       	rjmp	.+4      	; 0x71e <alarm_scheduler+0x146>
 71a:	09 f4       	brne	.+2      	; 0x71e <alarm_scheduler+0x146>
 71c:	b5 c0       	rjmp	.+362    	; 0x888 <__stack+0x29>
				alarm_ptr_arr[usr_def_alarms].minutes = min;
 71e:	30 91 71 00 	lds	r19, 0x0071	; 0x800071 <usr_def_alarms>
 722:	e3 2f       	mov	r30, r19
 724:	f0 e0       	ldi	r31, 0x00	; 0
 726:	ee 0f       	add	r30, r30
 728:	ff 1f       	adc	r31, r31
 72a:	ee 0f       	add	r30, r30
 72c:	ff 1f       	adc	r31, r31
 72e:	e0 5a       	subi	r30, 0xA0	; 160
 730:	ff 4f       	sbci	r31, 0xFF	; 255
 732:	20 83       	st	Z, r18
				alarm_ptr_arr[usr_def_alarms].seconds = sec;
 734:	81 83       	std	Z+1, r24	; 0x01
				alarm_ptr_arr[usr_def_alarms].Fire_Time=(((UINT16_t)min*60)+(UINT16_t)sec)+Current_Time;
 736:	90 e0       	ldi	r25, 0x00	; 0
 738:	4c e3       	ldi	r20, 0x3C	; 60
 73a:	24 9f       	mul	r18, r20
 73c:	80 0d       	add	r24, r0
 73e:	91 1d       	adc	r25, r1
 740:	11 24       	eor	r1, r1
 742:	40 91 6e 00 	lds	r20, 0x006E	; 0x80006e <Current_Time>
 746:	50 91 6f 00 	lds	r21, 0x006F	; 0x80006f <Current_Time+0x1>
 74a:	84 0f       	add	r24, r20
 74c:	95 1f       	adc	r25, r21
 74e:	93 83       	std	Z+3, r25	; 0x03
 750:	82 83       	std	Z+2, r24	; 0x02
				++usr_def_alarms;
 752:	3f 5f       	subi	r19, 0xFF	; 255
 754:	30 93 71 00 	sts	0x0071, r19	; 0x800071 <usr_def_alarms>
 758:	97 c0       	rjmp	.+302    	; 0x888 <__stack+0x29>
			}

			}else{
			/*in case all 3 alarms are used*/
			LCD_Clear();
 75a:	0e 94 52 10 	call	0x20a4	; 0x20a4 <LCD_Clear>
			LCD_LINE_position(LCD_LINE2, 8);
 75e:	68 e0       	ldi	r22, 0x08	; 8
 760:	81 e0       	ldi	r24, 0x01	; 1
 762:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
			LCD_Write_String("No free alarms left!");
 766:	64 ec       	ldi	r22, 0xC4	; 196
 768:	71 e0       	ldi	r23, 0x01	; 1
 76a:	80 e0       	ldi	r24, 0x00	; 0
 76c:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <LCD_Write_String>
 770:	8b c0       	rjmp	.+278    	; 0x888 <__stack+0x29>
		}
		/**********************************modify alarm page**************************************/
		} else if (button_2_val){
 772:	8a 81       	ldd	r24, Y+2	; 0x02
 774:	88 23       	and	r24, r24
 776:	09 f4       	brne	.+2      	; 0x77a <alarm_scheduler+0x1a2>
 778:	87 c0       	rjmp	.+270    	; 0x888 <__stack+0x29>
		if(usr_def_alarms != 0){
 77a:	80 91 71 00 	lds	r24, 0x0071	; 0x800071 <usr_def_alarms>
 77e:	88 23       	and	r24, r24
 780:	09 f4       	brne	.+2      	; 0x784 <alarm_scheduler+0x1ac>
 782:	72 c0       	rjmp	.+228    	; 0x868 <__stack+0x9>
			cursor_loc = 1;
			LCD_Clear();
 784:	0e 94 52 10 	call	0x20a4	; 0x20a4 <LCD_Clear>
			LCD_LINE_position(LCD_LINE1, 2);
 788:	62 e0       	ldi	r22, 0x02	; 2
 78a:	80 e0       	ldi	r24, 0x00	; 0
 78c:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
			LCD_Write_String("**Choose Alarm**");
 790:	69 ed       	ldi	r22, 0xD9	; 217
 792:	71 e0       	ldi	r23, 0x01	; 1
 794:	80 e0       	ldi	r24, 0x00	; 0
 796:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <LCD_Write_String>
			LCD_LINE_position(LCD_LINE2, cursor_loc);
 79a:	61 e0       	ldi	r22, 0x01	; 1
 79c:	81 e0       	ldi	r24, 0x01	; 1
 79e:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
			/*print all alarms set by the user*/
			for(UINT8_t alarm_index = 0; usr_def_alarms > alarm_index; ++alarm_index){
 7a2:	10 e0       	ldi	r17, 0x00	; 0
			LCD_Write_String("No free alarms left!");
		}
		/**********************************modify alarm page**************************************/
		} else if (button_2_val){
		if(usr_def_alarms != 0){
			cursor_loc = 1;
 7a4:	01 e0       	ldi	r16, 0x01	; 1
			LCD_Clear();
			LCD_LINE_position(LCD_LINE1, 2);
			LCD_Write_String("**Choose Alarm**");
			LCD_LINE_position(LCD_LINE2, cursor_loc);
			/*print all alarms set by the user*/
			for(UINT8_t alarm_index = 0; usr_def_alarms > alarm_index; ++alarm_index){
 7a6:	10 c0       	rjmp	.+32     	; 0x7c8 <alarm_scheduler+0x1f0>
				printAlarm(alarm_ptr_arr[alarm_index].minutes, alarm_ptr_arr[alarm_index].seconds,LCD_LINE2, cursor_loc);
 7a8:	e1 2f       	mov	r30, r17
 7aa:	f0 e0       	ldi	r31, 0x00	; 0
 7ac:	ee 0f       	add	r30, r30
 7ae:	ff 1f       	adc	r31, r31
 7b0:	ee 0f       	add	r30, r30
 7b2:	ff 1f       	adc	r31, r31
 7b4:	e0 5a       	subi	r30, 0xA0	; 160
 7b6:	ff 4f       	sbci	r31, 0xFF	; 255
 7b8:	20 2f       	mov	r18, r16
 7ba:	41 e0       	ldi	r20, 0x01	; 1
 7bc:	61 81       	ldd	r22, Z+1	; 0x01
 7be:	80 81       	ld	r24, Z
 7c0:	0e 94 21 09 	call	0x1242	; 0x1242 <printAlarm>
				cursor_loc+=7;
 7c4:	09 5f       	subi	r16, 0xF9	; 249
			LCD_Clear();
			LCD_LINE_position(LCD_LINE1, 2);
			LCD_Write_String("**Choose Alarm**");
			LCD_LINE_position(LCD_LINE2, cursor_loc);
			/*print all alarms set by the user*/
			for(UINT8_t alarm_index = 0; usr_def_alarms > alarm_index; ++alarm_index){
 7c6:	1f 5f       	subi	r17, 0xFF	; 255
 7c8:	80 91 71 00 	lds	r24, 0x0071	; 0x800071 <usr_def_alarms>
 7cc:	18 17       	cp	r17, r24
 7ce:	60 f3       	brcs	.-40     	; 0x7a8 <alarm_scheduler+0x1d0>
				printAlarm(alarm_ptr_arr[alarm_index].minutes, alarm_ptr_arr[alarm_index].seconds,LCD_LINE2, cursor_loc);
				cursor_loc+=7;
			}
			/*print buttons action*/
			Display_Action_Buttons(All_Buttons);
 7d0:	84 e0       	ldi	r24, 0x04	; 4
 7d2:	0e 94 48 0d 	call	0x1a90	; 0x1a90 <Display_Action_Buttons>
			/*reset button status*/
			button_1_val = FALSE;
 7d6:	19 82       	std	Y+1, r1	; 0x01
			button_2_val = FALSE;
 7d8:	1a 82       	std	Y+2, r1	; 0x02
			button_3_val = FALSE;
 7da:	1b 82       	std	Y+3, r1	; 0x03
			/*wait for a user response*/
			Check_Button_Update(&button_1_val, &button_2_val, &button_3_val, &button_4_val);
 7dc:	9e 01       	movw	r18, r28
 7de:	2c 5f       	subi	r18, 0xFC	; 252
 7e0:	3f 4f       	sbci	r19, 0xFF	; 255
 7e2:	ae 01       	movw	r20, r28
 7e4:	4d 5f       	subi	r20, 0xFD	; 253
 7e6:	5f 4f       	sbci	r21, 0xFF	; 255
 7e8:	be 01       	movw	r22, r28
 7ea:	6e 5f       	subi	r22, 0xFE	; 254
 7ec:	7f 4f       	sbci	r23, 0xFF	; 255
 7ee:	ce 01       	movw	r24, r28
 7f0:	01 96       	adiw	r24, 0x01	; 1
 7f2:	0e 94 ce 0b 	call	0x179c	; 0x179c <Check_Button_Update>
			if(button_1_val){
 7f6:	89 81       	ldd	r24, Y+1	; 0x01
 7f8:	88 23       	and	r24, r24
 7fa:	81 f0       	breq	.+32     	; 0x81c <__DATA_REGION_LENGTH__+0x1c>
				modify_set_alarm(Alarm_1, &minutes_tens, &minutes_ones, &seconds_tens, &seconds_ones);
 7fc:	8e 01       	movw	r16, r28
 7fe:	08 5f       	subi	r16, 0xF8	; 248
 800:	1f 4f       	sbci	r17, 0xFF	; 255
 802:	9e 01       	movw	r18, r28
 804:	29 5f       	subi	r18, 0xF9	; 249
 806:	3f 4f       	sbci	r19, 0xFF	; 255
 808:	ae 01       	movw	r20, r28
 80a:	4a 5f       	subi	r20, 0xFA	; 250
 80c:	5f 4f       	sbci	r21, 0xFF	; 255
 80e:	be 01       	movw	r22, r28
 810:	6b 5f       	subi	r22, 0xFB	; 251
 812:	7f 4f       	sbci	r23, 0xFF	; 255
 814:	80 e0       	ldi	r24, 0x00	; 0
 816:	0e 94 38 05 	call	0xa70	; 0xa70 <modify_set_alarm>
 81a:	36 c0       	rjmp	.+108    	; 0x888 <__stack+0x29>
				/*in case alarm 2 is chosen*/
				} else if(button_2_val){
 81c:	8a 81       	ldd	r24, Y+2	; 0x02
 81e:	88 23       	and	r24, r24
 820:	81 f0       	breq	.+32     	; 0x842 <__DATA_REGION_LENGTH__+0x42>
				modify_set_alarm(Alarm_2, &minutes_tens, &minutes_ones, &seconds_tens, &seconds_ones);
 822:	8e 01       	movw	r16, r28
 824:	08 5f       	subi	r16, 0xF8	; 248
 826:	1f 4f       	sbci	r17, 0xFF	; 255
 828:	9e 01       	movw	r18, r28
 82a:	29 5f       	subi	r18, 0xF9	; 249
 82c:	3f 4f       	sbci	r19, 0xFF	; 255
 82e:	ae 01       	movw	r20, r28
 830:	4a 5f       	subi	r20, 0xFA	; 250
 832:	5f 4f       	sbci	r21, 0xFF	; 255
 834:	be 01       	movw	r22, r28
 836:	6b 5f       	subi	r22, 0xFB	; 251
 838:	7f 4f       	sbci	r23, 0xFF	; 255
 83a:	81 e0       	ldi	r24, 0x01	; 1
 83c:	0e 94 38 05 	call	0xa70	; 0xa70 <modify_set_alarm>
 840:	23 c0       	rjmp	.+70     	; 0x888 <__stack+0x29>
				/*in case alarm 3 is chosen*/
				} else if(button_3_val){
 842:	8b 81       	ldd	r24, Y+3	; 0x03
 844:	88 23       	and	r24, r24
 846:	01 f1       	breq	.+64     	; 0x888 <__stack+0x29>
				modify_set_alarm(Alarm_3, &minutes_tens, &minutes_ones, &seconds_tens, &seconds_ones);
 848:	8e 01       	movw	r16, r28
 84a:	08 5f       	subi	r16, 0xF8	; 248
 84c:	1f 4f       	sbci	r17, 0xFF	; 255
 84e:	9e 01       	movw	r18, r28
 850:	29 5f       	subi	r18, 0xF9	; 249
 852:	3f 4f       	sbci	r19, 0xFF	; 255
 854:	ae 01       	movw	r20, r28
 856:	4a 5f       	subi	r20, 0xFA	; 250
 858:	5f 4f       	sbci	r21, 0xFF	; 255
 85a:	be 01       	movw	r22, r28
 85c:	6b 5f       	subi	r22, 0xFB	; 251
 85e:	7f 4f       	sbci	r23, 0xFF	; 255
 860:	82 e0       	ldi	r24, 0x02	; 2
 862:	0e 94 38 05 	call	0xa70	; 0xa70 <modify_set_alarm>
 866:	10 c0       	rjmp	.+32     	; 0x888 <__stack+0x29>
				/*do nothing*/;
				} else{
				/*do nothing*/;
			}
			}else{
			LCD_Clear();
 868:	0e 94 52 10 	call	0x20a4	; 0x20a4 <LCD_Clear>
			LCD_Write_String("No Alarms Set");
 86c:	6a ee       	ldi	r22, 0xEA	; 234
 86e:	71 e0       	ldi	r23, 0x01	; 1
 870:	80 e0       	ldi	r24, 0x00	; 0
 872:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <LCD_Write_String>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 876:	8f ef       	ldi	r24, 0xFF	; 255
 878:	97 ea       	ldi	r25, 0xA7	; 167
 87a:	21 e6       	ldi	r18, 0x61	; 97
 87c:	81 50       	subi	r24, 0x01	; 1
 87e:	90 40       	sbci	r25, 0x00	; 0
 880:	20 40       	sbci	r18, 0x00	; 0
 882:	e1 f7       	brne	.-8      	; 0x87c <__stack+0x1d>
 884:	00 c0       	rjmp	.+0      	; 0x886 <__stack+0x27>
 886:	00 00       	nop
		/*do nothing*/;
		} else{
		/*do nothing*/;
	}
	return state_error;
}
 888:	81 e0       	ldi	r24, 0x01	; 1
 88a:	28 96       	adiw	r28, 0x08	; 8
 88c:	0f b6       	in	r0, 0x3f	; 63
 88e:	f8 94       	cli
 890:	de bf       	out	0x3e, r29	; 62
 892:	0f be       	out	0x3f, r0	; 63
 894:	cd bf       	out	0x3d, r28	; 61
 896:	df 91       	pop	r29
 898:	cf 91       	pop	r28
 89a:	1f 91       	pop	r17
 89c:	0f 91       	pop	r16
 89e:	08 95       	ret

Disassembly of section .text.ALL_LEDS_TGL:

00001fa2 <ALL_LEDS_TGL>:
	ALL_LEDS_OFF();
	Timer0_Initialize();
	Timer0_STOP();
}
void ALL_LEDS_TGL (){
	BLUE_LED_TGL();
    1fa2:	0e 94 0c 10 	call	0x2018	; 0x2018 <BLUE_LED_TGL>
	RED_LED_TGL();
    1fa6:	0e 94 57 10 	call	0x20ae	; 0x20ae <RED_LED_TGL>
	GREEN_LED_TGL();
    1faa:	0e 94 4d 10 	call	0x209a	; 0x209a <GREEN_LED_TGL>
	YELLOW_LED_TGL();
    1fae:	0e 94 5c 10 	call	0x20b8	; 0x20b8 <YELLOW_LED_TGL>
    1fb2:	08 95       	ret

Disassembly of section .text.ALL_LEDS_ON:

00001f24 <ALL_LEDS_ON>:
}

void ALL_LEDS_ON (){
	Timer0_STOP();
    1f24:	0e 94 bd 0f 	call	0x1f7a	; 0x1f7a <Timer0_STOP>
	BLUE_LED_ON();
    1f28:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <BLUE_LED_ON>
	RED_LED_ON();
    1f2c:	0e 94 2a 10 	call	0x2054	; 0x2054 <RED_LED_ON>
	GREEN_LED_ON();
    1f30:	0e 94 18 10 	call	0x2030	; 0x2030 <GREEN_LED_ON>
	YELLOW_LED_ON();
    1f34:	0e 94 3c 10 	call	0x2078	; 0x2078 <YELLOW_LED_ON>
    1f38:	08 95       	ret

Disassembly of section .text.ALL_LEDS_OFF:

00001f3a <ALL_LEDS_OFF>:
}

void ALL_LEDS_OFF (){
	Timer0_STOP();
    1f3a:	0e 94 bd 0f 	call	0x1f7a	; 0x1f7a <Timer0_STOP>
	BLUE_LED_OFF();
    1f3e:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <BLUE_LED_OFF>
	RED_LED_OFF();
    1f42:	0e 94 30 10 	call	0x2060	; 0x2060 <RED_LED_OFF>
	GREEN_LED_OFF();
    1f46:	0e 94 1e 10 	call	0x203c	; 0x203c <GREEN_LED_OFF>
	YELLOW_LED_OFF();
    1f4a:	0e 94 42 10 	call	0x2084	; 0x2084 <YELLOW_LED_OFF>
    1f4e:	08 95       	ret

Disassembly of section .text.ALL_LEDS_Initialize:

00001e84 <ALL_LEDS_Initialize>:
volatile bool ACCELERATE = TRUE ,DECELERATE = FALSE;
volatile UINT8_t OVF_COUNTER = OVF_COUNTER_RESET ,DUTY_CYCLE = MIN_DUTY_CYCLE;

void ALL_LEDS_Initialize(){
	
	BLUE_LED_Initializ();
    1e84:	0e 94 e2 0f 	call	0x1fc4	; 0x1fc4 <BLUE_LED_Initializ>
	RED_LED_Initializ();
    1e88:	0e 94 24 10 	call	0x2048	; 0x2048 <RED_LED_Initializ>
	GREEN_LED_Initializ();
    1e8c:	0e 94 12 10 	call	0x2024	; 0x2024 <GREEN_LED_Initializ>
	YELLOW_LED_Initializ();
    1e90:	0e 94 36 10 	call	0x206c	; 0x206c <YELLOW_LED_Initializ>
	ALL_LEDS_OFF();
    1e94:	0e 94 9d 0f 	call	0x1f3a	; 0x1f3a <ALL_LEDS_OFF>
	Timer0_Initialize();
    1e98:	0e 94 7a 0f 	call	0x1ef4	; 0x1ef4 <Timer0_Initialize>
	Timer0_STOP();
    1e9c:	0e 94 bd 0f 	call	0x1f7a	; 0x1f7a <Timer0_STOP>
    1ea0:	08 95       	ret

Disassembly of section .text.ALL_LEDS_dimming:

000020d4 <ALL_LEDS_dimming>:
	GREEN_LED_OFF();
	YELLOW_LED_OFF();
}

void  ALL_LEDS_dimming(){
	Timer0_ON();
    20d4:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <Timer0_ON>
    20d8:	08 95       	ret

Disassembly of section .text.__vector_10:

00001bb4 <__vector_10>:
	ACCELERATE = TRUE ,DECELERATE = FALSE;
	OVF_COUNTER = OVF_COUNTER_RESET ,DUTY_CYCLE = MIN_DUTY_CYCLE;

}

ISR(TIMER0_COMP){
    1bb4:	1f 92       	push	r1
    1bb6:	0f 92       	push	r0
    1bb8:	0f b6       	in	r0, 0x3f	; 63
    1bba:	0f 92       	push	r0
    1bbc:	11 24       	eor	r1, r1
    1bbe:	2f 93       	push	r18
    1bc0:	3f 93       	push	r19
    1bc2:	4f 93       	push	r20
    1bc4:	5f 93       	push	r21
    1bc6:	6f 93       	push	r22
    1bc8:	7f 93       	push	r23
    1bca:	8f 93       	push	r24
    1bcc:	9f 93       	push	r25
    1bce:	af 93       	push	r26
    1bd0:	bf 93       	push	r27
    1bd2:	ef 93       	push	r30
    1bd4:	ff 93       	push	r31
	ALL_LEDS_TGL();
    1bd6:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <ALL_LEDS_TGL>
}
    1bda:	ff 91       	pop	r31
    1bdc:	ef 91       	pop	r30
    1bde:	bf 91       	pop	r27
    1be0:	af 91       	pop	r26
    1be2:	9f 91       	pop	r25
    1be4:	8f 91       	pop	r24
    1be6:	7f 91       	pop	r23
    1be8:	6f 91       	pop	r22
    1bea:	5f 91       	pop	r21
    1bec:	4f 91       	pop	r20
    1bee:	3f 91       	pop	r19
    1bf0:	2f 91       	pop	r18
    1bf2:	0f 90       	pop	r0
    1bf4:	0f be       	out	0x3f, r0	; 63
    1bf6:	0f 90       	pop	r0
    1bf8:	1f 90       	pop	r1
    1bfa:	18 95       	reti

Disassembly of section .text.__vector_11:

000010b2 <__vector_11>:
}
void ALL_LEDS_stop_dimming(){
	Timer0_STOP();
	ALL_LEDS_OFF();
	ACCELERATE = TRUE ,DECELERATE = FALSE;
	OVF_COUNTER = OVF_COUNTER_RESET ,DUTY_CYCLE = MIN_DUTY_CYCLE;
    10b2:	1f 92       	push	r1
    10b4:	0f 92       	push	r0
    10b6:	0f b6       	in	r0, 0x3f	; 63
    10b8:	0f 92       	push	r0
    10ba:	11 24       	eor	r1, r1
    10bc:	2f 93       	push	r18
    10be:	3f 93       	push	r19
    10c0:	4f 93       	push	r20
    10c2:	5f 93       	push	r21
    10c4:	6f 93       	push	r22
    10c6:	7f 93       	push	r23
    10c8:	8f 93       	push	r24
    10ca:	9f 93       	push	r25
    10cc:	af 93       	push	r26
    10ce:	bf 93       	push	r27
    10d0:	ef 93       	push	r30
    10d2:	ff 93       	push	r31
    10d4:	80 91 73 00 	lds	r24, 0x0073	; 0x800073 <DUTY_CYCLE>
    10d8:	83 36       	cpi	r24, 0x63	; 99
    10da:	28 f0       	brcs	.+10     	; 0x10e6 <__vector_11+0x34>
    10dc:	81 e0       	ldi	r24, 0x01	; 1
    10de:	80 93 75 00 	sts	0x0075, r24	; 0x800075 <DECELERATE>
    10e2:	10 92 76 00 	sts	0x0076, r1	; 0x800076 <ACCELERATE>
    10e6:	80 91 73 00 	lds	r24, 0x0073	; 0x800073 <DUTY_CYCLE>
    10ea:	82 30       	cpi	r24, 0x02	; 2
    10ec:	28 f4       	brcc	.+10     	; 0x10f8 <__vector_11+0x46>
    10ee:	81 e0       	ldi	r24, 0x01	; 1
    10f0:	80 93 76 00 	sts	0x0076, r24	; 0x800076 <ACCELERATE>
    10f4:	10 92 75 00 	sts	0x0075, r1	; 0x800075 <DECELERATE>
    10f8:	80 91 76 00 	lds	r24, 0x0076	; 0x800076 <ACCELERATE>
    10fc:	88 23       	and	r24, r24
    10fe:	a9 f0       	breq	.+42     	; 0x112a <__vector_11+0x78>
    1100:	80 91 74 00 	lds	r24, 0x0074	; 0x800074 <OVF_COUNTER>
    1104:	82 30       	cpi	r24, 0x02	; 2
    1106:	30 f4       	brcc	.+12     	; 0x1114 <__vector_11+0x62>
    1108:	80 91 74 00 	lds	r24, 0x0074	; 0x800074 <OVF_COUNTER>
    110c:	8f 5f       	subi	r24, 0xFF	; 255
    110e:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <OVF_COUNTER>
    1112:	0b c0       	rjmp	.+22     	; 0x112a <__vector_11+0x78>
    1114:	10 92 74 00 	sts	0x0074, r1	; 0x800074 <OVF_COUNTER>
    1118:	80 91 73 00 	lds	r24, 0x0073	; 0x800073 <DUTY_CYCLE>
    111c:	8f 5f       	subi	r24, 0xFF	; 255
    111e:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <DUTY_CYCLE>
    1122:	80 91 73 00 	lds	r24, 0x0073	; 0x800073 <DUTY_CYCLE>
    1126:	0e 94 22 0f 	call	0x1e44	; 0x1e44 <SET_DUTY_CYCLE>
    112a:	80 91 75 00 	lds	r24, 0x0075	; 0x800075 <DECELERATE>
    112e:	88 23       	and	r24, r24
    1130:	a9 f0       	breq	.+42     	; 0x115c <__vector_11+0xaa>
    1132:	80 91 74 00 	lds	r24, 0x0074	; 0x800074 <OVF_COUNTER>
    1136:	82 30       	cpi	r24, 0x02	; 2
    1138:	30 f4       	brcc	.+12     	; 0x1146 <__vector_11+0x94>
    113a:	80 91 74 00 	lds	r24, 0x0074	; 0x800074 <OVF_COUNTER>
    113e:	8f 5f       	subi	r24, 0xFF	; 255
    1140:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <OVF_COUNTER>
    1144:	0b c0       	rjmp	.+22     	; 0x115c <__vector_11+0xaa>
    1146:	10 92 74 00 	sts	0x0074, r1	; 0x800074 <OVF_COUNTER>
    114a:	80 91 73 00 	lds	r24, 0x0073	; 0x800073 <DUTY_CYCLE>
    114e:	81 50       	subi	r24, 0x01	; 1
    1150:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <DUTY_CYCLE>
    1154:	80 91 73 00 	lds	r24, 0x0073	; 0x800073 <DUTY_CYCLE>
    1158:	0e 94 22 0f 	call	0x1e44	; 0x1e44 <SET_DUTY_CYCLE>
    115c:	ff 91       	pop	r31
    115e:	ef 91       	pop	r30
    1160:	bf 91       	pop	r27
    1162:	af 91       	pop	r26
    1164:	9f 91       	pop	r25
    1166:	8f 91       	pop	r24
    1168:	7f 91       	pop	r23
    116a:	6f 91       	pop	r22
    116c:	5f 91       	pop	r21
    116e:	4f 91       	pop	r20
    1170:	3f 91       	pop	r19
    1172:	2f 91       	pop	r18
    1174:	0f 90       	pop	r0
    1176:	0f be       	out	0x3f, r0	; 63
    1178:	0f 90       	pop	r0
    117a:	1f 90       	pop	r1
    117c:	18 95       	reti

Disassembly of section .text.app_init:

00001edc <app_init>:
// extern SINT16_t Timing_array[];
// extern alarm_struct alarm_ptr_arr[NUM_OF_ALARMS];

ERROR_STATE app_init(){
	ERROR_STATE state_error = SUCCESS;
	ALL_LEDS_Initialize();
    1edc:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <ALL_LEDS_Initialize>
	alarm_scheduler_init();
    1ee0:	0e 94 a9 0e 	call	0x1d52	; 0x1d52 <alarm_scheduler_init>
	BUZZER_Initialize();
    1ee4:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <BUZZER_Initialize>
	LDR_init();
    1ee8:	0e 94 da 0f 	call	0x1fb4	; 0x1fb4 <LDR_init>
	LCD_Runable_Page();
    1eec:	0e 94 dd 09 	call	0x13ba	; 0x13ba <LCD_Runable_Page>
	// 	for(int i=0;i<3;i++){
	// 		LCD_Write_Number(Timing_array[i]);
	// 	}
	/*code init here*/
	return state_error;
}
    1ef0:	81 e0       	ldi	r24, 0x01	; 1
    1ef2:	08 95       	ret

Disassembly of section .text.app_main:

000020cc <app_main>:

ERROR_STATE app_main(){
	ERROR_STATE state_error = SUCCESS;
	LCD_First_Page();
    20cc:	0e 94 ac 0d 	call	0x1b58	; 0x1b58 <LCD_First_Page>
	/*Main code here*/
	return state_error;
}
    20d0:	81 e0       	ldi	r24, 0x01	; 1
    20d2:	08 95       	ret

Disassembly of section .text.LCD_Runable_Page:

000013ba <LCD_Runable_Page>:

ERROR_STATE LCD_Runable_Page(void)
{
	ERROR_STATE state_error = SUCCESS;

	LCD_LINE_position(LCD_LINE1,0);
    13ba:	60 e0       	ldi	r22, 0x00	; 0
    13bc:	80 e0       	ldi	r24, 0x00	; 0
    13be:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
	LCD_Write_String("Sunrise Alarm Clock");
    13c2:	6e ed       	ldi	r22, 0xDE	; 222
    13c4:	70 e0       	ldi	r23, 0x00	; 0
    13c6:	80 e0       	ldi	r24, 0x00	; 0
    13c8:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <LCD_Write_String>
	
	LCD_LINE_position(LCD_LINE2,2);
    13cc:	62 e0       	ldi	r22, 0x02	; 2
    13ce:	81 e0       	ldi	r24, 0x01	; 1
    13d0:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
	LCD_Write_String("^_^ Welcome ^_^");
    13d4:	62 ef       	ldi	r22, 0xF2	; 242
    13d6:	70 e0       	ldi	r23, 0x00	; 0
    13d8:	80 e0       	ldi	r24, 0x00	; 0
    13da:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <LCD_Write_String>
	
	LCD_LINE_position(LCD_LINE4,2);
    13de:	62 e0       	ldi	r22, 0x02	; 2
    13e0:	83 e0       	ldi	r24, 0x03	; 3
    13e2:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
	LCD_Write_String("BY: KYLIAN TECH");
    13e6:	62 e0       	ldi	r22, 0x02	; 2
    13e8:	71 e0       	ldi	r23, 0x01	; 1
    13ea:	80 e0       	ldi	r24, 0x00	; 0
    13ec:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <LCD_Write_String>
    13f0:	2f ef       	ldi	r18, 0xFF	; 255
    13f2:	87 ea       	ldi	r24, 0xA7	; 167
    13f4:	91 e6       	ldi	r25, 0x61	; 97
    13f6:	21 50       	subi	r18, 0x01	; 1
    13f8:	80 40       	sbci	r24, 0x00	; 0
    13fa:	90 40       	sbci	r25, 0x00	; 0
    13fc:	e1 f7       	brne	.-8      	; 0x13f6 <LCD_Runable_Page+0x3c>
    13fe:	00 c0       	rjmp	.+0      	; 0x1400 <LCD_Runable_Page+0x46>
    1400:	00 00       	nop
	
	_delay_ms(2000);
	LCD_Clear();
    1402:	0e 94 52 10 	call	0x20a4	; 0x20a4 <LCD_Clear>
	
	LCD_LINE_position(LCD_LINE1,0);
    1406:	60 e0       	ldi	r22, 0x00	; 0
    1408:	80 e0       	ldi	r24, 0x00	; 0
    140a:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
	LCD_Write_String("Ali Embaby 980");
    140e:	62 e1       	ldi	r22, 0x12	; 18
    1410:	71 e0       	ldi	r23, 0x01	; 1
    1412:	80 e0       	ldi	r24, 0x00	; 0
    1414:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <LCD_Write_String>
	
	LCD_LINE_position(LCD_LINE2,0);
    1418:	60 e0       	ldi	r22, 0x00	; 0
    141a:	81 e0       	ldi	r24, 0x01	; 1
    141c:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
	LCD_Write_String("Seif Shebl 894");
    1420:	61 e2       	ldi	r22, 0x21	; 33
    1422:	71 e0       	ldi	r23, 0x01	; 1
    1424:	80 e0       	ldi	r24, 0x00	; 0
    1426:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <LCD_Write_String>
	
	LCD_LINE_position(LCD_LINE3,0);
    142a:	60 e0       	ldi	r22, 0x00	; 0
    142c:	82 e0       	ldi	r24, 0x02	; 2
    142e:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
	LCD_Write_String("Ahmed Nasr 1069");
    1432:	60 e3       	ldi	r22, 0x30	; 48
    1434:	71 e0       	ldi	r23, 0x01	; 1
    1436:	80 e0       	ldi	r24, 0x00	; 0
    1438:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <LCD_Write_String>
	
	LCD_LINE_position(LCD_LINE4,0);
    143c:	60 e0       	ldi	r22, 0x00	; 0
    143e:	83 e0       	ldi	r24, 0x03	; 3
    1440:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
	LCD_Write_String("Azza Saeed 912");
    1444:	60 e4       	ldi	r22, 0x40	; 64
    1446:	71 e0       	ldi	r23, 0x01	; 1
    1448:	80 e0       	ldi	r24, 0x00	; 0
    144a:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <LCD_Write_String>
    144e:	2f ef       	ldi	r18, 0xFF	; 255
    1450:	87 ea       	ldi	r24, 0xA7	; 167
    1452:	91 e6       	ldi	r25, 0x61	; 97
    1454:	21 50       	subi	r18, 0x01	; 1
    1456:	80 40       	sbci	r24, 0x00	; 0
    1458:	90 40       	sbci	r25, 0x00	; 0
    145a:	e1 f7       	brne	.-8      	; 0x1454 <LCD_Runable_Page+0x9a>
    145c:	00 c0       	rjmp	.+0      	; 0x145e <LCD_Runable_Page+0xa4>
    145e:	00 00       	nop
	_delay_ms(2000);
	LCD_Clear();
    1460:	0e 94 52 10 	call	0x20a4	; 0x20a4 <LCD_Clear>
	return state_error;
}
    1464:	81 e0       	ldi	r24, 0x01	; 1
    1466:	08 95       	ret

Disassembly of section .text.LCD_Second_Page:

0000117e <LCD_Second_Page>:
	return state_error;
}


ERROR_STATE LCD_Second_Page()
{	ERROR_STATE state_error = SUCCESS;
    117e:	cf 93       	push	r28
    1180:	df 93       	push	r29
    1182:	00 d0       	rcall	.+0      	; 0x1184 <LCD_Second_Page+0x6>
    1184:	0f 92       	push	r0
    1186:	cd b7       	in	r28, 0x3d	; 61
    1188:	de b7       	in	r29, 0x3e	; 62

	bool button_1_val = FALSE;
    118a:	19 82       	std	Y+1, r1	; 0x01
	bool button_2_val = FALSE;
    118c:	1a 82       	std	Y+2, r1	; 0x02
	bool button_3_val = FALSE;
    118e:	1b 82       	std	Y+3, r1	; 0x03
	Display_Action_Buttons(Three_Buttons_No_X);
    1190:	82 e0       	ldi	r24, 0x02	; 2
    1192:	0e 94 48 0d 	call	0x1a90	; 0x1a90 <Display_Action_Buttons>
	while(!button_1_val && !button_2_val && !button_3_val){
    1196:	23 c0       	rjmp	.+70     	; 0x11de <LCD_Second_Page+0x60>
		if(Alarm_1_Fire_Flag || Alarm_2_Fire_Flag || Alarm_3_Fire_Flag){
    1198:	80 91 79 00 	lds	r24, 0x0079	; 0x800079 <Alarm_1_Fire_Flag>
    119c:	81 11       	cpse	r24, r1
    119e:	28 c0       	rjmp	.+80     	; 0x11f0 <LCD_Second_Page+0x72>
    11a0:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <Alarm_2_Fire_Flag>
    11a4:	81 11       	cpse	r24, r1
    11a6:	24 c0       	rjmp	.+72     	; 0x11f0 <LCD_Second_Page+0x72>
    11a8:	80 91 77 00 	lds	r24, 0x0077	; 0x800077 <Alarm_3_Fire_Flag>
    11ac:	81 11       	cpse	r24, r1
    11ae:	20 c0       	rjmp	.+64     	; 0x11f0 <LCD_Second_Page+0x72>
			break;
		}
		Nearest_Time_Display();
    11b0:	0e 94 83 0b 	call	0x1706	; 0x1706 <Nearest_Time_Display>
		BTN_pressed(DIO_PORTD, DIO_PIN7, &button_1_val);
    11b4:	ae 01       	movw	r20, r28
    11b6:	4f 5f       	subi	r20, 0xFF	; 255
    11b8:	5f 4f       	sbci	r21, 0xFF	; 255
    11ba:	67 e0       	ldi	r22, 0x07	; 7
    11bc:	83 e0       	ldi	r24, 0x03	; 3
    11be:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <BTN_pressed>
		BTN_pressed(DIO_PORTD, DIO_PIN6, &button_2_val);
    11c2:	ae 01       	movw	r20, r28
    11c4:	4e 5f       	subi	r20, 0xFE	; 254
    11c6:	5f 4f       	sbci	r21, 0xFF	; 255
    11c8:	66 e0       	ldi	r22, 0x06	; 6
    11ca:	83 e0       	ldi	r24, 0x03	; 3
    11cc:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <BTN_pressed>
		BTN_pressed(DIO_PORTD, DIO_PIN5, &button_3_val);
    11d0:	ae 01       	movw	r20, r28
    11d2:	4d 5f       	subi	r20, 0xFD	; 253
    11d4:	5f 4f       	sbci	r21, 0xFF	; 255
    11d6:	65 e0       	ldi	r22, 0x05	; 5
    11d8:	83 e0       	ldi	r24, 0x03	; 3
    11da:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <BTN_pressed>

	bool button_1_val = FALSE;
	bool button_2_val = FALSE;
	bool button_3_val = FALSE;
	Display_Action_Buttons(Three_Buttons_No_X);
	while(!button_1_val && !button_2_val && !button_3_val){
    11de:	89 81       	ldd	r24, Y+1	; 0x01
    11e0:	81 11       	cpse	r24, r1
    11e2:	06 c0       	rjmp	.+12     	; 0x11f0 <LCD_Second_Page+0x72>
    11e4:	8a 81       	ldd	r24, Y+2	; 0x02
    11e6:	81 11       	cpse	r24, r1
    11e8:	03 c0       	rjmp	.+6      	; 0x11f0 <LCD_Second_Page+0x72>
    11ea:	8b 81       	ldd	r24, Y+3	; 0x03
    11ec:	88 23       	and	r24, r24
    11ee:	a1 f2       	breq	.-88     	; 0x1198 <LCD_Second_Page+0x1a>
		Nearest_Time_Display();
		BTN_pressed(DIO_PORTD, DIO_PIN7, &button_1_val);
		BTN_pressed(DIO_PORTD, DIO_PIN6, &button_2_val);
		BTN_pressed(DIO_PORTD, DIO_PIN5, &button_3_val);
	}
	LCD_Clear();
    11f0:	0e 94 52 10 	call	0x20a4	; 0x20a4 <LCD_Clear>
	
	if(button_1_val){
    11f4:	89 81       	ldd	r24, Y+1	; 0x01
    11f6:	88 23       	and	r24, r24
    11f8:	19 f0       	breq	.+6      	; 0x1200 <LCD_Second_Page+0x82>
		alarm_scheduler();
    11fa:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <alarm_scheduler>
    11fe:	1a c0       	rjmp	.+52     	; 0x1234 <LCD_Second_Page+0xb6>
		/*in case alarm 2 is chosen*/
		} else if(button_2_val){
    1200:	8a 81       	ldd	r24, Y+2	; 0x02
    1202:	88 23       	and	r24, r24
    1204:	29 f0       	breq	.+10     	; 0x1210 <LCD_Second_Page+0x92>
		LCD_Clear();
    1206:	0e 94 52 10 	call	0x20a4	; 0x20a4 <LCD_Clear>
		Remove_Alarm();
    120a:	0e 94 13 0c 	call	0x1826	; 0x1826 <Remove_Alarm>
    120e:	12 c0       	rjmp	.+36     	; 0x1234 <LCD_Second_Page+0xb6>
		/*in case alarm 3 is chosen*/
		} else if(button_3_val){
    1210:	8b 81       	ldd	r24, Y+3	; 0x03
    1212:	88 23       	and	r24, r24
    1214:	79 f0       	breq	.+30     	; 0x1234 <LCD_Second_Page+0xb6>
		LCD_Clear();
    1216:	0e 94 52 10 	call	0x20a4	; 0x20a4 <LCD_Clear>
		if(Show_Alarms()){
    121a:	0e 94 89 0a 	call	0x1512	; 0x1512 <Show_Alarms>
    121e:	88 23       	and	r24, r24
    1220:	49 f0       	breq	.+18     	; 0x1234 <LCD_Second_Page+0xb6>
    1222:	2f ef       	ldi	r18, 0xFF	; 255
    1224:	8b e7       	ldi	r24, 0x7B	; 123
    1226:	92 e9       	ldi	r25, 0x92	; 146
    1228:	21 50       	subi	r18, 0x01	; 1
    122a:	80 40       	sbci	r24, 0x00	; 0
    122c:	90 40       	sbci	r25, 0x00	; 0
    122e:	e1 f7       	brne	.-8      	; 0x1228 <LCD_Second_Page+0xaa>
    1230:	00 c0       	rjmp	.+0      	; 0x1232 <LCD_Second_Page+0xb4>
    1232:	00 00       	nop
		}else{
		/*do nothing*/
	}

	return state_error;
}
    1234:	81 e0       	ldi	r24, 0x01	; 1
    1236:	0f 90       	pop	r0
    1238:	0f 90       	pop	r0
    123a:	0f 90       	pop	r0
    123c:	df 91       	pop	r29
    123e:	cf 91       	pop	r28
    1240:	08 95       	ret

Disassembly of section .text.LCD_First_Page:

00001b58 <LCD_First_Page>:

ERROR_STATE LCD_First_Page(void)
{
	ERROR_STATE state_error = SUCCESS;
	
	if(Alarm_1_Fire_Flag || Alarm_2_Fire_Flag || Alarm_3_Fire_Flag){
    1b58:	80 91 79 00 	lds	r24, 0x0079	; 0x800079 <Alarm_1_Fire_Flag>
    1b5c:	81 11       	cpse	r24, r1
    1b5e:	07 c0       	rjmp	.+14     	; 0x1b6e <LCD_First_Page+0x16>
    1b60:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <Alarm_2_Fire_Flag>
    1b64:	81 11       	cpse	r24, r1
    1b66:	03 c0       	rjmp	.+6      	; 0x1b6e <LCD_First_Page+0x16>
    1b68:	80 91 77 00 	lds	r24, 0x0077	; 0x800077 <Alarm_3_Fire_Flag>
    1b6c:	81 11       	cpse	r24, r1
		Alarm_Action();
    1b6e:	0e 94 7f 09 	call	0x12fe	; 0x12fe <Alarm_Action>
	}
	LCD_Clear();
    1b72:	0e 94 52 10 	call	0x20a4	; 0x20a4 <LCD_Clear>
	LCD_LINE_position(LCD_LINE1,0);
    1b76:	60 e0       	ldi	r22, 0x00	; 0
    1b78:	80 e0       	ldi	r24, 0x00	; 0
    1b7a:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
	LCD_Write_String("1-Set Alarm   |");
    1b7e:	6f e4       	ldi	r22, 0x4F	; 79
    1b80:	71 e0       	ldi	r23, 0x01	; 1
    1b82:	80 e0       	ldi	r24, 0x00	; 0
    1b84:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <LCD_Write_String>
	LCD_LINE_position(LCD_LINE2,0);
    1b88:	60 e0       	ldi	r22, 0x00	; 0
    1b8a:	81 e0       	ldi	r24, 0x01	; 1
    1b8c:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
	LCD_Write_String("2-Cancel Alarm|");
    1b90:	6f e5       	ldi	r22, 0x5F	; 95
    1b92:	71 e0       	ldi	r23, 0x01	; 1
    1b94:	80 e0       	ldi	r24, 0x00	; 0
    1b96:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <LCD_Write_String>
	LCD_LINE_position(LCD_LINE3,0);
    1b9a:	60 e0       	ldi	r22, 0x00	; 0
    1b9c:	82 e0       	ldi	r24, 0x02	; 2
    1b9e:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
	LCD_Write_String("3-Show Alarms |");
    1ba2:	6f e6       	ldi	r22, 0x6F	; 111
    1ba4:	71 e0       	ldi	r23, 0x01	; 1
    1ba6:	80 e0       	ldi	r24, 0x00	; 0
    1ba8:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <LCD_Write_String>
	
	LCD_Second_Page();
    1bac:	0e 94 bf 08 	call	0x117e	; 0x117e <LCD_Second_Page>
	return state_error;
}
    1bb0:	81 e0       	ldi	r24, 0x01	; 1
    1bb2:	08 95       	ret

Disassembly of section .text.__vector_7:

000015bc <__vector_7>:
	}

	return state_error;
}

ISR (TIMER1_COMP_1s){
    15bc:	1f 92       	push	r1
    15be:	0f 92       	push	r0
    15c0:	0f b6       	in	r0, 0x3f	; 63
    15c2:	0f 92       	push	r0
    15c4:	11 24       	eor	r1, r1
    15c6:	2f 93       	push	r18
    15c8:	3f 93       	push	r19
    15ca:	8f 93       	push	r24
    15cc:	9f 93       	push	r25
	TEN_Secs_Counter++;
    15ce:	80 91 6c 00 	lds	r24, 0x006C	; 0x80006c <TEN_Secs_Counter>
    15d2:	90 91 6d 00 	lds	r25, 0x006D	; 0x80006d <TEN_Secs_Counter+0x1>
    15d6:	01 96       	adiw	r24, 0x01	; 1
    15d8:	90 93 6d 00 	sts	0x006D, r25	; 0x80006d <TEN_Secs_Counter+0x1>
    15dc:	80 93 6c 00 	sts	0x006C, r24	; 0x80006c <TEN_Secs_Counter>
	five_sec_timeout++;
    15e0:	80 91 72 00 	lds	r24, 0x0072	; 0x800072 <five_sec_timeout>
    15e4:	8f 5f       	subi	r24, 0xFF	; 255
    15e6:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <five_sec_timeout>
	if(Current_Time < 5940){
    15ea:	80 91 6e 00 	lds	r24, 0x006E	; 0x80006e <Current_Time>
    15ee:	90 91 6f 00 	lds	r25, 0x006F	; 0x80006f <Current_Time+0x1>
    15f2:	84 33       	cpi	r24, 0x34	; 52
    15f4:	27 e1       	ldi	r18, 0x17	; 23
    15f6:	92 07       	cpc	r25, r18
    15f8:	30 f4       	brcc	.+12     	; 0x1606 <__vector_7+0x4a>
		Current_Time++;	
    15fa:	01 96       	adiw	r24, 0x01	; 1
    15fc:	90 93 6f 00 	sts	0x006F, r25	; 0x80006f <Current_Time+0x1>
    1600:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <Current_Time>
    1604:	04 c0       	rjmp	.+8      	; 0x160e <__vector_7+0x52>
	}else{
		Current_Time=0;
    1606:	10 92 6f 00 	sts	0x006F, r1	; 0x80006f <Current_Time+0x1>
    160a:	10 92 6e 00 	sts	0x006E, r1	; 0x80006e <Current_Time>
	}
	if(alarm_ptr_arr[0].Fire_Time == Current_Time){
    160e:	20 91 62 00 	lds	r18, 0x0062	; 0x800062 <__DATA_REGION_ORIGIN__+0x2>
    1612:	30 91 63 00 	lds	r19, 0x0063	; 0x800063 <__DATA_REGION_ORIGIN__+0x3>
    1616:	80 91 6e 00 	lds	r24, 0x006E	; 0x80006e <Current_Time>
    161a:	90 91 6f 00 	lds	r25, 0x006F	; 0x80006f <Current_Time+0x1>
    161e:	28 17       	cp	r18, r24
    1620:	39 07       	cpc	r19, r25
    1622:	19 f4       	brne	.+6      	; 0x162a <__vector_7+0x6e>
		Alarm_1_Fire_Flag =HIGH;
    1624:	21 e0       	ldi	r18, 0x01	; 1
    1626:	20 93 79 00 	sts	0x0079, r18	; 0x800079 <Alarm_1_Fire_Flag>
		//five_sec_timeout=5;
	}
	if(alarm_ptr_arr[1].Fire_Time == Current_Time){
    162a:	20 91 66 00 	lds	r18, 0x0066	; 0x800066 <__DATA_REGION_ORIGIN__+0x6>
    162e:	30 91 67 00 	lds	r19, 0x0067	; 0x800067 <__DATA_REGION_ORIGIN__+0x7>
    1632:	82 17       	cp	r24, r18
    1634:	93 07       	cpc	r25, r19
    1636:	19 f4       	brne	.+6      	; 0x163e <__vector_7+0x82>
		Alarm_2_Fire_Flag =HIGH;
    1638:	21 e0       	ldi	r18, 0x01	; 1
    163a:	20 93 78 00 	sts	0x0078, r18	; 0x800078 <Alarm_2_Fire_Flag>
		//five_sec_timeout=5;
	}
	if(alarm_ptr_arr[2].Fire_Time == Current_Time){
    163e:	20 91 6a 00 	lds	r18, 0x006A	; 0x80006a <__DATA_REGION_ORIGIN__+0xa>
    1642:	30 91 6b 00 	lds	r19, 0x006B	; 0x80006b <__DATA_REGION_ORIGIN__+0xb>
    1646:	82 17       	cp	r24, r18
    1648:	93 07       	cpc	r25, r19
    164a:	19 f4       	brne	.+6      	; 0x1652 <__vector_7+0x96>
		Alarm_3_Fire_Flag =HIGH;
    164c:	81 e0       	ldi	r24, 0x01	; 1
    164e:	80 93 77 00 	sts	0x0077, r24	; 0x800077 <Alarm_3_Fire_Flag>
		//five_sec_timeout=5;
	}
	
    1652:	9f 91       	pop	r25
    1654:	8f 91       	pop	r24
    1656:	3f 91       	pop	r19
    1658:	2f 91       	pop	r18
    165a:	0f 90       	pop	r0
    165c:	0f be       	out	0x3f, r0	; 63
    165e:	0f 90       	pop	r0
    1660:	1f 90       	pop	r1
    1662:	18 95       	reti

Disassembly of section .text.Alarm_Action:

000012fe <Alarm_Action>:

extern UINT8_t usr_def_alarms;
extern alarm_struct alarm_ptr_arr[NUM_OF_ALARMS];
extern bool Alarm_1_Fire_Flag ,Alarm_2_Fire_Flag ,Alarm_3_Fire_Flag ;

void Alarm_Action(){
    12fe:	cf 93       	push	r28
    1300:	df 93       	push	r29
    1302:	00 d0       	rcall	.+0      	; 0x1304 <Alarm_Action+0x6>
    1304:	cd b7       	in	r28, 0x3d	; 61
    1306:	de b7       	in	r29, 0x3e	; 62
	UINT16_t reading=0;
    1308:	1a 82       	std	Y+2, r1	; 0x02
    130a:	19 82       	std	Y+1, r1	; 0x01
	TEN_Secs_Counter=0;
    130c:	10 92 6d 00 	sts	0x006D, r1	; 0x80006d <TEN_Secs_Counter+0x1>
    1310:	10 92 6c 00 	sts	0x006C, r1	; 0x80006c <TEN_Secs_Counter>
	LDR_Read(&reading);
    1314:	ce 01       	movw	r24, r28
    1316:	01 96       	adiw	r24, 0x01	; 1
    1318:	0e 94 b3 0f 	call	0x1f66	; 0x1f66 <LDR_Read>
	LCD_Clear();
    131c:	0e 94 52 10 	call	0x20a4	; 0x20a4 <LCD_Clear>
	LCD_LINE_position(LCD_LINE2,4);
    1320:	64 e0       	ldi	r22, 0x04	; 4
    1322:	81 e0       	ldi	r24, 0x01	; 1
    1324:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
	LCD_Write_String("!! ALARM !!");
    1328:	64 e2       	ldi	r22, 0x24	; 36
    132a:	72 e0       	ldi	r23, 0x02	; 2
    132c:	80 e0       	ldi	r24, 0x00	; 0
    132e:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <LCD_Write_String>
	while (reading<550)
    1332:	17 c0       	rjmp	.+46     	; 0x1362 <Alarm_Action+0x64>
	{
		//printAlarm(((UINT8_t)Current_Time/60),((UINT8_t)Current_Time%60),LCD_LINE2,15);
		LDR_Read(&reading);
    1334:	ce 01       	movw	r24, r28
    1336:	01 96       	adiw	r24, 0x01	; 1
    1338:	0e 94 b3 0f 	call	0x1f66	; 0x1f66 <LDR_Read>
		if (TEN_Secs_Counter>=10){
    133c:	80 91 6c 00 	lds	r24, 0x006C	; 0x80006c <TEN_Secs_Counter>
    1340:	90 91 6d 00 	lds	r25, 0x006D	; 0x80006d <TEN_Secs_Counter+0x1>
    1344:	0a 97       	sbiw	r24, 0x0a	; 10
    1346:	58 f0       	brcs	.+22     	; 0x135e <Alarm_Action+0x60>
			ALL_LEDS_ON();
    1348:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <ALL_LEDS_ON>
			BUZZER_ON();
    134c:	0e 94 fe 0f 	call	0x1ffc	; 0x1ffc <BUZZER_ON>
			TEN_Secs_Counter=10;
    1350:	8a e0       	ldi	r24, 0x0A	; 10
    1352:	90 e0       	ldi	r25, 0x00	; 0
    1354:	90 93 6d 00 	sts	0x006D, r25	; 0x80006d <TEN_Secs_Counter+0x1>
    1358:	80 93 6c 00 	sts	0x006C, r24	; 0x80006c <TEN_Secs_Counter>
    135c:	02 c0       	rjmp	.+4      	; 0x1362 <Alarm_Action+0x64>
			} else {
			ALL_LEDS_dimming();
    135e:	0e 94 6a 10 	call	0x20d4	; 0x20d4 <ALL_LEDS_dimming>
	TEN_Secs_Counter=0;
	LDR_Read(&reading);
	LCD_Clear();
	LCD_LINE_position(LCD_LINE2,4);
	LCD_Write_String("!! ALARM !!");
	while (reading<550)
    1362:	89 81       	ldd	r24, Y+1	; 0x01
    1364:	9a 81       	ldd	r25, Y+2	; 0x02
    1366:	86 32       	cpi	r24, 0x26	; 38
    1368:	92 40       	sbci	r25, 0x02	; 2
    136a:	20 f3       	brcs	.-56     	; 0x1334 <Alarm_Action+0x36>
			TEN_Secs_Counter=10;
			} else {
			ALL_LEDS_dimming();
		}
	}
	BUZZER_OFF();
    136c:	0e 94 05 10 	call	0x200a	; 0x200a <BUZZER_OFF>
	ALL_LEDS_OFF();
    1370:	0e 94 9d 0f 	call	0x1f3a	; 0x1f3a <ALL_LEDS_OFF>
	if(Alarm_1_Fire_Flag){
    1374:	80 91 79 00 	lds	r24, 0x0079	; 0x800079 <Alarm_1_Fire_Flag>
    1378:	88 23       	and	r24, r24
    137a:	21 f0       	breq	.+8      	; 0x1384 <Alarm_Action+0x86>
		erase(1);
    137c:	81 e0       	ldi	r24, 0x01	; 1
    137e:	90 e0       	ldi	r25, 0x00	; 0
    1380:	0e 94 0b 07 	call	0xe16	; 0xe16 <erase>
	}
	if(Alarm_2_Fire_Flag){
    1384:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <Alarm_2_Fire_Flag>
    1388:	88 23       	and	r24, r24
    138a:	21 f0       	breq	.+8      	; 0x1394 <Alarm_Action+0x96>
		erase(2);
    138c:	82 e0       	ldi	r24, 0x02	; 2
    138e:	90 e0       	ldi	r25, 0x00	; 0
    1390:	0e 94 0b 07 	call	0xe16	; 0xe16 <erase>
	}
	if(Alarm_3_Fire_Flag){
    1394:	80 91 77 00 	lds	r24, 0x0077	; 0x800077 <Alarm_3_Fire_Flag>
    1398:	88 23       	and	r24, r24
    139a:	21 f0       	breq	.+8      	; 0x13a4 <Alarm_Action+0xa6>
		erase(3);
    139c:	83 e0       	ldi	r24, 0x03	; 3
    139e:	90 e0       	ldi	r25, 0x00	; 0
    13a0:	0e 94 0b 07 	call	0xe16	; 0xe16 <erase>
	}
	Alarm_1_Fire_Flag =LOW;
    13a4:	10 92 79 00 	sts	0x0079, r1	; 0x800079 <Alarm_1_Fire_Flag>
	Alarm_2_Fire_Flag =LOW;
    13a8:	10 92 78 00 	sts	0x0078, r1	; 0x800078 <Alarm_2_Fire_Flag>
	Alarm_3_Fire_Flag =LOW;
    13ac:	10 92 77 00 	sts	0x0077, r1	; 0x800077 <Alarm_3_Fire_Flag>
}
    13b0:	0f 90       	pop	r0
    13b2:	0f 90       	pop	r0
    13b4:	df 91       	pop	r29
    13b6:	cf 91       	pop	r28
    13b8:	08 95       	ret

Disassembly of section .text.swap:

00001c44 <swap>:
		printAlarm(((UINT8_t)remaining/60),((UINT8_t)remaining%60),LCD_LINE4,15);
	}

}

void swap(alarm_struct *a, alarm_struct *b) {
    1c44:	cf 92       	push	r12
    1c46:	df 92       	push	r13
    1c48:	ef 92       	push	r14
    1c4a:	ff 92       	push	r15
    1c4c:	0f 93       	push	r16
    1c4e:	1f 93       	push	r17
	alarm_struct temp = *a;
    1c50:	fc 01       	movw	r30, r24
    1c52:	00 81       	ld	r16, Z
    1c54:	11 81       	ldd	r17, Z+1	; 0x01
    1c56:	22 81       	ldd	r18, Z+2	; 0x02
    1c58:	33 81       	ldd	r19, Z+3	; 0x03
	*a = *b;
    1c5a:	fb 01       	movw	r30, r22
    1c5c:	c0 80       	ld	r12, Z
    1c5e:	d1 80       	ldd	r13, Z+1	; 0x01
    1c60:	e2 80       	ldd	r14, Z+2	; 0x02
    1c62:	f3 80       	ldd	r15, Z+3	; 0x03
    1c64:	fc 01       	movw	r30, r24
    1c66:	c0 82       	st	Z, r12
    1c68:	d1 82       	std	Z+1, r13	; 0x01
    1c6a:	e2 82       	std	Z+2, r14	; 0x02
    1c6c:	f3 82       	std	Z+3, r15	; 0x03
	*b = temp;
    1c6e:	fb 01       	movw	r30, r22
    1c70:	00 83       	st	Z, r16
    1c72:	11 83       	std	Z+1, r17	; 0x01
    1c74:	22 83       	std	Z+2, r18	; 0x02
    1c76:	33 83       	std	Z+3, r19	; 0x03
}
    1c78:	1f 91       	pop	r17
    1c7a:	0f 91       	pop	r16
    1c7c:	ff 90       	pop	r15
    1c7e:	ef 90       	pop	r14
    1c80:	df 90       	pop	r13
    1c82:	cf 90       	pop	r12
    1c84:	08 95       	ret

Disassembly of section .text.customSort:

00001468 <customSort>:

void customSort(alarm_struct arr[], UINT16_t n) {
    1468:	ef 92       	push	r14
    146a:	ff 92       	push	r15
    146c:	0f 93       	push	r16
    146e:	1f 93       	push	r17
    1470:	cf 93       	push	r28
    1472:	df 93       	push	r29
    1474:	ec 01       	movw	r28, r24
    1476:	7b 01       	movw	r14, r22
	for (UINT16_t i = 0; i < n - 1; i++) {
    1478:	80 e0       	ldi	r24, 0x00	; 0
    147a:	90 e0       	ldi	r25, 0x00	; 0
    147c:	3c c0       	rjmp	.+120    	; 0x14f6 <customSort+0x8e>
		UINT16_t minIndex = i;
		for (UINT16_t j = i + 1; j < n; j++) {
    147e:	8c 01       	movw	r16, r24
    1480:	0f 5f       	subi	r16, 0xFF	; 255
    1482:	1f 4f       	sbci	r17, 0xFF	; 255
    1484:	98 01       	movw	r18, r16
	*b = temp;
}

void customSort(alarm_struct arr[], UINT16_t n) {
	for (UINT16_t i = 0; i < n - 1; i++) {
		UINT16_t minIndex = i;
    1486:	bc 01       	movw	r22, r24
		for (UINT16_t j = i + 1; j < n; j++) {
    1488:	21 c0       	rjmp	.+66     	; 0x14cc <customSort+0x64>
			if (arr[j].Fire_Time != 0 &&
    148a:	f9 01       	movw	r30, r18
    148c:	ee 0f       	add	r30, r30
    148e:	ff 1f       	adc	r31, r31
    1490:	ee 0f       	add	r30, r30
    1492:	ff 1f       	adc	r31, r31
    1494:	ec 0f       	add	r30, r28
    1496:	fd 1f       	adc	r31, r29
    1498:	42 81       	ldd	r20, Z+2	; 0x02
    149a:	53 81       	ldd	r21, Z+3	; 0x03
    149c:	41 15       	cp	r20, r1
    149e:	51 05       	cpc	r21, r1
    14a0:	99 f0       	breq	.+38     	; 0x14c8 <customSort+0x60>
			(arr[minIndex].Fire_Time == 0 || arr[j].Fire_Time < arr[minIndex].Fire_Time)) {
    14a2:	fb 01       	movw	r30, r22
    14a4:	ee 0f       	add	r30, r30
    14a6:	ff 1f       	adc	r31, r31
    14a8:	ee 0f       	add	r30, r30
    14aa:	ff 1f       	adc	r31, r31
    14ac:	ec 0f       	add	r30, r28
    14ae:	fd 1f       	adc	r31, r29
    14b0:	02 80       	ldd	r0, Z+2	; 0x02
    14b2:	f3 81       	ldd	r31, Z+3	; 0x03
    14b4:	e0 2d       	mov	r30, r0

void customSort(alarm_struct arr[], UINT16_t n) {
	for (UINT16_t i = 0; i < n - 1; i++) {
		UINT16_t minIndex = i;
		for (UINT16_t j = i + 1; j < n; j++) {
			if (arr[j].Fire_Time != 0 &&
    14b6:	30 97       	sbiw	r30, 0x00	; 0
    14b8:	21 f0       	breq	.+8      	; 0x14c2 <customSort+0x5a>
			(arr[minIndex].Fire_Time == 0 || arr[j].Fire_Time < arr[minIndex].Fire_Time)) {
    14ba:	4e 17       	cp	r20, r30
    14bc:	5f 07       	cpc	r21, r31
    14be:	18 f0       	brcs	.+6      	; 0x14c6 <customSort+0x5e>
    14c0:	03 c0       	rjmp	.+6      	; 0x14c8 <customSort+0x60>
				minIndex = j;
    14c2:	b9 01       	movw	r22, r18
    14c4:	01 c0       	rjmp	.+2      	; 0x14c8 <customSort+0x60>
    14c6:	b9 01       	movw	r22, r18
}

void customSort(alarm_struct arr[], UINT16_t n) {
	for (UINT16_t i = 0; i < n - 1; i++) {
		UINT16_t minIndex = i;
		for (UINT16_t j = i + 1; j < n; j++) {
    14c8:	2f 5f       	subi	r18, 0xFF	; 255
    14ca:	3f 4f       	sbci	r19, 0xFF	; 255
    14cc:	2e 15       	cp	r18, r14
    14ce:	3f 05       	cpc	r19, r15
    14d0:	e0 f2       	brcs	.-72     	; 0x148a <customSort+0x22>
			if (arr[j].Fire_Time != 0 &&
			(arr[minIndex].Fire_Time == 0 || arr[j].Fire_Time < arr[minIndex].Fire_Time)) {
				minIndex = j;
			}
		}
		if (minIndex != i) {
    14d2:	86 17       	cp	r24, r22
    14d4:	97 07       	cpc	r25, r23
    14d6:	71 f0       	breq	.+28     	; 0x14f4 <customSort+0x8c>
			swap(&arr[i], &arr[minIndex]);
    14d8:	66 0f       	add	r22, r22
    14da:	77 1f       	adc	r23, r23
    14dc:	66 0f       	add	r22, r22
    14de:	77 1f       	adc	r23, r23
    14e0:	88 0f       	add	r24, r24
    14e2:	99 1f       	adc	r25, r25
    14e4:	88 0f       	add	r24, r24
    14e6:	99 1f       	adc	r25, r25
    14e8:	6c 0f       	add	r22, r28
    14ea:	7d 1f       	adc	r23, r29
    14ec:	8c 0f       	add	r24, r28
    14ee:	9d 1f       	adc	r25, r29
    14f0:	0e 94 22 0e 	call	0x1c44	; 0x1c44 <swap>
	*b = temp;
}

void customSort(alarm_struct arr[], UINT16_t n) {
	for (UINT16_t i = 0; i < n - 1; i++) {
		UINT16_t minIndex = i;
    14f4:	c8 01       	movw	r24, r16
	*a = *b;
	*b = temp;
}

void customSort(alarm_struct arr[], UINT16_t n) {
	for (UINT16_t i = 0; i < n - 1; i++) {
    14f6:	97 01       	movw	r18, r14
    14f8:	21 50       	subi	r18, 0x01	; 1
    14fa:	31 09       	sbc	r19, r1
    14fc:	82 17       	cp	r24, r18
    14fe:	93 07       	cpc	r25, r19
    1500:	08 f4       	brcc	.+2      	; 0x1504 <customSort+0x9c>
    1502:	bd cf       	rjmp	.-134    	; 0x147e <customSort+0x16>
		}
		if (minIndex != i) {
			swap(&arr[i], &arr[minIndex]);
		}
	}
    1504:	df 91       	pop	r29
    1506:	cf 91       	pop	r28
    1508:	1f 91       	pop	r17
    150a:	0f 91       	pop	r16
    150c:	ff 90       	pop	r15
    150e:	ef 90       	pop	r14
    1510:	08 95       	ret

Disassembly of section .text.Nearest_Time_Display:

00001706 <Nearest_Time_Display>:
	Alarm_2_Fire_Flag =LOW;
	Alarm_3_Fire_Flag =LOW;
}

void Nearest_Time_Display(void){
	printAlarm(((UINT8_t)(Current_Time/60)),((UINT8_t)(Current_Time%60)),LCD_LINE2,15);
    1706:	40 91 6e 00 	lds	r20, 0x006E	; 0x80006e <Current_Time>
    170a:	50 91 6f 00 	lds	r21, 0x006F	; 0x80006f <Current_Time+0x1>
    170e:	9a 01       	movw	r18, r20
    1710:	a9 e8       	ldi	r26, 0x89	; 137
    1712:	b8 e8       	ldi	r27, 0x88	; 136
    1714:	0e 94 51 0f 	call	0x1ea2	; 0x1ea2 <__umulhisi3>
    1718:	fc 01       	movw	r30, r24
    171a:	f6 95       	lsr	r31
    171c:	e7 95       	ror	r30
    171e:	f2 95       	swap	r31
    1720:	e2 95       	swap	r30
    1722:	ef 70       	andi	r30, 0x0F	; 15
    1724:	ef 27       	eor	r30, r31
    1726:	ff 70       	andi	r31, 0x0F	; 15
    1728:	ef 27       	eor	r30, r31
    172a:	2c e3       	ldi	r18, 0x3C	; 60
    172c:	2e 9f       	mul	r18, r30
    172e:	c0 01       	movw	r24, r0
    1730:	2f 9f       	mul	r18, r31
    1732:	90 0d       	add	r25, r0
    1734:	11 24       	eor	r1, r1
    1736:	fa 01       	movw	r30, r20
    1738:	e8 1b       	sub	r30, r24
    173a:	f9 0b       	sbc	r31, r25
    173c:	9a 01       	movw	r18, r20
    173e:	0e 94 51 0f 	call	0x1ea2	; 0x1ea2 <__umulhisi3>
    1742:	96 95       	lsr	r25
    1744:	87 95       	ror	r24
    1746:	92 95       	swap	r25
    1748:	82 95       	swap	r24
    174a:	8f 70       	andi	r24, 0x0F	; 15
    174c:	89 27       	eor	r24, r25
    174e:	9f 70       	andi	r25, 0x0F	; 15
    1750:	89 27       	eor	r24, r25
    1752:	2f e0       	ldi	r18, 0x0F	; 15
    1754:	41 e0       	ldi	r20, 0x01	; 1
    1756:	6e 2f       	mov	r22, r30
    1758:	0e 94 21 09 	call	0x1242	; 0x1242 <printAlarm>
	if(usr_def_alarms >0){
    175c:	60 91 71 00 	lds	r22, 0x0071	; 0x800071 <usr_def_alarms>
    1760:	66 23       	and	r22, r22
    1762:	d9 f0       	breq	.+54     	; 0x179a <Nearest_Time_Display+0x94>
		customSort(alarm_ptr_arr,usr_def_alarms);
    1764:	70 e0       	ldi	r23, 0x00	; 0
    1766:	80 e6       	ldi	r24, 0x60	; 96
    1768:	90 e0       	ldi	r25, 0x00	; 0
    176a:	0e 94 34 0a 	call	0x1468	; 0x1468 <customSort>
		UINT16_t remaining = alarm_ptr_arr[0].Fire_Time-Current_Time;
    176e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__DATA_REGION_ORIGIN__+0x2>
    1772:	90 91 63 00 	lds	r25, 0x0063	; 0x800063 <__DATA_REGION_ORIGIN__+0x3>
    1776:	20 91 6e 00 	lds	r18, 0x006E	; 0x80006e <Current_Time>
    177a:	30 91 6f 00 	lds	r19, 0x006F	; 0x80006f <Current_Time+0x1>
    177e:	82 1b       	sub	r24, r18
    1780:	93 0b       	sbc	r25, r19
		printAlarm(((UINT8_t)remaining/60),((UINT8_t)remaining%60),LCD_LINE4,15);
    1782:	99 27       	eor	r25, r25
    1784:	6c e3       	ldi	r22, 0x3C	; 60
    1786:	70 e0       	ldi	r23, 0x00	; 0
    1788:	0e 94 e9 0e 	call	0x1dd2	; 0x1dd2 <__divmodhi4>
    178c:	96 2f       	mov	r25, r22
    178e:	2f e0       	ldi	r18, 0x0F	; 15
    1790:	43 e0       	ldi	r20, 0x03	; 3
    1792:	68 2f       	mov	r22, r24
    1794:	89 2f       	mov	r24, r25
    1796:	0e 94 21 09 	call	0x1242	; 0x1242 <printAlarm>
    179a:	08 95       	ret

Disassembly of section .text.Show_Alarms:

00001512 <Show_Alarms>:
extern UINT8_t usr_def_alarms;
extern alarm_struct alarm_ptr_arr[NUM_OF_ALARMS];
extern bool Alarm_1_Fire_Flag ,Alarm_2_Fire_Flag ,Alarm_3_Fire_Flag ;

/* Tested for king EMBO*/
ERROR_STATE Show_Alarms(){
    1512:	0f 93       	push	r16
    1514:	1f 93       	push	r17
    1516:	cf 93       	push	r28
    1518:	df 93       	push	r29
	ERROR_STATE state_error = SUCCESS;
	if (usr_def_alarms == 0){
    151a:	80 91 71 00 	lds	r24, 0x0071	; 0x800071 <usr_def_alarms>
    151e:	81 11       	cpse	r24, r1
    1520:	41 c0       	rjmp	.+130    	; 0x15a4 <Show_Alarms+0x92>
		LCD_Write_String("No Alarms Set");
    1522:	68 ef       	ldi	r22, 0xF8	; 248
    1524:	71 e0       	ldi	r23, 0x01	; 1
    1526:	80 e0       	ldi	r24, 0x00	; 0
    1528:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <LCD_Write_String>
    152c:	2f ef       	ldi	r18, 0xFF	; 255
    152e:	87 ea       	ldi	r24, 0xA7	; 167
    1530:	91 e6       	ldi	r25, 0x61	; 97
    1532:	21 50       	subi	r18, 0x01	; 1
    1534:	80 40       	sbci	r24, 0x00	; 0
    1536:	90 40       	sbci	r25, 0x00	; 0
    1538:	e1 f7       	brne	.-8      	; 0x1532 <Show_Alarms+0x20>
    153a:	00 c0       	rjmp	.+0      	; 0x153c <Show_Alarms+0x2a>
    153c:	00 00       	nop
		_delay_ms(2000);
		state_error = FAIL;
    153e:	80 e0       	ldi	r24, 0x00	; 0
    1540:	38 c0       	rjmp	.+112    	; 0x15b2 <Show_Alarms+0xa0>
		UINT8_t i=0;
		LCD_LINES Rows=LCD_LINE1;
		UINT8_t index=1;
		for (i=0;i<usr_def_alarms;i++){

			LCD_LINE_position(Rows,0);
    1542:	60 e0       	ldi	r22, 0x00	; 0
    1544:	81 2f       	mov	r24, r17
    1546:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
			LCD_Write_Number(i+1);
    154a:	c0 2f       	mov	r28, r16
    154c:	d0 e0       	ldi	r29, 0x00	; 0
    154e:	ae 01       	movw	r20, r28
    1550:	4f 5f       	subi	r20, 0xFF	; 255
    1552:	5f 4f       	sbci	r21, 0xFF	; 255
    1554:	95 2f       	mov	r25, r21
    1556:	99 0f       	add	r25, r25
    1558:	99 0b       	sbc	r25, r25
    155a:	24 2f       	mov	r18, r20
    155c:	35 2f       	mov	r19, r21
    155e:	49 2f       	mov	r20, r25
    1560:	59 2f       	mov	r21, r25
    1562:	69 2f       	mov	r22, r25
    1564:	79 2f       	mov	r23, r25
    1566:	89 2f       	mov	r24, r25
    1568:	0e 94 50 04 	call	0x8a0	; 0x8a0 <LCD_Write_Number>
			index++;
			LCD_LINE_position(Rows,1);
    156c:	61 e0       	ldi	r22, 0x01	; 1
    156e:	81 2f       	mov	r24, r17
    1570:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
			LCD_Write_String("- ");
    1574:	66 e0       	ldi	r22, 0x06	; 6
    1576:	72 e0       	ldi	r23, 0x02	; 2
    1578:	80 e0       	ldi	r24, 0x00	; 0
    157a:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <LCD_Write_String>
			printAlarm(alarm_ptr_arr[i].minutes,alarm_ptr_arr[i].seconds,Rows,2);
    157e:	cc 0f       	add	r28, r28
    1580:	dd 1f       	adc	r29, r29
    1582:	cc 0f       	add	r28, r28
    1584:	dd 1f       	adc	r29, r29
    1586:	c0 5a       	subi	r28, 0xA0	; 160
    1588:	df 4f       	sbci	r29, 0xFF	; 255
    158a:	22 e0       	ldi	r18, 0x02	; 2
    158c:	41 2f       	mov	r20, r17
    158e:	69 81       	ldd	r22, Y+1	; 0x01
    1590:	88 81       	ld	r24, Y
    1592:	0e 94 21 09 	call	0x1242	; 0x1242 <printAlarm>
			Rows++;
    1596:	1f 5f       	subi	r17, 0xFF	; 255
			LCD_LINE_position(Rows,0);
    1598:	60 e0       	ldi	r22, 0x00	; 0
    159a:	81 2f       	mov	r24, r17
    159c:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
		state_error = FAIL;
	}else{
		UINT8_t i=0;
		LCD_LINES Rows=LCD_LINE1;
		UINT8_t index=1;
		for (i=0;i<usr_def_alarms;i++){
    15a0:	0f 5f       	subi	r16, 0xFF	; 255
    15a2:	02 c0       	rjmp	.+4      	; 0x15a8 <Show_Alarms+0x96>
    15a4:	10 e0       	ldi	r17, 0x00	; 0
    15a6:	00 e0       	ldi	r16, 0x00	; 0
    15a8:	80 91 71 00 	lds	r24, 0x0071	; 0x800071 <usr_def_alarms>
    15ac:	08 17       	cp	r16, r24
    15ae:	48 f2       	brcs	.-110    	; 0x1542 <Show_Alarms+0x30>
extern alarm_struct alarm_ptr_arr[NUM_OF_ALARMS];
extern bool Alarm_1_Fire_Flag ,Alarm_2_Fire_Flag ,Alarm_3_Fire_Flag ;

/* Tested for king EMBO*/
ERROR_STATE Show_Alarms(){
	ERROR_STATE state_error = SUCCESS;
    15b0:	81 e0       	ldi	r24, 0x01	; 1
			LCD_LINE_position(Rows,0);
		}
	}

	return state_error;
}
    15b2:	df 91       	pop	r29
    15b4:	cf 91       	pop	r28
    15b6:	1f 91       	pop	r17
    15b8:	0f 91       	pop	r16
    15ba:	08 95       	ret

Disassembly of section .text.erase:

00000e16 <erase>:
	}
	
	return state_error;
	
}
void erase(UINT16_t reading){
 e16:	cf 93       	push	r28
 e18:	df 93       	push	r29
 e1a:	9c 01       	movw	r18, r24
	alarm_ptr_arr[reading-1].minutes=0;
 e1c:	fc 01       	movw	r30, r24
 e1e:	31 97       	sbiw	r30, 0x01	; 1
 e20:	ee 0f       	add	r30, r30
 e22:	ff 1f       	adc	r31, r31
 e24:	ee 0f       	add	r30, r30
 e26:	ff 1f       	adc	r31, r31
 e28:	e0 5a       	subi	r30, 0xA0	; 160
 e2a:	ff 4f       	sbci	r31, 0xFF	; 255
 e2c:	10 82       	st	Z, r1
	alarm_ptr_arr[reading-1].seconds=0;
 e2e:	11 82       	std	Z+1, r1	; 0x01
	alarm_ptr_arr[reading-1].Fire_Time=0;
 e30:	13 82       	std	Z+3, r1	; 0x03
 e32:	12 82       	std	Z+2, r1	; 0x02
	UINT8_t shift=usr_def_alarms;
 e34:	90 91 71 00 	lds	r25, 0x0071	; 0x800071 <usr_def_alarms>
	if(reading==1){
 e38:	21 30       	cpi	r18, 0x01	; 1
 e3a:	31 05       	cpc	r19, r1
 e3c:	61 f5       	brne	.+88     	; 0xe96 <erase+0x80>
 e3e:	1d c0       	rjmp	.+58     	; 0xe7a <erase+0x64>
		UINT8_t shift_index=0;
		while(shift!=1){
			alarm_ptr_arr[shift_index]=alarm_ptr_arr[shift_index+1];
 e40:	2e 2f       	mov	r18, r30
 e42:	30 e0       	ldi	r19, 0x00	; 0
 e44:	e9 01       	movw	r28, r18
 e46:	21 96       	adiw	r28, 0x01	; 1
 e48:	22 0f       	add	r18, r18
 e4a:	33 1f       	adc	r19, r19
 e4c:	22 0f       	add	r18, r18
 e4e:	33 1f       	adc	r19, r19
 e50:	d9 01       	movw	r26, r18
 e52:	a0 5a       	subi	r26, 0xA0	; 160
 e54:	bf 4f       	sbci	r27, 0xFF	; 255
 e56:	cc 0f       	add	r28, r28
 e58:	dd 1f       	adc	r29, r29
 e5a:	cc 0f       	add	r28, r28
 e5c:	dd 1f       	adc	r29, r29
 e5e:	c0 5a       	subi	r28, 0xA0	; 160
 e60:	df 4f       	sbci	r29, 0xFF	; 255
 e62:	48 81       	ld	r20, Y
 e64:	59 81       	ldd	r21, Y+1	; 0x01
 e66:	6a 81       	ldd	r22, Y+2	; 0x02
 e68:	7b 81       	ldd	r23, Y+3	; 0x03
 e6a:	4d 93       	st	X+, r20
 e6c:	5d 93       	st	X+, r21
 e6e:	6d 93       	st	X+, r22
 e70:	7c 93       	st	X, r23
 e72:	13 97       	sbiw	r26, 0x03	; 3
			shift_index++;
 e74:	ef 5f       	subi	r30, 0xFF	; 255
			shift--;
 e76:	81 50       	subi	r24, 0x01	; 1
 e78:	02 c0       	rjmp	.+4      	; 0xe7e <erase+0x68>
 e7a:	89 2f       	mov	r24, r25
 e7c:	e0 e0       	ldi	r30, 0x00	; 0
	alarm_ptr_arr[reading-1].seconds=0;
	alarm_ptr_arr[reading-1].Fire_Time=0;
	UINT8_t shift=usr_def_alarms;
	if(reading==1){
		UINT8_t shift_index=0;
		while(shift!=1){
 e7e:	81 30       	cpi	r24, 0x01	; 1
 e80:	f9 f6       	brne	.-66     	; 0xe40 <erase+0x2a>
			alarm_ptr_arr[shift_index]=alarm_ptr_arr[shift_index+1];
			shift_index++;
			shift--;
		}
		alarm_ptr_arr[shift_index].minutes = 0;
 e82:	f0 e0       	ldi	r31, 0x00	; 0
 e84:	ee 0f       	add	r30, r30
 e86:	ff 1f       	adc	r31, r31
 e88:	ee 0f       	add	r30, r30
 e8a:	ff 1f       	adc	r31, r31
 e8c:	e0 5a       	subi	r30, 0xA0	; 160
 e8e:	ff 4f       	sbci	r31, 0xFF	; 255
 e90:	10 82       	st	Z, r1
		alarm_ptr_arr[shift_index].seconds = 0;
 e92:	11 82       	std	Z+1, r1	; 0x01
 e94:	0f c0       	rjmp	.+30     	; 0xeb4 <erase+0x9e>
	}
	else if(reading==2){
 e96:	22 30       	cpi	r18, 0x02	; 2
 e98:	31 05       	cpc	r19, r1
 e9a:	61 f4       	brne	.+24     	; 0xeb4 <erase+0x9e>
		if (usr_def_alarms==NUM_OF_ALARMS){
 e9c:	93 30       	cpi	r25, 0x03	; 3
 e9e:	51 f4       	brne	.+20     	; 0xeb4 <erase+0x9e>
			alarm_ptr_arr[1]=alarm_ptr_arr[2];
 ea0:	e0 e6       	ldi	r30, 0x60	; 96
 ea2:	f0 e0       	ldi	r31, 0x00	; 0
 ea4:	40 85       	ldd	r20, Z+8	; 0x08
 ea6:	51 85       	ldd	r21, Z+9	; 0x09
 ea8:	62 85       	ldd	r22, Z+10	; 0x0a
 eaa:	73 85       	ldd	r23, Z+11	; 0x0b
 eac:	44 83       	std	Z+4, r20	; 0x04
 eae:	55 83       	std	Z+5, r21	; 0x05
 eb0:	66 83       	std	Z+6, r22	; 0x06
 eb2:	77 83       	std	Z+7, r23	; 0x07
	}
	else {
		/* Do Nothing*/
	}
	
	usr_def_alarms--;
 eb4:	91 50       	subi	r25, 0x01	; 1
 eb6:	90 93 71 00 	sts	0x0071, r25	; 0x800071 <usr_def_alarms>
	if(!Alarm_1_Fire_Flag && !Alarm_2_Fire_Flag && !Alarm_3_Fire_Flag){
 eba:	80 91 79 00 	lds	r24, 0x0079	; 0x800079 <Alarm_1_Fire_Flag>
 ebe:	81 11       	cpse	r24, r1
 ec0:	1f c0       	rjmp	.+62     	; 0xf00 <erase+0xea>
 ec2:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <Alarm_2_Fire_Flag>
 ec6:	81 11       	cpse	r24, r1
 ec8:	1b c0       	rjmp	.+54     	; 0xf00 <erase+0xea>
 eca:	80 91 77 00 	lds	r24, 0x0077	; 0x800077 <Alarm_3_Fire_Flag>
 ece:	81 11       	cpse	r24, r1
 ed0:	17 c0       	rjmp	.+46     	; 0xf00 <erase+0xea>
		LCD_Write_String("ALARM DELETED");
 ed2:	69 e0       	ldi	r22, 0x09	; 9
 ed4:	72 e0       	ldi	r23, 0x02	; 2
 ed6:	80 e0       	ldi	r24, 0x00	; 0
 ed8:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <LCD_Write_String>
		LCD_LINE_position(LCD_LINE2,0);
 edc:	60 e0       	ldi	r22, 0x00	; 0
 ede:	81 e0       	ldi	r24, 0x01	; 1
 ee0:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_LINE_position>
		LCD_Write_String("SUCCESSFULLY");
 ee4:	67 e1       	ldi	r22, 0x17	; 23
 ee6:	72 e0       	ldi	r23, 0x02	; 2
 ee8:	80 e0       	ldi	r24, 0x00	; 0
 eea:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <LCD_Write_String>
 eee:	2f ef       	ldi	r18, 0xFF	; 255
 ef0:	87 ea       	ldi	r24, 0xA7	; 167
 ef2:	91 e6       	ldi	r25, 0x61	; 97
 ef4:	21 50       	subi	r18, 0x01	; 1
 ef6:	80 40       	sbci	r24, 0x00	; 0
 ef8:	90 40       	sbci	r25, 0x00	; 0
 efa:	e1 f7       	brne	.-8      	; 0xef4 <erase+0xde>
 efc:	00 c0       	rjmp	.+0      	; 0xefe <erase+0xe8>
 efe:	00 00       	nop
		_delay_ms(2000);
	}
	LCD_Clear();
 f00:	0e 94 52 10 	call	0x20a4	; 0x20a4 <LCD_Clear>
}
 f04:	df 91       	pop	r29
 f06:	cf 91       	pop	r28
 f08:	08 95       	ret

Disassembly of section .text.Remove_Alarm:

00001826 <Remove_Alarm>:
	}

	return state_error;
}
/* Tested for King EMBO*/
ERROR_STATE Remove_Alarm(){
    1826:	cf 93       	push	r28
    1828:	df 93       	push	r29
    182a:	00 d0       	rcall	.+0      	; 0x182c <Remove_Alarm+0x6>
    182c:	00 d0       	rcall	.+0      	; 0x182e <Remove_Alarm+0x8>
    182e:	cd b7       	in	r28, 0x3d	; 61
    1830:	de b7       	in	r29, 0x3e	; 62
	ERROR_STATE state_error = SUCCESS;
	
	bool button_1_val = FALSE;
    1832:	19 82       	std	Y+1, r1	; 0x01
	bool button_2_val = FALSE;
    1834:	1a 82       	std	Y+2, r1	; 0x02
	bool button_3_val = FALSE;
    1836:	1b 82       	std	Y+3, r1	; 0x03
	bool button_4_val = FALSE;
    1838:	1c 82       	std	Y+4, r1	; 0x04

	if(Show_Alarms()){
    183a:	0e 94 89 0a 	call	0x1512	; 0x1512 <Show_Alarms>
    183e:	88 23       	and	r24, r24
    1840:	69 f1       	breq	.+90     	; 0x189c <Remove_Alarm+0x76>
		Display_Action_Buttons(All_Buttons);
    1842:	84 e0       	ldi	r24, 0x04	; 4
    1844:	0e 94 48 0d 	call	0x1a90	; 0x1a90 <Display_Action_Buttons>
		Check_Button_Update(&button_1_val,&button_2_val,&button_3_val,&button_4_val);
    1848:	9e 01       	movw	r18, r28
    184a:	2c 5f       	subi	r18, 0xFC	; 252
    184c:	3f 4f       	sbci	r19, 0xFF	; 255
    184e:	ae 01       	movw	r20, r28
    1850:	4d 5f       	subi	r20, 0xFD	; 253
    1852:	5f 4f       	sbci	r21, 0xFF	; 255
    1854:	be 01       	movw	r22, r28
    1856:	6e 5f       	subi	r22, 0xFE	; 254
    1858:	7f 4f       	sbci	r23, 0xFF	; 255
    185a:	ce 01       	movw	r24, r28
    185c:	01 96       	adiw	r24, 0x01	; 1
    185e:	0e 94 ce 0b 	call	0x179c	; 0x179c <Check_Button_Update>
		LCD_Clear();
    1862:	0e 94 52 10 	call	0x20a4	; 0x20a4 <LCD_Clear>
		
		if(button_1_val){
    1866:	89 81       	ldd	r24, Y+1	; 0x01
    1868:	88 23       	and	r24, r24
    186a:	31 f0       	breq	.+12     	; 0x1878 <Remove_Alarm+0x52>
			erase(1);
    186c:	81 e0       	ldi	r24, 0x01	; 1
    186e:	90 e0       	ldi	r25, 0x00	; 0
    1870:	0e 94 0b 07 	call	0xe16	; 0xe16 <erase>

	return state_error;
}
/* Tested for King EMBO*/
ERROR_STATE Remove_Alarm(){
	ERROR_STATE state_error = SUCCESS;
    1874:	81 e0       	ldi	r24, 0x01	; 1
    1876:	15 c0       	rjmp	.+42     	; 0x18a2 <Remove_Alarm+0x7c>
		LCD_Clear();
		
		if(button_1_val){
			erase(1);
			/*in case alarm 2 is chosen*/
			} else if(button_2_val){
    1878:	8a 81       	ldd	r24, Y+2	; 0x02
    187a:	88 23       	and	r24, r24
    187c:	31 f0       	breq	.+12     	; 0x188a <Remove_Alarm+0x64>
			erase(2);
    187e:	82 e0       	ldi	r24, 0x02	; 2
    1880:	90 e0       	ldi	r25, 0x00	; 0
    1882:	0e 94 0b 07 	call	0xe16	; 0xe16 <erase>

	return state_error;
}
/* Tested for King EMBO*/
ERROR_STATE Remove_Alarm(){
	ERROR_STATE state_error = SUCCESS;
    1886:	81 e0       	ldi	r24, 0x01	; 1
    1888:	0c c0       	rjmp	.+24     	; 0x18a2 <Remove_Alarm+0x7c>
			erase(1);
			/*in case alarm 2 is chosen*/
			} else if(button_2_val){
			erase(2);
			/*in case alarm 3 is chosen*/
			} else if(button_3_val){
    188a:	8b 81       	ldd	r24, Y+3	; 0x03
    188c:	88 23       	and	r24, r24
    188e:	41 f0       	breq	.+16     	; 0x18a0 <Remove_Alarm+0x7a>
			erase(3);
    1890:	83 e0       	ldi	r24, 0x03	; 3
    1892:	90 e0       	ldi	r25, 0x00	; 0
    1894:	0e 94 0b 07 	call	0xe16	; 0xe16 <erase>

	return state_error;
}
/* Tested for King EMBO*/
ERROR_STATE Remove_Alarm(){
	ERROR_STATE state_error = SUCCESS;
    1898:	81 e0       	ldi	r24, 0x01	; 1
    189a:	03 c0       	rjmp	.+6      	; 0x18a2 <Remove_Alarm+0x7c>
			/*do nothing*/;
			} else{
			/*do nothing*/;
		}
	}else{
		state_error = FAIL;
    189c:	80 e0       	ldi	r24, 0x00	; 0
    189e:	01 c0       	rjmp	.+2      	; 0x18a2 <Remove_Alarm+0x7c>

	return state_error;
}
/* Tested for King EMBO*/
ERROR_STATE Remove_Alarm(){
	ERROR_STATE state_error = SUCCESS;
    18a0:	81 e0       	ldi	r24, 0x01	; 1
		state_error = FAIL;
	}
	
	return state_error;
	
}
    18a2:	0f 90       	pop	r0
    18a4:	0f 90       	pop	r0
    18a6:	0f 90       	pop	r0
    18a8:	0f 90       	pop	r0
    18aa:	df 91       	pop	r29
    18ac:	cf 91       	pop	r28
    18ae:	08 95       	ret

Disassembly of section .text.BLUE_LED_Initializ:

00001fc4 <BLUE_LED_Initializ>:

#include "BLUE_LED_Private.h"

ERROR_STATE BLUE_LED_Initializ(void){
	ERROR_STATE state_error = SUCCESS;
	DIO_SetPin_Direction(BLUE_LED_PORT,BLUE_LED_PIN,BLUE_LED_OUTPUT);
    1fc4:	41 e0       	ldi	r20, 0x01	; 1
    1fc6:	65 e0       	ldi	r22, 0x05	; 5
    1fc8:	80 e0       	ldi	r24, 0x00	; 0
    1fca:	0e 94 0d 06 	call	0xc1a	; 0xc1a <DIO_SetPin_Direction>
	return state_error;
}
    1fce:	81 e0       	ldi	r24, 0x01	; 1
    1fd0:	08 95       	ret

Disassembly of section .text.BLUE_LED_ON:

00001fd2 <BLUE_LED_ON>:
ERROR_STATE BLUE_LED_ON(void){
	ERROR_STATE state_error = SUCCESS;
	DIO_SetPin_Value(BLUE_LED_PORT,BLUE_LED_PIN,BLUE_LED_HIGH);
    1fd2:	41 e0       	ldi	r20, 0x01	; 1
    1fd4:	65 e0       	ldi	r22, 0x05	; 5
    1fd6:	80 e0       	ldi	r24, 0x00	; 0
    1fd8:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
	return state_error;
}
    1fdc:	81 e0       	ldi	r24, 0x01	; 1
    1fde:	08 95       	ret

Disassembly of section .text.BLUE_LED_OFF:

00001fe0 <BLUE_LED_OFF>:
ERROR_STATE BLUE_LED_OFF(void){
	ERROR_STATE state_error = SUCCESS;
	DIO_SetPin_Value(BLUE_LED_PORT,BLUE_LED_PIN,BLUE_LED_LOW);
    1fe0:	40 e0       	ldi	r20, 0x00	; 0
    1fe2:	65 e0       	ldi	r22, 0x05	; 5
    1fe4:	80 e0       	ldi	r24, 0x00	; 0
    1fe6:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
	return state_error;
}
    1fea:	81 e0       	ldi	r24, 0x01	; 1
    1fec:	08 95       	ret

Disassembly of section .text.BLUE_LED_TGL:

00002018 <BLUE_LED_TGL>:
ERROR_STATE BLUE_LED_TGL(void){
	ERROR_STATE state_error = SUCCESS;
	DIO_TglPin_Value(BLUE_LED_PORT,BLUE_LED_PIN);
    2018:	65 e0       	ldi	r22, 0x05	; 5
    201a:	80 e0       	ldi	r24, 0x00	; 0
    201c:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <DIO_TglPin_Value>
	return state_error;
}
    2020:	81 e0       	ldi	r24, 0x01	; 1
    2022:	08 95       	ret

Disassembly of section .text.BTN_Initialization:

00002090 <BTN_Initialization>:
#include "button_Private.h"

bool BTN_OneTime = LOW;
ERROR_STATE BTN_Initialization(DIO_Port port, DIO_Pin pin){
	ERROR_STATE state_error = SUCCESS;
	DIO_SetPin_Direction(port , pin , DIO_INPUT);
    2090:	40 e0       	ldi	r20, 0x00	; 0
    2092:	0e 94 0d 06 	call	0xc1a	; 0xc1a <DIO_SetPin_Direction>
	return state_error;
}
    2096:	81 e0       	ldi	r24, 0x01	; 1
    2098:	08 95       	ret

Disassembly of section .text.BTN_pressed:

000018b0 <BTN_pressed>:
ERROR_STATE BTN_pressed(DIO_Port port, DIO_Pin pin, bool* btn_state){
    18b0:	ef 92       	push	r14
    18b2:	ff 92       	push	r15
    18b4:	0f 93       	push	r16
    18b6:	1f 93       	push	r17
    18b8:	cf 93       	push	r28
    18ba:	df 93       	push	r29
    18bc:	0f 92       	push	r0
    18be:	cd b7       	in	r28, 0x3d	; 61
    18c0:	de b7       	in	r29, 0x3e	; 62
    18c2:	18 2f       	mov	r17, r24
    18c4:	06 2f       	mov	r16, r22
    18c6:	7a 01       	movw	r14, r20
	ERROR_STATE state_error = SUCCESS;
	bool Btn_clicked;
	bool return_value = LOW;
	DIO_GetPin_Value(port, pin, &Btn_clicked);
    18c8:	ae 01       	movw	r20, r28
    18ca:	4f 5f       	subi	r20, 0xFF	; 255
    18cc:	5f 4f       	sbci	r21, 0xFF	; 255
    18ce:	0e 94 0e 0d 	call	0x1a1c	; 0x1a1c <DIO_GetPin_Value>
	return state_error;
}
ERROR_STATE BTN_pressed(DIO_Port port, DIO_Pin pin, bool* btn_state){
	ERROR_STATE state_error = SUCCESS;
	bool Btn_clicked;
	bool return_value = LOW;
    18d2:	80 e0       	ldi	r24, 0x00	; 0
	DIO_GetPin_Value(port, pin, &Btn_clicked);
	while((Btn_clicked) == LOW){
    18d4:	08 c0       	rjmp	.+16     	; 0x18e6 <BTN_pressed+0x36>
		return_value =HIGH;
		DIO_GetPin_Value(port, pin, &Btn_clicked);
    18d6:	ae 01       	movw	r20, r28
    18d8:	4f 5f       	subi	r20, 0xFF	; 255
    18da:	5f 4f       	sbci	r21, 0xFF	; 255
    18dc:	60 2f       	mov	r22, r16
    18de:	81 2f       	mov	r24, r17
    18e0:	0e 94 0e 0d 	call	0x1a1c	; 0x1a1c <DIO_GetPin_Value>
	ERROR_STATE state_error = SUCCESS;
	bool Btn_clicked;
	bool return_value = LOW;
	DIO_GetPin_Value(port, pin, &Btn_clicked);
	while((Btn_clicked) == LOW){
		return_value =HIGH;
    18e4:	81 e0       	ldi	r24, 0x01	; 1
ERROR_STATE BTN_pressed(DIO_Port port, DIO_Pin pin, bool* btn_state){
	ERROR_STATE state_error = SUCCESS;
	bool Btn_clicked;
	bool return_value = LOW;
	DIO_GetPin_Value(port, pin, &Btn_clicked);
	while((Btn_clicked) == LOW){
    18e6:	99 81       	ldd	r25, Y+1	; 0x01
    18e8:	99 23       	and	r25, r25
    18ea:	a9 f3       	breq	.-22     	; 0x18d6 <BTN_pressed+0x26>
    18ec:	2f ef       	ldi	r18, 0xFF	; 255
    18ee:	3d ee       	ldi	r19, 0xED	; 237
    18f0:	92 e0       	ldi	r25, 0x02	; 2
    18f2:	21 50       	subi	r18, 0x01	; 1
    18f4:	30 40       	sbci	r19, 0x00	; 0
    18f6:	90 40       	sbci	r25, 0x00	; 0
    18f8:	e1 f7       	brne	.-8      	; 0x18f2 <BTN_pressed+0x42>
    18fa:	00 c0       	rjmp	.+0      	; 0x18fc <BTN_pressed+0x4c>
    18fc:	00 00       	nop
    18fe:	08 c0       	rjmp	.+16     	; 0x1910 <BTN_pressed+0x60>
	}
	//return_value =LOW;
	_delay_ms(60);
	while((Btn_clicked) == LOW){
		return_value =HIGH;
		DIO_GetPin_Value(port, pin, &Btn_clicked);
    1900:	ae 01       	movw	r20, r28
    1902:	4f 5f       	subi	r20, 0xFF	; 255
    1904:	5f 4f       	sbci	r21, 0xFF	; 255
    1906:	60 2f       	mov	r22, r16
    1908:	81 2f       	mov	r24, r17
    190a:	0e 94 0e 0d 	call	0x1a1c	; 0x1a1c <DIO_GetPin_Value>
		DIO_GetPin_Value(port, pin, &Btn_clicked);
	}
	//return_value =LOW;
	_delay_ms(60);
	while((Btn_clicked) == LOW){
		return_value =HIGH;
    190e:	81 e0       	ldi	r24, 0x01	; 1
		return_value =HIGH;
		DIO_GetPin_Value(port, pin, &Btn_clicked);
	}
	//return_value =LOW;
	_delay_ms(60);
	while((Btn_clicked) == LOW){
    1910:	99 81       	ldd	r25, Y+1	; 0x01
    1912:	99 23       	and	r25, r25
    1914:	a9 f3       	breq	.-22     	; 0x1900 <BTN_pressed+0x50>
		return_value =HIGH;
		DIO_GetPin_Value(port, pin, &Btn_clicked);
	}
	*btn_state = return_value;
    1916:	f7 01       	movw	r30, r14
    1918:	80 83       	st	Z, r24
	return state_error;
    191a:	81 e0       	ldi	r24, 0x01	; 1
    191c:	0f 90       	pop	r0
    191e:	df 91       	pop	r29
    1920:	cf 91       	pop	r28
    1922:	1f 91       	pop	r17
    1924:	0f 91       	pop	r16
    1926:	ff 90       	pop	r15
    1928:	ef 90       	pop	r14
    192a:	08 95       	ret

Disassembly of section .text.BUZZER_Initialize:

00001fee <BUZZER_Initialize>:

#include "Buzzer_Private.h"

ERROR_STATE BUZZER_Initialize(void){
	ERROR_STATE state_error = SUCCESS;
	DIO_SetPin_Direction(BUZZER_PORT,BUZZER_PIN,BUZZER_OUTPUT);
    1fee:	41 e0       	ldi	r20, 0x01	; 1
    1ff0:	66 e0       	ldi	r22, 0x06	; 6
    1ff2:	82 e0       	ldi	r24, 0x02	; 2
    1ff4:	0e 94 0d 06 	call	0xc1a	; 0xc1a <DIO_SetPin_Direction>
	return state_error;
}
    1ff8:	81 e0       	ldi	r24, 0x01	; 1
    1ffa:	08 95       	ret

Disassembly of section .text.BUZZER_ON:

00001ffc <BUZZER_ON>:
ERROR_STATE BUZZER_ON(void){
	ERROR_STATE state_error = SUCCESS;
	DIO_SetPin_Value(BUZZER_PORT,BUZZER_PIN,BUZZER_HIGH);
    1ffc:	41 e0       	ldi	r20, 0x01	; 1
    1ffe:	66 e0       	ldi	r22, 0x06	; 6
    2000:	82 e0       	ldi	r24, 0x02	; 2
    2002:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
	return state_error;
}
    2006:	81 e0       	ldi	r24, 0x01	; 1
    2008:	08 95       	ret

Disassembly of section .text.BUZZER_OFF:

0000200a <BUZZER_OFF>:
ERROR_STATE BUZZER_OFF(void){
	ERROR_STATE state_error = SUCCESS;
	DIO_SetPin_Value(BUZZER_PORT,BUZZER_PIN,BUZZER_LOW);
    200a:	40 e0       	ldi	r20, 0x00	; 0
    200c:	66 e0       	ldi	r22, 0x06	; 6
    200e:	82 e0       	ldi	r24, 0x02	; 2
    2010:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
	return state_error;
}
    2014:	81 e0       	ldi	r24, 0x01	; 1
    2016:	08 95       	ret

Disassembly of section .text.GREEN_LED_Initializ:

00002024 <GREEN_LED_Initializ>:
 *  Author: aliae
 */ 
#include "GREEN_LED_Private.h"

void GREEN_LED_Initializ(void){
	DIO_SetPin_Direction(GREEN_LED_PORT,GREEN_LED_PIN,GREEN_LED_OUTPUT);
    2024:	41 e0       	ldi	r20, 0x01	; 1
    2026:	64 e0       	ldi	r22, 0x04	; 4
    2028:	80 e0       	ldi	r24, 0x00	; 0
    202a:	0e 94 0d 06 	call	0xc1a	; 0xc1a <DIO_SetPin_Direction>
    202e:	08 95       	ret

Disassembly of section .text.GREEN_LED_ON:

00002030 <GREEN_LED_ON>:
}
void GREEN_LED_ON(void){
	DIO_SetPin_Value(GREEN_LED_PORT,GREEN_LED_PIN,GREEN_LED_HIGH);
    2030:	41 e0       	ldi	r20, 0x01	; 1
    2032:	64 e0       	ldi	r22, 0x04	; 4
    2034:	80 e0       	ldi	r24, 0x00	; 0
    2036:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
    203a:	08 95       	ret

Disassembly of section .text.GREEN_LED_OFF:

0000203c <GREEN_LED_OFF>:
}
void GREEN_LED_OFF(void){
	DIO_SetPin_Value(GREEN_LED_PORT,GREEN_LED_PIN,GREEN_LED_LOW);
    203c:	40 e0       	ldi	r20, 0x00	; 0
    203e:	64 e0       	ldi	r22, 0x04	; 4
    2040:	80 e0       	ldi	r24, 0x00	; 0
    2042:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
    2046:	08 95       	ret

Disassembly of section .text.GREEN_LED_TGL:

0000209a <GREEN_LED_TGL>:
}
void GREEN_LED_TGL(void){
	DIO_TglPin_Value(GREEN_LED_PORT,GREEN_LED_PIN);
    209a:	64 e0       	ldi	r22, 0x04	; 4
    209c:	80 e0       	ldi	r24, 0x00	; 0
    209e:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <DIO_TglPin_Value>
    20a2:	08 95       	ret

Disassembly of section .text.LCD_Write_Command:

00000f0a <LCD_Write_Command>:
			digit++;
		}
		LCD_Write_Number(decimalp);
	}
	return state_error;
}
 f0a:	cf 93       	push	r28
 f0c:	c8 2f       	mov	r28, r24
 f0e:	48 2f       	mov	r20, r24
 f10:	44 1f       	adc	r20, r20
 f12:	44 27       	eor	r20, r20
 f14:	44 1f       	adc	r20, r20
 f16:	64 e0       	ldi	r22, 0x04	; 4
 f18:	81 e0       	ldi	r24, 0x01	; 1
 f1a:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
 f1e:	c6 fb       	bst	r28, 6
 f20:	44 27       	eor	r20, r20
 f22:	40 f9       	bld	r20, 0
 f24:	62 e0       	ldi	r22, 0x02	; 2
 f26:	81 e0       	ldi	r24, 0x01	; 1
 f28:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
 f2c:	c5 fb       	bst	r28, 5
 f2e:	44 27       	eor	r20, r20
 f30:	40 f9       	bld	r20, 0
 f32:	61 e0       	ldi	r22, 0x01	; 1
 f34:	81 e0       	ldi	r24, 0x01	; 1
 f36:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
 f3a:	c4 fb       	bst	r28, 4
 f3c:	44 27       	eor	r20, r20
 f3e:	40 f9       	bld	r20, 0
 f40:	60 e0       	ldi	r22, 0x00	; 0
 f42:	81 e0       	ldi	r24, 0x01	; 1
 f44:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
 f48:	40 e0       	ldi	r20, 0x00	; 0
 f4a:	63 e0       	ldi	r22, 0x03	; 3
 f4c:	80 e0       	ldi	r24, 0x00	; 0
 f4e:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
 f52:	41 e0       	ldi	r20, 0x01	; 1
 f54:	62 e0       	ldi	r22, 0x02	; 2
 f56:	80 e0       	ldi	r24, 0x00	; 0
 f58:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
 f5c:	85 e0       	ldi	r24, 0x05	; 5
 f5e:	8a 95       	dec	r24
 f60:	f1 f7       	brne	.-4      	; 0xf5e <LCD_Write_Command+0x54>
 f62:	00 00       	nop
 f64:	40 e0       	ldi	r20, 0x00	; 0
 f66:	62 e0       	ldi	r22, 0x02	; 2
 f68:	80 e0       	ldi	r24, 0x00	; 0
 f6a:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
 f6e:	8f e1       	ldi	r24, 0x1F	; 31
 f70:	93 e0       	ldi	r25, 0x03	; 3
 f72:	01 97       	sbiw	r24, 0x01	; 1
 f74:	f1 f7       	brne	.-4      	; 0xf72 <LCD_Write_Command+0x68>
 f76:	00 c0       	rjmp	.+0      	; 0xf78 <LCD_Write_Command+0x6e>
 f78:	00 00       	nop
 f7a:	c3 fb       	bst	r28, 3
 f7c:	44 27       	eor	r20, r20
 f7e:	40 f9       	bld	r20, 0
 f80:	64 e0       	ldi	r22, 0x04	; 4
 f82:	81 e0       	ldi	r24, 0x01	; 1
 f84:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
 f88:	c2 fb       	bst	r28, 2
 f8a:	44 27       	eor	r20, r20
 f8c:	40 f9       	bld	r20, 0
 f8e:	62 e0       	ldi	r22, 0x02	; 2
 f90:	81 e0       	ldi	r24, 0x01	; 1
 f92:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
 f96:	c1 fb       	bst	r28, 1
 f98:	44 27       	eor	r20, r20
 f9a:	40 f9       	bld	r20, 0
 f9c:	61 e0       	ldi	r22, 0x01	; 1
 f9e:	81 e0       	ldi	r24, 0x01	; 1
 fa0:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
 fa4:	4c 2f       	mov	r20, r28
 fa6:	41 70       	andi	r20, 0x01	; 1
 fa8:	60 e0       	ldi	r22, 0x00	; 0
 faa:	81 e0       	ldi	r24, 0x01	; 1
 fac:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
 fb0:	41 e0       	ldi	r20, 0x01	; 1
 fb2:	62 e0       	ldi	r22, 0x02	; 2
 fb4:	80 e0       	ldi	r24, 0x00	; 0
 fb6:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
 fba:	95 e0       	ldi	r25, 0x05	; 5
 fbc:	9a 95       	dec	r25
 fbe:	f1 f7       	brne	.-4      	; 0xfbc <LCD_Write_Command+0xb2>
 fc0:	00 00       	nop
 fc2:	40 e0       	ldi	r20, 0x00	; 0
 fc4:	62 e0       	ldi	r22, 0x02	; 2
 fc6:	80 e0       	ldi	r24, 0x00	; 0
 fc8:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
 fcc:	8f e3       	ldi	r24, 0x3F	; 63
 fce:	9f e1       	ldi	r25, 0x1F	; 31
 fd0:	01 97       	sbiw	r24, 0x01	; 1
 fd2:	f1 f7       	brne	.-4      	; 0xfd0 <LCD_Write_Command+0xc6>
 fd4:	00 c0       	rjmp	.+0      	; 0xfd6 <LCD_Write_Command+0xcc>
 fd6:	00 00       	nop
 fd8:	81 e0       	ldi	r24, 0x01	; 1
 fda:	cf 91       	pop	r28
 fdc:	08 95       	ret

Disassembly of section .text.LCD_Initialize:

0000192c <LCD_Initialize>:
    192c:	41 e0       	ldi	r20, 0x01	; 1
    192e:	60 e0       	ldi	r22, 0x00	; 0
    1930:	81 e0       	ldi	r24, 0x01	; 1
    1932:	0e 94 0d 06 	call	0xc1a	; 0xc1a <DIO_SetPin_Direction>
    1936:	41 e0       	ldi	r20, 0x01	; 1
    1938:	61 e0       	ldi	r22, 0x01	; 1
    193a:	81 e0       	ldi	r24, 0x01	; 1
    193c:	0e 94 0d 06 	call	0xc1a	; 0xc1a <DIO_SetPin_Direction>
    1940:	41 e0       	ldi	r20, 0x01	; 1
    1942:	62 e0       	ldi	r22, 0x02	; 2
    1944:	81 e0       	ldi	r24, 0x01	; 1
    1946:	0e 94 0d 06 	call	0xc1a	; 0xc1a <DIO_SetPin_Direction>
    194a:	41 e0       	ldi	r20, 0x01	; 1
    194c:	64 e0       	ldi	r22, 0x04	; 4
    194e:	81 e0       	ldi	r24, 0x01	; 1
    1950:	0e 94 0d 06 	call	0xc1a	; 0xc1a <DIO_SetPin_Direction>
    1954:	41 e0       	ldi	r20, 0x01	; 1
    1956:	63 e0       	ldi	r22, 0x03	; 3
    1958:	80 e0       	ldi	r24, 0x00	; 0
    195a:	0e 94 0d 06 	call	0xc1a	; 0xc1a <DIO_SetPin_Direction>
    195e:	41 e0       	ldi	r20, 0x01	; 1
    1960:	62 e0       	ldi	r22, 0x02	; 2
    1962:	80 e0       	ldi	r24, 0x00	; 0
    1964:	0e 94 0d 06 	call	0xc1a	; 0xc1a <DIO_SetPin_Direction>
    1968:	2f ef       	ldi	r18, 0xFF	; 255
    196a:	89 ef       	ldi	r24, 0xF9	; 249
    196c:	90 e0       	ldi	r25, 0x00	; 0
    196e:	21 50       	subi	r18, 0x01	; 1
    1970:	80 40       	sbci	r24, 0x00	; 0
    1972:	90 40       	sbci	r25, 0x00	; 0
    1974:	e1 f7       	brne	.-8      	; 0x196e <LCD_Initialize+0x42>
    1976:	00 c0       	rjmp	.+0      	; 0x1978 <LCD_Initialize+0x4c>
    1978:	00 00       	nop
    197a:	83 e3       	ldi	r24, 0x33	; 51
    197c:	0e 94 85 07 	call	0xf0a	; 0xf0a <LCD_Write_Command>
    1980:	82 e3       	ldi	r24, 0x32	; 50
    1982:	0e 94 85 07 	call	0xf0a	; 0xf0a <LCD_Write_Command>
    1986:	88 e2       	ldi	r24, 0x28	; 40
    1988:	0e 94 85 07 	call	0xf0a	; 0xf0a <LCD_Write_Command>
    198c:	81 e0       	ldi	r24, 0x01	; 1
    198e:	0e 94 85 07 	call	0xf0a	; 0xf0a <LCD_Write_Command>
    1992:	8f e0       	ldi	r24, 0x0F	; 15
    1994:	0e 94 85 07 	call	0xf0a	; 0xf0a <LCD_Write_Command>
    1998:	8f e3       	ldi	r24, 0x3F	; 63
    199a:	9c e9       	ldi	r25, 0x9C	; 156
    199c:	01 97       	sbiw	r24, 0x01	; 1
    199e:	f1 f7       	brne	.-4      	; 0x199c <LCD_Initialize+0x70>
    19a0:	00 c0       	rjmp	.+0      	; 0x19a2 <LCD_Initialize+0x76>
    19a2:	00 00       	nop
    19a4:	81 e0       	ldi	r24, 0x01	; 1
    19a6:	08 95       	ret

Disassembly of section .text.LCD_Clear:

000020a4 <LCD_Clear>:
	return state_error;
}
ERROR_STATE LCD_Clear(void)
{
	ERROR_STATE state_error = SUCCESS;
	LCD_Write_Command(0x01);
    20a4:	81 e0       	ldi	r24, 0x01	; 1
    20a6:	0e 94 85 07 	call	0xf0a	; 0xf0a <LCD_Write_Command>
	return state_error;
}
    20aa:	81 e0       	ldi	r24, 0x01	; 1
    20ac:	08 95       	ret

Disassembly of section .text.LCD_Write_Character:

00000fde <LCD_Write_Character>:
			digit++;
		}
		LCD_Write_Number(decimalp);
	}
	return state_error;
}
     fde:	cf 93       	push	r28
     fe0:	c8 2f       	mov	r28, r24
     fe2:	48 2f       	mov	r20, r24
     fe4:	44 1f       	adc	r20, r20
     fe6:	44 27       	eor	r20, r20
     fe8:	44 1f       	adc	r20, r20
     fea:	64 e0       	ldi	r22, 0x04	; 4
     fec:	81 e0       	ldi	r24, 0x01	; 1
     fee:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
     ff2:	c6 fb       	bst	r28, 6
     ff4:	44 27       	eor	r20, r20
     ff6:	40 f9       	bld	r20, 0
     ff8:	62 e0       	ldi	r22, 0x02	; 2
     ffa:	81 e0       	ldi	r24, 0x01	; 1
     ffc:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
    1000:	c5 fb       	bst	r28, 5
    1002:	44 27       	eor	r20, r20
    1004:	40 f9       	bld	r20, 0
    1006:	61 e0       	ldi	r22, 0x01	; 1
    1008:	81 e0       	ldi	r24, 0x01	; 1
    100a:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
    100e:	c4 fb       	bst	r28, 4
    1010:	44 27       	eor	r20, r20
    1012:	40 f9       	bld	r20, 0
    1014:	60 e0       	ldi	r22, 0x00	; 0
    1016:	81 e0       	ldi	r24, 0x01	; 1
    1018:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
    101c:	41 e0       	ldi	r20, 0x01	; 1
    101e:	63 e0       	ldi	r22, 0x03	; 3
    1020:	80 e0       	ldi	r24, 0x00	; 0
    1022:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
    1026:	41 e0       	ldi	r20, 0x01	; 1
    1028:	62 e0       	ldi	r22, 0x02	; 2
    102a:	80 e0       	ldi	r24, 0x00	; 0
    102c:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
    1030:	85 e0       	ldi	r24, 0x05	; 5
    1032:	8a 95       	dec	r24
    1034:	f1 f7       	brne	.-4      	; 0x1032 <LCD_Write_Character+0x54>
    1036:	00 00       	nop
    1038:	40 e0       	ldi	r20, 0x00	; 0
    103a:	62 e0       	ldi	r22, 0x02	; 2
    103c:	80 e0       	ldi	r24, 0x00	; 0
    103e:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
    1042:	8f e1       	ldi	r24, 0x1F	; 31
    1044:	93 e0       	ldi	r25, 0x03	; 3
    1046:	01 97       	sbiw	r24, 0x01	; 1
    1048:	f1 f7       	brne	.-4      	; 0x1046 <LCD_Write_Character+0x68>
    104a:	00 c0       	rjmp	.+0      	; 0x104c <LCD_Write_Character+0x6e>
    104c:	00 00       	nop
    104e:	c3 fb       	bst	r28, 3
    1050:	44 27       	eor	r20, r20
    1052:	40 f9       	bld	r20, 0
    1054:	64 e0       	ldi	r22, 0x04	; 4
    1056:	81 e0       	ldi	r24, 0x01	; 1
    1058:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
    105c:	c2 fb       	bst	r28, 2
    105e:	44 27       	eor	r20, r20
    1060:	40 f9       	bld	r20, 0
    1062:	62 e0       	ldi	r22, 0x02	; 2
    1064:	81 e0       	ldi	r24, 0x01	; 1
    1066:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
    106a:	c1 fb       	bst	r28, 1
    106c:	44 27       	eor	r20, r20
    106e:	40 f9       	bld	r20, 0
    1070:	61 e0       	ldi	r22, 0x01	; 1
    1072:	81 e0       	ldi	r24, 0x01	; 1
    1074:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
    1078:	4c 2f       	mov	r20, r28
    107a:	41 70       	andi	r20, 0x01	; 1
    107c:	60 e0       	ldi	r22, 0x00	; 0
    107e:	81 e0       	ldi	r24, 0x01	; 1
    1080:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
    1084:	41 e0       	ldi	r20, 0x01	; 1
    1086:	62 e0       	ldi	r22, 0x02	; 2
    1088:	80 e0       	ldi	r24, 0x00	; 0
    108a:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
    108e:	95 e0       	ldi	r25, 0x05	; 5
    1090:	9a 95       	dec	r25
    1092:	f1 f7       	brne	.-4      	; 0x1090 <LCD_Write_Character+0xb2>
    1094:	00 00       	nop
    1096:	40 e0       	ldi	r20, 0x00	; 0
    1098:	62 e0       	ldi	r22, 0x02	; 2
    109a:	80 e0       	ldi	r24, 0x00	; 0
    109c:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
    10a0:	8f e3       	ldi	r24, 0x3F	; 63
    10a2:	9f e1       	ldi	r25, 0x1F	; 31
    10a4:	01 97       	sbiw	r24, 0x01	; 1
    10a6:	f1 f7       	brne	.-4      	; 0x10a4 <LCD_Write_Character+0xc6>
    10a8:	00 c0       	rjmp	.+0      	; 0x10aa <LCD_Write_Character+0xcc>
    10aa:	00 00       	nop
    10ac:	81 e0       	ldi	r24, 0x01	; 1
    10ae:	cf 91       	pop	r28
    10b0:	08 95       	ret

Disassembly of section .text.LCD_Write_String:

00001d24 <LCD_Write_String>:
	_delay_ms(2);
	return state_error;
}

ERROR_STATE LCD_Write_String(const char *str)
{
    1d24:	cf 92       	push	r12
    1d26:	df 92       	push	r13
    1d28:	ef 92       	push	r14
    1d2a:	6b 01       	movw	r12, r22
    1d2c:	e8 2e       	mov	r14, r24
	ERROR_STATE state_error = SUCCESS;
	while (*str != '\0')
    1d2e:	06 c0       	rjmp	.+12     	; 0x1d3c <LCD_Write_String+0x18>
	{
		LCD_Write_Character(*str);
    1d30:	0e 94 ef 07 	call	0xfde	; 0xfde <LCD_Write_Character>
		str++;
    1d34:	8f ef       	ldi	r24, 0xFF	; 255
    1d36:	c8 1a       	sub	r12, r24
    1d38:	d8 0a       	sbc	r13, r24
    1d3a:	e8 0a       	sbc	r14, r24
}

ERROR_STATE LCD_Write_String(const char *str)
{
	ERROR_STATE state_error = SUCCESS;
	while (*str != '\0')
    1d3c:	f6 01       	movw	r30, r12
    1d3e:	84 91       	lpm	r24, Z
    1d40:	e7 fc       	sbrc	r14, 7
    1d42:	80 81       	ld	r24, Z
    1d44:	81 11       	cpse	r24, r1
    1d46:	f4 cf       	rjmp	.-24     	; 0x1d30 <LCD_Write_String+0xc>
	{
		LCD_Write_Character(*str);
		str++;
	}
	return state_error;
}
    1d48:	81 e0       	ldi	r24, 0x01	; 1
    1d4a:	ef 90       	pop	r14
    1d4c:	df 90       	pop	r13
    1d4e:	cf 90       	pop	r12
    1d50:	08 95       	ret

Disassembly of section .text.LCD_Write_Number:

000008a0 <LCD_Write_Number>:
			digit++;
		}
		LCD_Write_Number(decimalp);
	}
	return state_error;
}
 8a0:	2f 92       	push	r2
 8a2:	3f 92       	push	r3
 8a4:	4f 92       	push	r4
 8a6:	5f 92       	push	r5
 8a8:	6f 92       	push	r6
 8aa:	7f 92       	push	r7
 8ac:	8f 92       	push	r8
 8ae:	9f 92       	push	r9
 8b0:	af 92       	push	r10
 8b2:	bf 92       	push	r11
 8b4:	cf 92       	push	r12
 8b6:	df 92       	push	r13
 8b8:	ef 92       	push	r14
 8ba:	ff 92       	push	r15
 8bc:	0f 93       	push	r16
 8be:	1f 93       	push	r17
 8c0:	cf 93       	push	r28
 8c2:	df 93       	push	r29
 8c4:	cd b7       	in	r28, 0x3d	; 61
 8c6:	de b7       	in	r29, 0x3e	; 62
 8c8:	6b 97       	sbiw	r28, 0x1b	; 27
 8ca:	0f b6       	in	r0, 0x3f	; 63
 8cc:	f8 94       	cli
 8ce:	de bf       	out	0x3e, r29	; 62
 8d0:	0f be       	out	0x3f, r0	; 63
 8d2:	cd bf       	out	0x3d, r28	; 61
 8d4:	2d 8b       	std	Y+21, r18	; 0x15
 8d6:	3e 8b       	std	Y+22, r19	; 0x16
 8d8:	94 2e       	mov	r9, r20
 8da:	85 2e       	mov	r8, r21
 8dc:	6f 8b       	std	Y+23, r22	; 0x17
 8de:	78 8f       	std	Y+24, r23	; 0x18
 8e0:	38 2e       	mov	r3, r24
 8e2:	29 2e       	mov	r2, r25
 8e4:	a0 e0       	ldi	r26, 0x00	; 0
 8e6:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <__cmpdi2_s8>
 8ea:	ac f4       	brge	.+42     	; 0x916 <LCD_Write_Number+0x76>
 8ec:	8d e2       	ldi	r24, 0x2D	; 45
 8ee:	0e 94 ef 07 	call	0xfde	; 0xfde <LCD_Write_Character>
 8f2:	2d 89       	ldd	r18, Y+21	; 0x15
 8f4:	3e 89       	ldd	r19, Y+22	; 0x16
 8f6:	49 2d       	mov	r20, r9
 8f8:	58 2d       	mov	r21, r8
 8fa:	6f 89       	ldd	r22, Y+23	; 0x17
 8fc:	78 8d       	ldd	r23, Y+24	; 0x18
 8fe:	83 2d       	mov	r24, r3
 900:	92 2d       	mov	r25, r2
 902:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <__negdi2>
 906:	2d 8b       	std	Y+21, r18	; 0x15
 908:	3e 8b       	std	Y+22, r19	; 0x16
 90a:	94 2e       	mov	r9, r20
 90c:	85 2e       	mov	r8, r21
 90e:	6f 8b       	std	Y+23, r22	; 0x17
 910:	78 8f       	std	Y+24, r23	; 0x18
 912:	38 2e       	mov	r3, r24
 914:	29 2e       	mov	r2, r25
 916:	ed 89       	ldd	r30, Y+21	; 0x15
 918:	5e 88       	ldd	r5, Y+22	; 0x16
 91a:	49 2c       	mov	r4, r9
 91c:	89 8e       	std	Y+25, r8	; 0x19
 91e:	8f 89       	ldd	r24, Y+23	; 0x17
 920:	8a 8f       	std	Y+26, r24	; 0x1a
 922:	88 8d       	ldd	r24, Y+24	; 0x18
 924:	8b 8f       	std	Y+27, r24	; 0x1b
 926:	b3 2d       	mov	r27, r3
 928:	f2 2d       	mov	r31, r2
 92a:	61 2c       	mov	r6, r1
 92c:	71 2c       	mov	r7, r1
 92e:	20 c0       	rjmp	.+64     	; 0x970 <LCD_Write_Number+0xd0>
 930:	8f ef       	ldi	r24, 0xFF	; 255
 932:	68 1a       	sub	r6, r24
 934:	78 0a       	sbc	r7, r24
 936:	0f 2e       	mov	r0, r31
 938:	fa e0       	ldi	r31, 0x0A	; 10
 93a:	af 2e       	mov	r10, r31
 93c:	f0 2d       	mov	r31, r0
 93e:	b1 2c       	mov	r11, r1
 940:	c1 2c       	mov	r12, r1
 942:	d1 2c       	mov	r13, r1
 944:	e1 2c       	mov	r14, r1
 946:	f1 2c       	mov	r15, r1
 948:	00 e0       	ldi	r16, 0x00	; 0
 94a:	10 e0       	ldi	r17, 0x00	; 0
 94c:	2e 2f       	mov	r18, r30
 94e:	35 2d       	mov	r19, r5
 950:	44 2d       	mov	r20, r4
 952:	59 8d       	ldd	r21, Y+25	; 0x19
 954:	6a 8d       	ldd	r22, Y+26	; 0x1a
 956:	7b 8d       	ldd	r23, Y+27	; 0x1b
 958:	8b 2f       	mov	r24, r27
 95a:	9f 2f       	mov	r25, r31
 95c:	0e 94 7d 0d 	call	0x1afa	; 0x1afa <__divdi3>
 960:	e2 2f       	mov	r30, r18
 962:	53 2e       	mov	r5, r19
 964:	44 2e       	mov	r4, r20
 966:	59 8f       	std	Y+25, r21	; 0x19
 968:	6a 8f       	std	Y+26, r22	; 0x1a
 96a:	7b 8f       	std	Y+27, r23	; 0x1b
 96c:	b8 2f       	mov	r27, r24
 96e:	f9 2f       	mov	r31, r25
 970:	2e 2f       	mov	r18, r30
 972:	35 2d       	mov	r19, r5
 974:	44 2d       	mov	r20, r4
 976:	59 8d       	ldd	r21, Y+25	; 0x19
 978:	6a 8d       	ldd	r22, Y+26	; 0x1a
 97a:	7b 8d       	ldd	r23, Y+27	; 0x1b
 97c:	8b 2f       	mov	r24, r27
 97e:	9f 2f       	mov	r25, r31
 980:	a0 e0       	ldi	r26, 0x00	; 0
 982:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <__cmpdi2_s8>
 986:	a1 f6       	brne	.-88     	; 0x930 <LCD_Write_Number+0x90>
 988:	2d 89       	ldd	r18, Y+21	; 0x15
 98a:	3e 89       	ldd	r19, Y+22	; 0x16
 98c:	49 2d       	mov	r20, r9
 98e:	58 2d       	mov	r21, r8
 990:	6f 89       	ldd	r22, Y+23	; 0x17
 992:	78 8d       	ldd	r23, Y+24	; 0x18
 994:	83 2d       	mov	r24, r3
 996:	92 2d       	mov	r25, r2
 998:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <__cmpdi2_s8>
 99c:	21 f4       	brne	.+8      	; 0x9a6 <LCD_Write_Number+0x106>
 99e:	80 e3       	ldi	r24, 0x30	; 48
 9a0:	0e 94 ef 07 	call	0xfde	; 0xfde <LCD_Write_Character>
 9a4:	4b c0       	rjmp	.+150    	; 0xa3c <LCD_Write_Number+0x19c>
 9a6:	23 01       	movw	r4, r6
 9a8:	81 e0       	ldi	r24, 0x01	; 1
 9aa:	48 1a       	sub	r4, r24
 9ac:	51 08       	sbc	r5, r1
 9ae:	32 c0       	rjmp	.+100    	; 0xa14 <LCD_Write_Number+0x174>
 9b0:	0f 2e       	mov	r0, r31
 9b2:	fa e0       	ldi	r31, 0x0A	; 10
 9b4:	af 2e       	mov	r10, r31
 9b6:	f0 2d       	mov	r31, r0
 9b8:	b1 2c       	mov	r11, r1
 9ba:	c1 2c       	mov	r12, r1
 9bc:	d1 2c       	mov	r13, r1
 9be:	e1 2c       	mov	r14, r1
 9c0:	f1 2c       	mov	r15, r1
 9c2:	00 e0       	ldi	r16, 0x00	; 0
 9c4:	10 e0       	ldi	r17, 0x00	; 0
 9c6:	2d 89       	ldd	r18, Y+21	; 0x15
 9c8:	3e 89       	ldd	r19, Y+22	; 0x16
 9ca:	49 2d       	mov	r20, r9
 9cc:	58 2d       	mov	r21, r8
 9ce:	6f 89       	ldd	r22, Y+23	; 0x17
 9d0:	78 8d       	ldd	r23, Y+24	; 0x18
 9d2:	83 2d       	mov	r24, r3
 9d4:	92 2d       	mov	r25, r2
 9d6:	0e 94 7b 0d 	call	0x1af6	; 0x1af6 <__moddi3>
 9da:	e1 e0       	ldi	r30, 0x01	; 1
 9dc:	f0 e0       	ldi	r31, 0x00	; 0
 9de:	ec 0f       	add	r30, r28
 9e0:	fd 1f       	adc	r31, r29
 9e2:	e4 0d       	add	r30, r4
 9e4:	f5 1d       	adc	r31, r5
 9e6:	20 5d       	subi	r18, 0xD0	; 208
 9e8:	20 83       	st	Z, r18
 9ea:	2d 89       	ldd	r18, Y+21	; 0x15
 9ec:	3e 89       	ldd	r19, Y+22	; 0x16
 9ee:	49 2d       	mov	r20, r9
 9f0:	58 2d       	mov	r21, r8
 9f2:	6f 89       	ldd	r22, Y+23	; 0x17
 9f4:	78 8d       	ldd	r23, Y+24	; 0x18
 9f6:	83 2d       	mov	r24, r3
 9f8:	92 2d       	mov	r25, r2
 9fa:	0e 94 7d 0d 	call	0x1afa	; 0x1afa <__divdi3>
 9fe:	2d 8b       	std	Y+21, r18	; 0x15
 a00:	3e 8b       	std	Y+22, r19	; 0x16
 a02:	94 2e       	mov	r9, r20
 a04:	85 2e       	mov	r8, r21
 a06:	6f 8b       	std	Y+23, r22	; 0x17
 a08:	78 8f       	std	Y+24, r23	; 0x18
 a0a:	38 2e       	mov	r3, r24
 a0c:	29 2e       	mov	r2, r25
 a0e:	81 e0       	ldi	r24, 0x01	; 1
 a10:	48 1a       	sub	r4, r24
 a12:	51 08       	sbc	r5, r1
 a14:	55 20       	and	r5, r5
 a16:	64 f6       	brge	.-104    	; 0x9b0 <LCD_Write_Number+0x110>
 a18:	81 2c       	mov	r8, r1
 a1a:	91 2c       	mov	r9, r1
 a1c:	0c c0       	rjmp	.+24     	; 0xa36 <LCD_Write_Number+0x196>
 a1e:	e1 e0       	ldi	r30, 0x01	; 1
 a20:	f0 e0       	ldi	r31, 0x00	; 0
 a22:	ec 0f       	add	r30, r28
 a24:	fd 1f       	adc	r31, r29
 a26:	e8 0d       	add	r30, r8
 a28:	f9 1d       	adc	r31, r9
 a2a:	80 81       	ld	r24, Z
 a2c:	0e 94 ef 07 	call	0xfde	; 0xfde <LCD_Write_Character>
 a30:	8f ef       	ldi	r24, 0xFF	; 255
 a32:	88 1a       	sub	r8, r24
 a34:	98 0a       	sbc	r9, r24
 a36:	86 14       	cp	r8, r6
 a38:	97 04       	cpc	r9, r7
 a3a:	88 f3       	brcs	.-30     	; 0xa1e <LCD_Write_Number+0x17e>
 a3c:	81 e0       	ldi	r24, 0x01	; 1
 a3e:	6b 96       	adiw	r28, 0x1b	; 27
 a40:	0f b6       	in	r0, 0x3f	; 63
 a42:	f8 94       	cli
 a44:	de bf       	out	0x3e, r29	; 62
 a46:	0f be       	out	0x3f, r0	; 63
 a48:	cd bf       	out	0x3d, r28	; 61
 a4a:	df 91       	pop	r29
 a4c:	cf 91       	pop	r28
 a4e:	1f 91       	pop	r17
 a50:	0f 91       	pop	r16
 a52:	ff 90       	pop	r15
 a54:	ef 90       	pop	r14
 a56:	df 90       	pop	r13
 a58:	cf 90       	pop	r12
 a5a:	bf 90       	pop	r11
 a5c:	af 90       	pop	r10
 a5e:	9f 90       	pop	r9
 a60:	8f 90       	pop	r8
 a62:	7f 90       	pop	r7
 a64:	6f 90       	pop	r6
 a66:	5f 90       	pop	r5
 a68:	4f 90       	pop	r4
 a6a:	3f 90       	pop	r3
 a6c:	2f 90       	pop	r2
 a6e:	08 95       	ret

Disassembly of section .text.LCD_LINE_position:

00001bfc <LCD_LINE_position>:
Inputs:	row and column
Output:	state
Description: Moves the cursor position to the provided
row and column.
*/
ERROR_STATE LCD_LINE_position(LCD_LINES row , SINT8_t column){
    1bfc:	cf 93       	push	r28
	ERROR_STATE state_error = SUCCESS;
	UINT8_t address = 0;
	
	if(column < 20 && column >= 0){
    1bfe:	64 31       	cpi	r22, 0x14	; 20
    1c00:	e8 f4       	brcc	.+58     	; 0x1c3c <LCD_LINE_position+0x40>
		switch(row){
    1c02:	81 30       	cpi	r24, 0x01	; 1
    1c04:	91 f0       	breq	.+36     	; 0x1c2a <LCD_LINE_position+0x2e>
    1c06:	28 f0       	brcs	.+10     	; 0x1c12 <LCD_LINE_position+0x16>
    1c08:	82 30       	cpi	r24, 0x02	; 2
    1c0a:	31 f0       	breq	.+12     	; 0x1c18 <LCD_LINE_position+0x1c>
    1c0c:	83 30       	cpi	r24, 0x03	; 3
    1c0e:	39 f0       	breq	.+14     	; 0x1c1e <LCD_LINE_position+0x22>
    1c10:	09 c0       	rjmp	.+18     	; 0x1c24 <LCD_LINE_position+0x28>
			case LCD_LINE1:
			address = 0x00;
    1c12:	80 e0       	ldi	r24, 0x00	; 0
Output:	state
Description: Moves the cursor position to the provided
row and column.
*/
ERROR_STATE LCD_LINE_position(LCD_LINES row , SINT8_t column){
	ERROR_STATE state_error = SUCCESS;
    1c14:	c1 e0       	ldi	r28, 0x01	; 1
    1c16:	0b c0       	rjmp	.+22     	; 0x1c2e <LCD_LINE_position+0x32>
			break;
			case LCD_LINE2:
			address = 0x40;
			break;
			case LCD_LINE3:
			address = 0x14;
    1c18:	84 e1       	ldi	r24, 0x14	; 20
Output:	state
Description: Moves the cursor position to the provided
row and column.
*/
ERROR_STATE LCD_LINE_position(LCD_LINES row , SINT8_t column){
	ERROR_STATE state_error = SUCCESS;
    1c1a:	c1 e0       	ldi	r28, 0x01	; 1
			case LCD_LINE2:
			address = 0x40;
			break;
			case LCD_LINE3:
			address = 0x14;
			break;
    1c1c:	08 c0       	rjmp	.+16     	; 0x1c2e <LCD_LINE_position+0x32>
			case LCD_LINE4:
			address = 0x54;
    1c1e:	84 e5       	ldi	r24, 0x54	; 84
Output:	state
Description: Moves the cursor position to the provided
row and column.
*/
ERROR_STATE LCD_LINE_position(LCD_LINES row , SINT8_t column){
	ERROR_STATE state_error = SUCCESS;
    1c20:	c1 e0       	ldi	r28, 0x01	; 1
			case LCD_LINE3:
			address = 0x14;
			break;
			case LCD_LINE4:
			address = 0x54;
			break;
    1c22:	05 c0       	rjmp	.+10     	; 0x1c2e <LCD_LINE_position+0x32>
Description: Moves the cursor position to the provided
row and column.
*/
ERROR_STATE LCD_LINE_position(LCD_LINES row , SINT8_t column){
	ERROR_STATE state_error = SUCCESS;
	UINT8_t address = 0;
    1c24:	80 e0       	ldi	r24, 0x00	; 0
			break;
			case LCD_LINE4:
			address = 0x54;
			break;
			default:
			state_error = FAIL;
    1c26:	c0 e0       	ldi	r28, 0x00	; 0
			break;
    1c28:	02 c0       	rjmp	.+4      	; 0x1c2e <LCD_LINE_position+0x32>
		switch(row){
			case LCD_LINE1:
			address = 0x00;
			break;
			case LCD_LINE2:
			address = 0x40;
    1c2a:	80 e4       	ldi	r24, 0x40	; 64
Output:	state
Description: Moves the cursor position to the provided
row and column.
*/
ERROR_STATE LCD_LINE_position(LCD_LINES row , SINT8_t column){
	ERROR_STATE state_error = SUCCESS;
    1c2c:	c1 e0       	ldi	r28, 0x01	; 1
			break;
			default:
			state_error = FAIL;
			break;
		}
		if(SUCCESS == state_error){
    1c2e:	c1 30       	cpi	r28, 0x01	; 1
    1c30:	31 f4       	brne	.+12     	; 0x1c3e <LCD_LINE_position+0x42>
			address += column;
    1c32:	86 0f       	add	r24, r22
			LCD_Write_Command(0x80+address);
    1c34:	80 58       	subi	r24, 0x80	; 128
    1c36:	0e 94 85 07 	call	0xf0a	; 0xf0a <LCD_Write_Command>
    1c3a:	01 c0       	rjmp	.+2      	; 0x1c3e <LCD_LINE_position+0x42>
			}else{
			;
		}
		}else{
		state_error = FAIL;
    1c3c:	c0 e0       	ldi	r28, 0x00	; 0
	}

	return state_error;
    1c3e:	8c 2f       	mov	r24, r28
    1c40:	cf 91       	pop	r28
    1c42:	08 95       	ret

Disassembly of section .text.LDR_init:

00001fb4 <LDR_init>:
#include "Potentiometer_Private.h"

ERROR_STATE LDR_init(){
	ERROR_STATE state_error = SUCCESS;
	if(ADC_Initialize()){
    1fb4:	0e 94 d5 0e 	call	0x1daa	; 0x1daa <ADC_Initialize>
    1fb8:	88 23       	and	r24, r24
    1fba:	11 f0       	breq	.+4      	; 0x1fc0 <LDR_init+0xc>
		state_error = SUCCESS;
    1fbc:	81 e0       	ldi	r24, 0x01	; 1
    1fbe:	08 95       	ret
	}else{
		state_error = FAIL;
    1fc0:	80 e0       	ldi	r24, 0x00	; 0
	}
	return state_error;
}
    1fc2:	08 95       	ret

Disassembly of section .text.LDR_Read:

00001f66 <LDR_Read>:

ERROR_STATE LDR_Read(UINT16_t* POT_value){
	ERROR_STATE state_error = SUCCESS;
	if(ADC_Read(LDR_PIN,POT_value)){
    1f66:	bc 01       	movw	r22, r24
    1f68:	80 e0       	ldi	r24, 0x00	; 0
    1f6a:	0e 94 7a 0e 	call	0x1cf4	; 0x1cf4 <ADC_Read>
    1f6e:	88 23       	and	r24, r24
    1f70:	11 f0       	breq	.+4      	; 0x1f76 <LDR_Read+0x10>
		state_error = SUCCESS;
    1f72:	81 e0       	ldi	r24, 0x01	; 1
    1f74:	08 95       	ret
	}else{
		state_error = FAIL;
    1f76:	80 e0       	ldi	r24, 0x00	; 0
	}
	return state_error;
}
    1f78:	08 95       	ret

Disassembly of section .text.RED_LED_Initializ:

00002048 <RED_LED_Initializ>:
 */ 

#include "RED_LED_Private.h"

void RED_LED_Initializ(void){
	DIO_SetPin_Direction(RED_LED_PORT,RED_LED_PIN,RED_LED_OUTPUT);
    2048:	41 e0       	ldi	r20, 0x01	; 1
    204a:	67 e0       	ldi	r22, 0x07	; 7
    204c:	81 e0       	ldi	r24, 0x01	; 1
    204e:	0e 94 0d 06 	call	0xc1a	; 0xc1a <DIO_SetPin_Direction>
    2052:	08 95       	ret

Disassembly of section .text.RED_LED_ON:

00002054 <RED_LED_ON>:
}
void RED_LED_ON(void){
	DIO_SetPin_Value(RED_LED_PORT,RED_LED_PIN,RED_LED_HIGH);
    2054:	41 e0       	ldi	r20, 0x01	; 1
    2056:	67 e0       	ldi	r22, 0x07	; 7
    2058:	81 e0       	ldi	r24, 0x01	; 1
    205a:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
    205e:	08 95       	ret

Disassembly of section .text.RED_LED_OFF:

00002060 <RED_LED_OFF>:
}
void RED_LED_OFF(void){
	DIO_SetPin_Value(RED_LED_PORT,RED_LED_PIN,RED_LED_LOW);
    2060:	40 e0       	ldi	r20, 0x00	; 0
    2062:	67 e0       	ldi	r22, 0x07	; 7
    2064:	81 e0       	ldi	r24, 0x01	; 1
    2066:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
    206a:	08 95       	ret

Disassembly of section .text.RED_LED_TGL:

000020ae <RED_LED_TGL>:
}
void RED_LED_TGL(void){
	DIO_TglPin_Value(RED_LED_PORT,RED_LED_PIN);
    20ae:	67 e0       	ldi	r22, 0x07	; 7
    20b0:	81 e0       	ldi	r24, 0x01	; 1
    20b2:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <DIO_TglPin_Value>
    20b6:	08 95       	ret

Disassembly of section .text.YELLOW_LED_Initializ:

0000206c <YELLOW_LED_Initializ>:
 *  Author: aliae
 */ 
#include "YELLOW_LED_Private.h"

void YELLOW_LED_Initializ(void){
	DIO_SetPin_Direction(YELLOW_LED_PORT,YELLOW_LED_PIN,YELLOW_LED_OUTPUT);
    206c:	41 e0       	ldi	r20, 0x01	; 1
    206e:	66 e0       	ldi	r22, 0x06	; 6
    2070:	80 e0       	ldi	r24, 0x00	; 0
    2072:	0e 94 0d 06 	call	0xc1a	; 0xc1a <DIO_SetPin_Direction>
    2076:	08 95       	ret

Disassembly of section .text.YELLOW_LED_ON:

00002078 <YELLOW_LED_ON>:
}
void YELLOW_LED_ON(void){
	DIO_SetPin_Value(YELLOW_LED_PORT,YELLOW_LED_PIN,YELLOW_LED_HIGH);
    2078:	41 e0       	ldi	r20, 0x01	; 1
    207a:	66 e0       	ldi	r22, 0x06	; 6
    207c:	80 e0       	ldi	r24, 0x00	; 0
    207e:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
    2082:	08 95       	ret

Disassembly of section .text.YELLOW_LED_OFF:

00002084 <YELLOW_LED_OFF>:
}
void YELLOW_LED_OFF(void){
	DIO_SetPin_Value(YELLOW_LED_PORT,YELLOW_LED_PIN,YELLOW_LED_LOW);
    2084:	40 e0       	ldi	r20, 0x00	; 0
    2086:	66 e0       	ldi	r22, 0x06	; 6
    2088:	80 e0       	ldi	r24, 0x00	; 0
    208a:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_SetPin_Value>
    208e:	08 95       	ret

Disassembly of section .text.YELLOW_LED_TGL:

000020b8 <YELLOW_LED_TGL>:
}
void YELLOW_LED_TGL(void){
	DIO_TglPin_Value(YELLOW_LED_PORT,YELLOW_LED_PIN);
    20b8:	66 e0       	ldi	r22, 0x06	; 6
    20ba:	80 e0       	ldi	r24, 0x00	; 0
    20bc:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <DIO_TglPin_Value>
    20c0:	08 95       	ret

Disassembly of section .text.main:

000020c2 <main>:

#include "main.h"


int main() {
app_init();
    20c2:	0e 94 6e 0f 	call	0x1edc	; 0x1edc <app_init>
while(1){
app_main();
    20c6:	0e 94 66 10 	call	0x20cc	; 0x20cc <app_main>
    20ca:	fd cf       	rjmp	.-6      	; 0x20c6 <main+0x4>

Disassembly of section .text.ADC_Initialize:

00001daa <ADC_Initialize>:

#include "ADC_Private.h"

ERROR_STATE ADC_Initialize(){
	CLR_BIT(ADC_REF_voltage,REF_BIT1);SET_BIT(ADC_REF_voltage,REF_BIT0);
    1daa:	87 b1       	in	r24, 0x07	; 7
    1dac:	8f 77       	andi	r24, 0x7F	; 127
    1dae:	87 b9       	out	0x07, r24	; 7
    1db0:	87 b1       	in	r24, 0x07	; 7
    1db2:	80 64       	ori	r24, 0x40	; 64
    1db4:	87 b9       	out	0x07, r24	; 7
	SET_BIT(ADC_CNTR_State,ADC_EN_BIT);
    1db6:	86 b1       	in	r24, 0x06	; 6
    1db8:	80 68       	ori	r24, 0x80	; 128
    1dba:	86 b9       	out	0x06, r24	; 6
	SET_BIT(ADC_CNTR_State,ADC_PRESCALER_BIT2);SET_BIT(ADC_CNTR_State,ADC_PRESCALER_BIT1);SET_BIT(ADC_CNTR_State,ADC_PRESCALER_BIT0);
    1dbc:	86 b1       	in	r24, 0x06	; 6
    1dbe:	84 60       	ori	r24, 0x04	; 4
    1dc0:	86 b9       	out	0x06, r24	; 6
    1dc2:	86 b1       	in	r24, 0x06	; 6
    1dc4:	82 60       	ori	r24, 0x02	; 2
    1dc6:	86 b9       	out	0x06, r24	; 6
    1dc8:	86 b1       	in	r24, 0x06	; 6
    1dca:	81 60       	ori	r24, 0x01	; 1
    1dcc:	86 b9       	out	0x06, r24	; 6
	return SUCCESS;
}
    1dce:	81 e0       	ldi	r24, 0x01	; 1
    1dd0:	08 95       	ret

Disassembly of section .text.ADC_Read:

00001cf4 <ADC_Read>:

ERROR_STATE ADC_Read(ADC_PIN channel,UINT16_t* adc_value){
	ADC_REF_voltage &= 0xf0;
    1cf4:	97 b1       	in	r25, 0x07	; 7
    1cf6:	90 7f       	andi	r25, 0xF0	; 240
    1cf8:	97 b9       	out	0x07, r25	; 7
	ADC_REF_voltage |= channel;
    1cfa:	97 b1       	in	r25, 0x07	; 7
    1cfc:	89 2b       	or	r24, r25
    1cfe:	87 b9       	out	0x07, r24	; 7
	CLR_BIT(ADC_CNTR_State,ADC_INTERRUPT_EN);
    1d00:	86 b1       	in	r24, 0x06	; 6
    1d02:	87 7f       	andi	r24, 0xF7	; 247
    1d04:	86 b9       	out	0x06, r24	; 6
	CLR_BIT(ADC_CNTR_State,ADC_AUTO_TRIGGER_EN);
    1d06:	86 b1       	in	r24, 0x06	; 6
    1d08:	8f 7d       	andi	r24, 0xDF	; 223
    1d0a:	86 b9       	out	0x06, r24	; 6
	SET_BIT(ADC_CNTR_State,ADC_START_CONVERSION);
    1d0c:	86 b1       	in	r24, 0x06	; 6
    1d0e:	80 64       	ori	r24, 0x40	; 64
    1d10:	86 b9       	out	0x06, r24	; 6
	while(GET_BIT(ADC_CNTR_State,ADC_NORMAL_FLAG));
    1d12:	36 99       	sbic	0x06, 6	; 6
    1d14:	fe cf       	rjmp	.-4      	; 0x1d12 <ADC_Read+0x1e>
	*adc_value = ADCL;
    1d16:	84 b1       	in	r24, 0x04	; 4
    1d18:	95 b1       	in	r25, 0x05	; 5
    1d1a:	fb 01       	movw	r30, r22
    1d1c:	91 83       	std	Z+1, r25	; 0x01
    1d1e:	80 83       	st	Z, r24
	return SUCCESS;
}
    1d20:	81 e0       	ldi	r24, 0x01	; 1
    1d22:	08 95       	ret

Disassembly of section .text.DIO_SetPin_Direction:

00000c1a <DIO_SetPin_Direction>:
#include "DIO_Private.h"

ERROR_STATE DIO_SetPin_Direction(DIO_Port port, DIO_Pin pin, DIO_State state)
{
	ERROR_STATE state_error = SUCCESS;
	switch (state)
 c1a:	44 23       	and	r20, r20
 c1c:	19 f0       	breq	.+6      	; 0xc24 <DIO_SetPin_Direction+0xa>
 c1e:	41 30       	cpi	r20, 0x01	; 1
 c20:	e9 f1       	breq	.+122    	; 0xc9c <DIO_SetPin_Direction+0x82>
 c22:	74 c0       	rjmp	.+232    	; 0xd0c <DIO_SetPin_Direction+0xf2>
	{
		case DIO_INPUT:
		switch(port)
 c24:	81 30       	cpi	r24, 0x01	; 1
 c26:	99 f0       	breq	.+38     	; 0xc4e <DIO_SetPin_Direction+0x34>
 c28:	28 f0       	brcs	.+10     	; 0xc34 <DIO_SetPin_Direction+0x1a>
 c2a:	82 30       	cpi	r24, 0x02	; 2
 c2c:	e9 f0       	breq	.+58     	; 0xc68 <DIO_SetPin_Direction+0x4e>
 c2e:	83 30       	cpi	r24, 0x03	; 3
 c30:	41 f1       	breq	.+80     	; 0xc82 <DIO_SetPin_Direction+0x68>
 c32:	6e c0       	rjmp	.+220    	; 0xd10 <DIO_SetPin_Direction+0xf6>
		{
			case DIO_PORTA:
			CLR_BIT(DDRA, pin);
 c34:	2a b3       	in	r18, 0x1a	; 26
 c36:	81 e0       	ldi	r24, 0x01	; 1
 c38:	90 e0       	ldi	r25, 0x00	; 0
 c3a:	02 c0       	rjmp	.+4      	; 0xc40 <DIO_SetPin_Direction+0x26>
 c3c:	88 0f       	add	r24, r24
 c3e:	99 1f       	adc	r25, r25
 c40:	6a 95       	dec	r22
 c42:	e2 f7       	brpl	.-8      	; 0xc3c <DIO_SetPin_Direction+0x22>
 c44:	80 95       	com	r24
 c46:	82 23       	and	r24, r18
 c48:	8a bb       	out	0x1a, r24	; 26

#include "DIO_Private.h"

ERROR_STATE DIO_SetPin_Direction(DIO_Port port, DIO_Pin pin, DIO_State state)
{
	ERROR_STATE state_error = SUCCESS;
 c4a:	81 e0       	ldi	r24, 0x01	; 1
		case DIO_INPUT:
		switch(port)
		{
			case DIO_PORTA:
			CLR_BIT(DDRA, pin);
			break;
 c4c:	08 95       	ret
			case DIO_PORTB:
			CLR_BIT(DDRB, pin);
 c4e:	27 b3       	in	r18, 0x17	; 23
 c50:	81 e0       	ldi	r24, 0x01	; 1
 c52:	90 e0       	ldi	r25, 0x00	; 0
 c54:	02 c0       	rjmp	.+4      	; 0xc5a <DIO_SetPin_Direction+0x40>
 c56:	88 0f       	add	r24, r24
 c58:	99 1f       	adc	r25, r25
 c5a:	6a 95       	dec	r22
 c5c:	e2 f7       	brpl	.-8      	; 0xc56 <DIO_SetPin_Direction+0x3c>
 c5e:	80 95       	com	r24
 c60:	82 23       	and	r24, r18
 c62:	87 bb       	out	0x17, r24	; 23

#include "DIO_Private.h"

ERROR_STATE DIO_SetPin_Direction(DIO_Port port, DIO_Pin pin, DIO_State state)
{
	ERROR_STATE state_error = SUCCESS;
 c64:	81 e0       	ldi	r24, 0x01	; 1
			case DIO_PORTA:
			CLR_BIT(DDRA, pin);
			break;
			case DIO_PORTB:
			CLR_BIT(DDRB, pin);
			break;
 c66:	08 95       	ret
			case DIO_PORTC:
			CLR_BIT(DDRC, pin);
 c68:	24 b3       	in	r18, 0x14	; 20
 c6a:	81 e0       	ldi	r24, 0x01	; 1
 c6c:	90 e0       	ldi	r25, 0x00	; 0
 c6e:	02 c0       	rjmp	.+4      	; 0xc74 <DIO_SetPin_Direction+0x5a>
 c70:	88 0f       	add	r24, r24
 c72:	99 1f       	adc	r25, r25
 c74:	6a 95       	dec	r22
 c76:	e2 f7       	brpl	.-8      	; 0xc70 <DIO_SetPin_Direction+0x56>
 c78:	80 95       	com	r24
 c7a:	82 23       	and	r24, r18
 c7c:	84 bb       	out	0x14, r24	; 20

#include "DIO_Private.h"

ERROR_STATE DIO_SetPin_Direction(DIO_Port port, DIO_Pin pin, DIO_State state)
{
	ERROR_STATE state_error = SUCCESS;
 c7e:	81 e0       	ldi	r24, 0x01	; 1
			case DIO_PORTB:
			CLR_BIT(DDRB, pin);
			break;
			case DIO_PORTC:
			CLR_BIT(DDRC, pin);
			break;
 c80:	08 95       	ret
			case DIO_PORTD:
			CLR_BIT(DDRD, pin);
 c82:	21 b3       	in	r18, 0x11	; 17
 c84:	81 e0       	ldi	r24, 0x01	; 1
 c86:	90 e0       	ldi	r25, 0x00	; 0
 c88:	02 c0       	rjmp	.+4      	; 0xc8e <DIO_SetPin_Direction+0x74>
 c8a:	88 0f       	add	r24, r24
 c8c:	99 1f       	adc	r25, r25
 c8e:	6a 95       	dec	r22
 c90:	e2 f7       	brpl	.-8      	; 0xc8a <DIO_SetPin_Direction+0x70>
 c92:	80 95       	com	r24
 c94:	82 23       	and	r24, r18
 c96:	81 bb       	out	0x11, r24	; 17

#include "DIO_Private.h"

ERROR_STATE DIO_SetPin_Direction(DIO_Port port, DIO_Pin pin, DIO_State state)
{
	ERROR_STATE state_error = SUCCESS;
 c98:	81 e0       	ldi	r24, 0x01	; 1
			case DIO_PORTC:
			CLR_BIT(DDRC, pin);
			break;
			case DIO_PORTD:
			CLR_BIT(DDRD, pin);
			break;
 c9a:	08 95       	ret
			state_error = FAIL;
			break;
		}
		break;
		case DIO_OUTPUT:
		switch(port)
 c9c:	81 30       	cpi	r24, 0x01	; 1
 c9e:	91 f0       	breq	.+36     	; 0xcc4 <DIO_SetPin_Direction+0xaa>
 ca0:	28 f0       	brcs	.+10     	; 0xcac <DIO_SetPin_Direction+0x92>
 ca2:	82 30       	cpi	r24, 0x02	; 2
 ca4:	d9 f0       	breq	.+54     	; 0xcdc <DIO_SetPin_Direction+0xc2>
 ca6:	83 30       	cpi	r24, 0x03	; 3
 ca8:	29 f1       	breq	.+74     	; 0xcf4 <DIO_SetPin_Direction+0xda>
 caa:	34 c0       	rjmp	.+104    	; 0xd14 <DIO_SetPin_Direction+0xfa>
		{
			case DIO_PORTA:
			SET_BIT(DDRA, pin);
 cac:	2a b3       	in	r18, 0x1a	; 26
 cae:	81 e0       	ldi	r24, 0x01	; 1
 cb0:	90 e0       	ldi	r25, 0x00	; 0
 cb2:	02 c0       	rjmp	.+4      	; 0xcb8 <DIO_SetPin_Direction+0x9e>
 cb4:	88 0f       	add	r24, r24
 cb6:	99 1f       	adc	r25, r25
 cb8:	6a 95       	dec	r22
 cba:	e2 f7       	brpl	.-8      	; 0xcb4 <DIO_SetPin_Direction+0x9a>
 cbc:	82 2b       	or	r24, r18
 cbe:	8a bb       	out	0x1a, r24	; 26

#include "DIO_Private.h"

ERROR_STATE DIO_SetPin_Direction(DIO_Port port, DIO_Pin pin, DIO_State state)
{
	ERROR_STATE state_error = SUCCESS;
 cc0:	81 e0       	ldi	r24, 0x01	; 1
		case DIO_OUTPUT:
		switch(port)
		{
			case DIO_PORTA:
			SET_BIT(DDRA, pin);
			break;
 cc2:	08 95       	ret
			case DIO_PORTB:
			SET_BIT(DDRB, pin);
 cc4:	27 b3       	in	r18, 0x17	; 23
 cc6:	81 e0       	ldi	r24, 0x01	; 1
 cc8:	90 e0       	ldi	r25, 0x00	; 0
 cca:	02 c0       	rjmp	.+4      	; 0xcd0 <DIO_SetPin_Direction+0xb6>
 ccc:	88 0f       	add	r24, r24
 cce:	99 1f       	adc	r25, r25
 cd0:	6a 95       	dec	r22
 cd2:	e2 f7       	brpl	.-8      	; 0xccc <DIO_SetPin_Direction+0xb2>
 cd4:	82 2b       	or	r24, r18
 cd6:	87 bb       	out	0x17, r24	; 23

#include "DIO_Private.h"

ERROR_STATE DIO_SetPin_Direction(DIO_Port port, DIO_Pin pin, DIO_State state)
{
	ERROR_STATE state_error = SUCCESS;
 cd8:	81 e0       	ldi	r24, 0x01	; 1
			case DIO_PORTA:
			SET_BIT(DDRA, pin);
			break;
			case DIO_PORTB:
			SET_BIT(DDRB, pin);
			break;
 cda:	08 95       	ret
			case DIO_PORTC:
			SET_BIT(DDRC, pin);
 cdc:	24 b3       	in	r18, 0x14	; 20
 cde:	81 e0       	ldi	r24, 0x01	; 1
 ce0:	90 e0       	ldi	r25, 0x00	; 0
 ce2:	02 c0       	rjmp	.+4      	; 0xce8 <DIO_SetPin_Direction+0xce>
 ce4:	88 0f       	add	r24, r24
 ce6:	99 1f       	adc	r25, r25
 ce8:	6a 95       	dec	r22
 cea:	e2 f7       	brpl	.-8      	; 0xce4 <DIO_SetPin_Direction+0xca>
 cec:	82 2b       	or	r24, r18
 cee:	84 bb       	out	0x14, r24	; 20

#include "DIO_Private.h"

ERROR_STATE DIO_SetPin_Direction(DIO_Port port, DIO_Pin pin, DIO_State state)
{
	ERROR_STATE state_error = SUCCESS;
 cf0:	81 e0       	ldi	r24, 0x01	; 1
			case DIO_PORTB:
			SET_BIT(DDRB, pin);
			break;
			case DIO_PORTC:
			SET_BIT(DDRC, pin);
			break;
 cf2:	08 95       	ret
			case DIO_PORTD:
			SET_BIT(DDRD, pin);
 cf4:	21 b3       	in	r18, 0x11	; 17
 cf6:	81 e0       	ldi	r24, 0x01	; 1
 cf8:	90 e0       	ldi	r25, 0x00	; 0
 cfa:	02 c0       	rjmp	.+4      	; 0xd00 <DIO_SetPin_Direction+0xe6>
 cfc:	88 0f       	add	r24, r24
 cfe:	99 1f       	adc	r25, r25
 d00:	6a 95       	dec	r22
 d02:	e2 f7       	brpl	.-8      	; 0xcfc <DIO_SetPin_Direction+0xe2>
 d04:	82 2b       	or	r24, r18
 d06:	81 bb       	out	0x11, r24	; 17

#include "DIO_Private.h"

ERROR_STATE DIO_SetPin_Direction(DIO_Port port, DIO_Pin pin, DIO_State state)
{
	ERROR_STATE state_error = SUCCESS;
 d08:	81 e0       	ldi	r24, 0x01	; 1
			case DIO_PORTC:
			SET_BIT(DDRC, pin);
			break;
			case DIO_PORTD:
			SET_BIT(DDRD, pin);
			break;
 d0a:	08 95       	ret

#include "DIO_Private.h"

ERROR_STATE DIO_SetPin_Direction(DIO_Port port, DIO_Pin pin, DIO_State state)
{
	ERROR_STATE state_error = SUCCESS;
 d0c:	81 e0       	ldi	r24, 0x01	; 1
 d0e:	08 95       	ret
			break;
			case DIO_PORTD:
			CLR_BIT(DDRD, pin);
			break;
			default:
			state_error = FAIL;
 d10:	80 e0       	ldi	r24, 0x00	; 0
 d12:	08 95       	ret
			break;
			case DIO_PORTD:
			SET_BIT(DDRD, pin);
			break;
			default:
			state_error = FAIL;
 d14:	80 e0       	ldi	r24, 0x00	; 0
			break;
		}
		break;
	}
	return state_error;
}
 d16:	08 95       	ret

Disassembly of section .text.DIO_SetPin_Value:

00000d18 <DIO_SetPin_Value>:

ERROR_STATE DIO_SetPin_Value(DIO_Port port, DIO_Pin pin, DIO_Status status)
{
ERROR_STATE state_error = SUCCESS;
	switch (status)
 d18:	44 23       	and	r20, r20
 d1a:	19 f0       	breq	.+6      	; 0xd22 <DIO_SetPin_Value+0xa>
 d1c:	41 30       	cpi	r20, 0x01	; 1
 d1e:	e9 f1       	breq	.+122    	; 0xd9a <DIO_SetPin_Value+0x82>
 d20:	74 c0       	rjmp	.+232    	; 0xe0a <DIO_SetPin_Value+0xf2>
	{
		case DIO_LOW:
		switch(port)
 d22:	81 30       	cpi	r24, 0x01	; 1
 d24:	99 f0       	breq	.+38     	; 0xd4c <DIO_SetPin_Value+0x34>
 d26:	28 f0       	brcs	.+10     	; 0xd32 <DIO_SetPin_Value+0x1a>
 d28:	82 30       	cpi	r24, 0x02	; 2
 d2a:	e9 f0       	breq	.+58     	; 0xd66 <DIO_SetPin_Value+0x4e>
 d2c:	83 30       	cpi	r24, 0x03	; 3
 d2e:	41 f1       	breq	.+80     	; 0xd80 <DIO_SetPin_Value+0x68>
 d30:	6e c0       	rjmp	.+220    	; 0xe0e <DIO_SetPin_Value+0xf6>
		{
			case DIO_PORTA:
			CLR_BIT(PORTA, pin);
 d32:	2b b3       	in	r18, 0x1b	; 27
 d34:	81 e0       	ldi	r24, 0x01	; 1
 d36:	90 e0       	ldi	r25, 0x00	; 0
 d38:	02 c0       	rjmp	.+4      	; 0xd3e <DIO_SetPin_Value+0x26>
 d3a:	88 0f       	add	r24, r24
 d3c:	99 1f       	adc	r25, r25
 d3e:	6a 95       	dec	r22
 d40:	e2 f7       	brpl	.-8      	; 0xd3a <DIO_SetPin_Value+0x22>
 d42:	80 95       	com	r24
 d44:	82 23       	and	r24, r18
 d46:	8b bb       	out	0x1b, r24	; 27
	return state_error;
}

ERROR_STATE DIO_SetPin_Value(DIO_Port port, DIO_Pin pin, DIO_Status status)
{
ERROR_STATE state_error = SUCCESS;
 d48:	81 e0       	ldi	r24, 0x01	; 1
		case DIO_LOW:
		switch(port)
		{
			case DIO_PORTA:
			CLR_BIT(PORTA, pin);
			break;
 d4a:	08 95       	ret
			case DIO_PORTB:
			CLR_BIT(PORTB, pin);
 d4c:	28 b3       	in	r18, 0x18	; 24
 d4e:	81 e0       	ldi	r24, 0x01	; 1
 d50:	90 e0       	ldi	r25, 0x00	; 0
 d52:	02 c0       	rjmp	.+4      	; 0xd58 <DIO_SetPin_Value+0x40>
 d54:	88 0f       	add	r24, r24
 d56:	99 1f       	adc	r25, r25
 d58:	6a 95       	dec	r22
 d5a:	e2 f7       	brpl	.-8      	; 0xd54 <DIO_SetPin_Value+0x3c>
 d5c:	80 95       	com	r24
 d5e:	82 23       	and	r24, r18
 d60:	88 bb       	out	0x18, r24	; 24
	return state_error;
}

ERROR_STATE DIO_SetPin_Value(DIO_Port port, DIO_Pin pin, DIO_Status status)
{
ERROR_STATE state_error = SUCCESS;
 d62:	81 e0       	ldi	r24, 0x01	; 1
			case DIO_PORTA:
			CLR_BIT(PORTA, pin);
			break;
			case DIO_PORTB:
			CLR_BIT(PORTB, pin);
			break;
 d64:	08 95       	ret
			case DIO_PORTC:
			CLR_BIT(PORTC, pin);
 d66:	25 b3       	in	r18, 0x15	; 21
 d68:	81 e0       	ldi	r24, 0x01	; 1
 d6a:	90 e0       	ldi	r25, 0x00	; 0
 d6c:	02 c0       	rjmp	.+4      	; 0xd72 <DIO_SetPin_Value+0x5a>
 d6e:	88 0f       	add	r24, r24
 d70:	99 1f       	adc	r25, r25
 d72:	6a 95       	dec	r22
 d74:	e2 f7       	brpl	.-8      	; 0xd6e <DIO_SetPin_Value+0x56>
 d76:	80 95       	com	r24
 d78:	82 23       	and	r24, r18
 d7a:	85 bb       	out	0x15, r24	; 21
	return state_error;
}

ERROR_STATE DIO_SetPin_Value(DIO_Port port, DIO_Pin pin, DIO_Status status)
{
ERROR_STATE state_error = SUCCESS;
 d7c:	81 e0       	ldi	r24, 0x01	; 1
			case DIO_PORTB:
			CLR_BIT(PORTB, pin);
			break;
			case DIO_PORTC:
			CLR_BIT(PORTC, pin);
			break;
 d7e:	08 95       	ret
			case DIO_PORTD:
			CLR_BIT(PORTD, pin);
 d80:	22 b3       	in	r18, 0x12	; 18
 d82:	81 e0       	ldi	r24, 0x01	; 1
 d84:	90 e0       	ldi	r25, 0x00	; 0
 d86:	02 c0       	rjmp	.+4      	; 0xd8c <DIO_SetPin_Value+0x74>
 d88:	88 0f       	add	r24, r24
 d8a:	99 1f       	adc	r25, r25
 d8c:	6a 95       	dec	r22
 d8e:	e2 f7       	brpl	.-8      	; 0xd88 <DIO_SetPin_Value+0x70>
 d90:	80 95       	com	r24
 d92:	82 23       	and	r24, r18
 d94:	82 bb       	out	0x12, r24	; 18
	return state_error;
}

ERROR_STATE DIO_SetPin_Value(DIO_Port port, DIO_Pin pin, DIO_Status status)
{
ERROR_STATE state_error = SUCCESS;
 d96:	81 e0       	ldi	r24, 0x01	; 1
			case DIO_PORTC:
			CLR_BIT(PORTC, pin);
			break;
			case DIO_PORTD:
			CLR_BIT(PORTD, pin);
			break;
 d98:	08 95       	ret
			state_error = FAIL;
			break;
		}
		break;
		case DIO_HIGH:
		switch(port)
 d9a:	81 30       	cpi	r24, 0x01	; 1
 d9c:	91 f0       	breq	.+36     	; 0xdc2 <DIO_SetPin_Value+0xaa>
 d9e:	28 f0       	brcs	.+10     	; 0xdaa <DIO_SetPin_Value+0x92>
 da0:	82 30       	cpi	r24, 0x02	; 2
 da2:	d9 f0       	breq	.+54     	; 0xdda <DIO_SetPin_Value+0xc2>
 da4:	83 30       	cpi	r24, 0x03	; 3
 da6:	29 f1       	breq	.+74     	; 0xdf2 <DIO_SetPin_Value+0xda>
 da8:	34 c0       	rjmp	.+104    	; 0xe12 <DIO_SetPin_Value+0xfa>
		{
			case DIO_PORTA:
			SET_BIT(PORTA, pin);
 daa:	2b b3       	in	r18, 0x1b	; 27
 dac:	81 e0       	ldi	r24, 0x01	; 1
 dae:	90 e0       	ldi	r25, 0x00	; 0
 db0:	02 c0       	rjmp	.+4      	; 0xdb6 <DIO_SetPin_Value+0x9e>
 db2:	88 0f       	add	r24, r24
 db4:	99 1f       	adc	r25, r25
 db6:	6a 95       	dec	r22
 db8:	e2 f7       	brpl	.-8      	; 0xdb2 <DIO_SetPin_Value+0x9a>
 dba:	82 2b       	or	r24, r18
 dbc:	8b bb       	out	0x1b, r24	; 27
	return state_error;
}

ERROR_STATE DIO_SetPin_Value(DIO_Port port, DIO_Pin pin, DIO_Status status)
{
ERROR_STATE state_error = SUCCESS;
 dbe:	81 e0       	ldi	r24, 0x01	; 1
		case DIO_HIGH:
		switch(port)
		{
			case DIO_PORTA:
			SET_BIT(PORTA, pin);
			break;
 dc0:	08 95       	ret
			case DIO_PORTB:
			SET_BIT(PORTB, pin);
 dc2:	28 b3       	in	r18, 0x18	; 24
 dc4:	81 e0       	ldi	r24, 0x01	; 1
 dc6:	90 e0       	ldi	r25, 0x00	; 0
 dc8:	02 c0       	rjmp	.+4      	; 0xdce <DIO_SetPin_Value+0xb6>
 dca:	88 0f       	add	r24, r24
 dcc:	99 1f       	adc	r25, r25
 dce:	6a 95       	dec	r22
 dd0:	e2 f7       	brpl	.-8      	; 0xdca <DIO_SetPin_Value+0xb2>
 dd2:	82 2b       	or	r24, r18
 dd4:	88 bb       	out	0x18, r24	; 24
	return state_error;
}

ERROR_STATE DIO_SetPin_Value(DIO_Port port, DIO_Pin pin, DIO_Status status)
{
ERROR_STATE state_error = SUCCESS;
 dd6:	81 e0       	ldi	r24, 0x01	; 1
			case DIO_PORTA:
			SET_BIT(PORTA, pin);
			break;
			case DIO_PORTB:
			SET_BIT(PORTB, pin);
			break;
 dd8:	08 95       	ret
			case DIO_PORTC:
			SET_BIT(PORTC, pin);
 dda:	25 b3       	in	r18, 0x15	; 21
 ddc:	81 e0       	ldi	r24, 0x01	; 1
 dde:	90 e0       	ldi	r25, 0x00	; 0
 de0:	02 c0       	rjmp	.+4      	; 0xde6 <DIO_SetPin_Value+0xce>
 de2:	88 0f       	add	r24, r24
 de4:	99 1f       	adc	r25, r25
 de6:	6a 95       	dec	r22
 de8:	e2 f7       	brpl	.-8      	; 0xde2 <DIO_SetPin_Value+0xca>
 dea:	82 2b       	or	r24, r18
 dec:	85 bb       	out	0x15, r24	; 21
	return state_error;
}

ERROR_STATE DIO_SetPin_Value(DIO_Port port, DIO_Pin pin, DIO_Status status)
{
ERROR_STATE state_error = SUCCESS;
 dee:	81 e0       	ldi	r24, 0x01	; 1
			case DIO_PORTB:
			SET_BIT(PORTB, pin);
			break;
			case DIO_PORTC:
			SET_BIT(PORTC, pin);
			break;
 df0:	08 95       	ret
			case DIO_PORTD:
			SET_BIT(PORTD, pin);
 df2:	22 b3       	in	r18, 0x12	; 18
 df4:	81 e0       	ldi	r24, 0x01	; 1
 df6:	90 e0       	ldi	r25, 0x00	; 0
 df8:	02 c0       	rjmp	.+4      	; 0xdfe <DIO_SetPin_Value+0xe6>
 dfa:	88 0f       	add	r24, r24
 dfc:	99 1f       	adc	r25, r25
 dfe:	6a 95       	dec	r22
 e00:	e2 f7       	brpl	.-8      	; 0xdfa <DIO_SetPin_Value+0xe2>
 e02:	82 2b       	or	r24, r18
 e04:	82 bb       	out	0x12, r24	; 18
	return state_error;
}

ERROR_STATE DIO_SetPin_Value(DIO_Port port, DIO_Pin pin, DIO_Status status)
{
ERROR_STATE state_error = SUCCESS;
 e06:	81 e0       	ldi	r24, 0x01	; 1
			case DIO_PORTC:
			SET_BIT(PORTC, pin);
			break;
			case DIO_PORTD:
			SET_BIT(PORTD, pin);
			break;
 e08:	08 95       	ret
	return state_error;
}

ERROR_STATE DIO_SetPin_Value(DIO_Port port, DIO_Pin pin, DIO_Status status)
{
ERROR_STATE state_error = SUCCESS;
 e0a:	81 e0       	ldi	r24, 0x01	; 1
 e0c:	08 95       	ret
			break;
			case DIO_PORTD:
			CLR_BIT(PORTD, pin);
			break;
			default:
			state_error = FAIL;
 e0e:	80 e0       	ldi	r24, 0x00	; 0
 e10:	08 95       	ret
			break;
			case DIO_PORTD:
			SET_BIT(PORTD, pin);
			break;
			default:
			state_error = FAIL;
 e12:	80 e0       	ldi	r24, 0x00	; 0
			break;
		}
		break;
	}
	return state_error;
}
 e14:	08 95       	ret

Disassembly of section .text.DIO_TglPin_Value:

000019a8 <DIO_TglPin_Value>:

ERROR_STATE DIO_TglPin_Value(DIO_Port port, DIO_Pin pin)
{
ERROR_STATE state_error = SUCCESS;
	switch(port)
    19a8:	81 30       	cpi	r24, 0x01	; 1
    19aa:	91 f0       	breq	.+36     	; 0x19d0 <DIO_TglPin_Value+0x28>
    19ac:	28 f0       	brcs	.+10     	; 0x19b8 <DIO_TglPin_Value+0x10>
    19ae:	82 30       	cpi	r24, 0x02	; 2
    19b0:	d9 f0       	breq	.+54     	; 0x19e8 <DIO_TglPin_Value+0x40>
    19b2:	83 30       	cpi	r24, 0x03	; 3
    19b4:	29 f1       	breq	.+74     	; 0x1a00 <DIO_TglPin_Value+0x58>
    19b6:	30 c0       	rjmp	.+96     	; 0x1a18 <DIO_TglPin_Value+0x70>
	{
		case DIO_PORTA:
		TGL_BIT(PORTA, pin);
    19b8:	2b b3       	in	r18, 0x1b	; 27
    19ba:	81 e0       	ldi	r24, 0x01	; 1
    19bc:	90 e0       	ldi	r25, 0x00	; 0
    19be:	02 c0       	rjmp	.+4      	; 0x19c4 <DIO_TglPin_Value+0x1c>
    19c0:	88 0f       	add	r24, r24
    19c2:	99 1f       	adc	r25, r25
    19c4:	6a 95       	dec	r22
    19c6:	e2 f7       	brpl	.-8      	; 0x19c0 <DIO_TglPin_Value+0x18>
    19c8:	82 27       	eor	r24, r18
    19ca:	8b bb       	out	0x1b, r24	; 27
	return state_error;
}

ERROR_STATE DIO_TglPin_Value(DIO_Port port, DIO_Pin pin)
{
ERROR_STATE state_error = SUCCESS;
    19cc:	81 e0       	ldi	r24, 0x01	; 1
	switch(port)
	{
		case DIO_PORTA:
		TGL_BIT(PORTA, pin);
		break;
    19ce:	08 95       	ret
		case DIO_PORTB:
		TGL_BIT(PORTB, pin);
    19d0:	28 b3       	in	r18, 0x18	; 24
    19d2:	81 e0       	ldi	r24, 0x01	; 1
    19d4:	90 e0       	ldi	r25, 0x00	; 0
    19d6:	02 c0       	rjmp	.+4      	; 0x19dc <DIO_TglPin_Value+0x34>
    19d8:	88 0f       	add	r24, r24
    19da:	99 1f       	adc	r25, r25
    19dc:	6a 95       	dec	r22
    19de:	e2 f7       	brpl	.-8      	; 0x19d8 <DIO_TglPin_Value+0x30>
    19e0:	82 27       	eor	r24, r18
    19e2:	88 bb       	out	0x18, r24	; 24
	return state_error;
}

ERROR_STATE DIO_TglPin_Value(DIO_Port port, DIO_Pin pin)
{
ERROR_STATE state_error = SUCCESS;
    19e4:	81 e0       	ldi	r24, 0x01	; 1
		case DIO_PORTA:
		TGL_BIT(PORTA, pin);
		break;
		case DIO_PORTB:
		TGL_BIT(PORTB, pin);
		break;
    19e6:	08 95       	ret
		case DIO_PORTC:
		TGL_BIT(PORTC, pin);
    19e8:	25 b3       	in	r18, 0x15	; 21
    19ea:	81 e0       	ldi	r24, 0x01	; 1
    19ec:	90 e0       	ldi	r25, 0x00	; 0
    19ee:	02 c0       	rjmp	.+4      	; 0x19f4 <DIO_TglPin_Value+0x4c>
    19f0:	88 0f       	add	r24, r24
    19f2:	99 1f       	adc	r25, r25
    19f4:	6a 95       	dec	r22
    19f6:	e2 f7       	brpl	.-8      	; 0x19f0 <DIO_TglPin_Value+0x48>
    19f8:	82 27       	eor	r24, r18
    19fa:	85 bb       	out	0x15, r24	; 21
	return state_error;
}

ERROR_STATE DIO_TglPin_Value(DIO_Port port, DIO_Pin pin)
{
ERROR_STATE state_error = SUCCESS;
    19fc:	81 e0       	ldi	r24, 0x01	; 1
		case DIO_PORTB:
		TGL_BIT(PORTB, pin);
		break;
		case DIO_PORTC:
		TGL_BIT(PORTC, pin);
		break;
    19fe:	08 95       	ret
		case DIO_PORTD:
		TGL_BIT(PORTD, pin);
    1a00:	22 b3       	in	r18, 0x12	; 18
    1a02:	81 e0       	ldi	r24, 0x01	; 1
    1a04:	90 e0       	ldi	r25, 0x00	; 0
    1a06:	02 c0       	rjmp	.+4      	; 0x1a0c <DIO_TglPin_Value+0x64>
    1a08:	88 0f       	add	r24, r24
    1a0a:	99 1f       	adc	r25, r25
    1a0c:	6a 95       	dec	r22
    1a0e:	e2 f7       	brpl	.-8      	; 0x1a08 <DIO_TglPin_Value+0x60>
    1a10:	82 27       	eor	r24, r18
    1a12:	82 bb       	out	0x12, r24	; 18
	return state_error;
}

ERROR_STATE DIO_TglPin_Value(DIO_Port port, DIO_Pin pin)
{
ERROR_STATE state_error = SUCCESS;
    1a14:	81 e0       	ldi	r24, 0x01	; 1
		case DIO_PORTC:
		TGL_BIT(PORTC, pin);
		break;
		case DIO_PORTD:
		TGL_BIT(PORTD, pin);
		break;
    1a16:	08 95       	ret
		default:
		state_error = FAIL;
    1a18:	80 e0       	ldi	r24, 0x00	; 0
		break;
	}
	return state_error;
}
    1a1a:	08 95       	ret

Disassembly of section .text.DIO_GetPin_Value:

00001a1c <DIO_GetPin_Value>:

ERROR_STATE DIO_GetPin_Value(DIO_Port port, DIO_Pin pin,UINT8_t* pin_value)
{
ERROR_STATE state_error = SUCCESS;
	switch (port)
    1a1c:	81 30       	cpi	r24, 0x01	; 1
    1a1e:	91 f0       	breq	.+36     	; 0x1a44 <DIO_GetPin_Value+0x28>
    1a20:	28 f0       	brcs	.+10     	; 0x1a2c <DIO_GetPin_Value+0x10>
    1a22:	82 30       	cpi	r24, 0x02	; 2
    1a24:	d9 f0       	breq	.+54     	; 0x1a5c <DIO_GetPin_Value+0x40>
    1a26:	83 30       	cpi	r24, 0x03	; 3
    1a28:	29 f1       	breq	.+74     	; 0x1a74 <DIO_GetPin_Value+0x58>
    1a2a:	30 c0       	rjmp	.+96     	; 0x1a8c <DIO_GetPin_Value+0x70>
	{
		case DIO_PORTA:
		*pin_value = GET_BIT(PINA, pin);
    1a2c:	89 b3       	in	r24, 0x19	; 25
    1a2e:	90 e0       	ldi	r25, 0x00	; 0
    1a30:	02 c0       	rjmp	.+4      	; 0x1a36 <DIO_GetPin_Value+0x1a>
    1a32:	95 95       	asr	r25
    1a34:	87 95       	ror	r24
    1a36:	6a 95       	dec	r22
    1a38:	e2 f7       	brpl	.-8      	; 0x1a32 <DIO_GetPin_Value+0x16>
    1a3a:	81 70       	andi	r24, 0x01	; 1
    1a3c:	fa 01       	movw	r30, r20
    1a3e:	80 83       	st	Z, r24
	return state_error;
}

ERROR_STATE DIO_GetPin_Value(DIO_Port port, DIO_Pin pin,UINT8_t* pin_value)
{
ERROR_STATE state_error = SUCCESS;
    1a40:	81 e0       	ldi	r24, 0x01	; 1
	switch (port)
	{
		case DIO_PORTA:
		*pin_value = GET_BIT(PINA, pin);
		break;
    1a42:	08 95       	ret
		case DIO_PORTB:
		*pin_value = GET_BIT(PINB, pin);
    1a44:	86 b3       	in	r24, 0x16	; 22
    1a46:	90 e0       	ldi	r25, 0x00	; 0
    1a48:	02 c0       	rjmp	.+4      	; 0x1a4e <DIO_GetPin_Value+0x32>
    1a4a:	95 95       	asr	r25
    1a4c:	87 95       	ror	r24
    1a4e:	6a 95       	dec	r22
    1a50:	e2 f7       	brpl	.-8      	; 0x1a4a <DIO_GetPin_Value+0x2e>
    1a52:	81 70       	andi	r24, 0x01	; 1
    1a54:	fa 01       	movw	r30, r20
    1a56:	80 83       	st	Z, r24
	return state_error;
}

ERROR_STATE DIO_GetPin_Value(DIO_Port port, DIO_Pin pin,UINT8_t* pin_value)
{
ERROR_STATE state_error = SUCCESS;
    1a58:	81 e0       	ldi	r24, 0x01	; 1
		case DIO_PORTA:
		*pin_value = GET_BIT(PINA, pin);
		break;
		case DIO_PORTB:
		*pin_value = GET_BIT(PINB, pin);
		break;
    1a5a:	08 95       	ret
		case DIO_PORTC:
		*pin_value = GET_BIT(PINC, pin);
    1a5c:	83 b3       	in	r24, 0x13	; 19
    1a5e:	90 e0       	ldi	r25, 0x00	; 0
    1a60:	02 c0       	rjmp	.+4      	; 0x1a66 <DIO_GetPin_Value+0x4a>
    1a62:	95 95       	asr	r25
    1a64:	87 95       	ror	r24
    1a66:	6a 95       	dec	r22
    1a68:	e2 f7       	brpl	.-8      	; 0x1a62 <DIO_GetPin_Value+0x46>
    1a6a:	81 70       	andi	r24, 0x01	; 1
    1a6c:	fa 01       	movw	r30, r20
    1a6e:	80 83       	st	Z, r24
	return state_error;
}

ERROR_STATE DIO_GetPin_Value(DIO_Port port, DIO_Pin pin,UINT8_t* pin_value)
{
ERROR_STATE state_error = SUCCESS;
    1a70:	81 e0       	ldi	r24, 0x01	; 1
		case DIO_PORTB:
		*pin_value = GET_BIT(PINB, pin);
		break;
		case DIO_PORTC:
		*pin_value = GET_BIT(PINC, pin);
		break;
    1a72:	08 95       	ret
		case DIO_PORTD:
		*pin_value = GET_BIT(PIND, pin);
    1a74:	80 b3       	in	r24, 0x10	; 16
    1a76:	90 e0       	ldi	r25, 0x00	; 0
    1a78:	02 c0       	rjmp	.+4      	; 0x1a7e <DIO_GetPin_Value+0x62>
    1a7a:	95 95       	asr	r25
    1a7c:	87 95       	ror	r24
    1a7e:	6a 95       	dec	r22
    1a80:	e2 f7       	brpl	.-8      	; 0x1a7a <DIO_GetPin_Value+0x5e>
    1a82:	81 70       	andi	r24, 0x01	; 1
    1a84:	fa 01       	movw	r30, r20
    1a86:	80 83       	st	Z, r24
	return state_error;
}

ERROR_STATE DIO_GetPin_Value(DIO_Port port, DIO_Pin pin,UINT8_t* pin_value)
{
ERROR_STATE state_error = SUCCESS;
    1a88:	81 e0       	ldi	r24, 0x01	; 1
		case DIO_PORTC:
		*pin_value = GET_BIT(PINC, pin);
		break;
		case DIO_PORTD:
		*pin_value = GET_BIT(PIND, pin);
		break;
    1a8a:	08 95       	ret
		default:
		state_error = FAIL;
    1a8c:	80 e0       	ldi	r24, 0x00	; 0
		break;
	}
	return state_error;
}
    1a8e:	08 95       	ret

Disassembly of section .text.Set_Global_Initialize:

00001d7e <Set_Global_Initialize>:
#include "EXT_INT_Private.h"


ERROR_STATE Set_Global_Initialize(GLB_MODE mode){
	ERROR_STATE state_error = SUCCESS;
	SREG |= mode;
    1d7e:	9f b7       	in	r25, 0x3f	; 63
    1d80:	98 2b       	or	r25, r24
    1d82:	9f bf       	out	0x3f, r25	; 63
	if(mode == ON){
    1d84:	80 38       	cpi	r24, 0x80	; 128
    1d86:	29 f4       	brne	.+10     	; 0x1d92 <Set_Global_Initialize+0x14>
		if(!GET_BIT(SREG,7)){
    1d88:	0f b6       	in	r0, 0x3f	; 63
    1d8a:	07 fc       	sbrc	r0, 7
    1d8c:	08 c0       	rjmp	.+16     	; 0x1d9e <Set_Global_Initialize+0x20>
			state_error = FAIL;
    1d8e:	80 e0       	ldi	r24, 0x00	; 0
    1d90:	08 95       	ret
		}else{
			state_error = SUCCESS;
		}
	}else{
		if(mode == OFF){
    1d92:	81 11       	cpse	r24, r1
    1d94:	06 c0       	rjmp	.+12     	; 0x1da2 <Set_Global_Initialize+0x24>
			if(GET_BIT(SREG,7)){
    1d96:	0f b6       	in	r0, 0x3f	; 63
    1d98:	07 fe       	sbrs	r0, 7
    1d9a:	05 c0       	rjmp	.+10     	; 0x1da6 <Set_Global_Initialize+0x28>
    1d9c:	08 95       	ret
	SREG |= mode;
	if(mode == ON){
		if(!GET_BIT(SREG,7)){
			state_error = FAIL;
		}else{
			state_error = SUCCESS;
    1d9e:	81 e0       	ldi	r24, 0x01	; 1
    1da0:	08 95       	ret
				state_error = FAIL;
			}else{
				state_error = SUCCESS;
			}
		}else{
			state_error = FAIL;
    1da2:	80 e0       	ldi	r24, 0x00	; 0
    1da4:	08 95       	ret
	}else{
		if(mode == OFF){
			if(GET_BIT(SREG,7)){
				state_error = FAIL;
			}else{
				state_error = SUCCESS;
    1da6:	81 e0       	ldi	r24, 0x01	; 1
		}else{
			state_error = FAIL;
		}
	}
	return state_error;
}
    1da8:	08 95       	ret

Disassembly of section .text.Timer0_Initialize:

00001ef4 <Timer0_Initialize>:

#include "TIMER0_Private.h"


void Timer0_Initialize(){
Set_Global_Initialize(ON);
    1ef4:	80 e8       	ldi	r24, 0x80	; 128
    1ef6:	0e 94 bf 0e 	call	0x1d7e	; 0x1d7e <Set_Global_Initialize>
/*PHASE_CORRECT pwm*/
TIMER0_CNTR_REG = 0x43;
    1efa:	83 e4       	ldi	r24, 0x43	; 67
    1efc:	83 bf       	out	0x33, r24	; 51
/*COMP interrupt*/
INTTERUPT_FLAG_REG |= 0x03;
    1efe:	89 b7       	in	r24, 0x39	; 57
    1f00:	83 60       	ori	r24, 0x03	; 3
    1f02:	89 bf       	out	0x39, r24	; 57
/*TIMTTERUPT FLAG*/
SET_BIT(TIFR,OCF0);
    1f04:	88 b7       	in	r24, 0x38	; 56
    1f06:	82 60       	ori	r24, 0x02	; 2
    1f08:	88 bf       	out	0x38, r24	; 56
    1f0a:	08 95       	ret

Disassembly of section .text.SET_DUTY_CYCLE:

00001e44 <SET_DUTY_CYCLE>:
}

void SET_DUTY_CYCLE(UINT8_t duty_cycle){
	if(duty_cycle>99){
    1e44:	84 36       	cpi	r24, 0x64	; 100
    1e46:	08 f0       	brcs	.+2      	; 0x1e4a <SET_DUTY_CYCLE+0x6>
		duty_cycle=99;
    1e48:	83 e6       	ldi	r24, 0x63	; 99
	}
	if(duty_cycle<1){
    1e4a:	81 11       	cpse	r24, r1
    1e4c:	01 c0       	rjmp	.+2      	; 0x1e50 <SET_DUTY_CYCLE+0xc>
		duty_cycle=1;
    1e4e:	81 e0       	ldi	r24, 0x01	; 1
	}
	OCR0 = ((duty_cycle*255)/100);
    1e50:	2f ef       	ldi	r18, 0xFF	; 255
    1e52:	82 9f       	mul	r24, r18
    1e54:	c0 01       	movw	r24, r0
    1e56:	11 24       	eor	r1, r1
    1e58:	64 e6       	ldi	r22, 0x64	; 100
    1e5a:	70 e0       	ldi	r23, 0x00	; 0
    1e5c:	0e 94 e9 0e 	call	0x1dd2	; 0x1dd2 <__divmodhi4>
    1e60:	6c bf       	out	0x3c, r22	; 60
    1e62:	08 95       	ret

Disassembly of section .text.Timer0_STOP:

00001f7a <Timer0_STOP>:
}

void Timer0_STOP(){
	//TCCR0 &= ~0x03;
	CLR_BIT(TCCR0,CS00);
    1f7a:	83 b7       	in	r24, 0x33	; 51
    1f7c:	8e 7f       	andi	r24, 0xFE	; 254
    1f7e:	83 bf       	out	0x33, r24	; 51
	CLR_BIT(TCCR0,CS01);
    1f80:	83 b7       	in	r24, 0x33	; 51
    1f82:	8d 7f       	andi	r24, 0xFD	; 253
    1f84:	83 bf       	out	0x33, r24	; 51
	CLR_BIT(TCCR0,CS02);
    1f86:	83 b7       	in	r24, 0x33	; 51
    1f88:	8b 7f       	andi	r24, 0xFB	; 251
    1f8a:	83 bf       	out	0x33, r24	; 51
    1f8c:	08 95       	ret

Disassembly of section .text.Timer0_ON:

00001f8e <Timer0_ON>:
}
void Timer0_ON(){
	//TCCR0 |= 0x03;
	SET_BIT(TCCR0,CS00);
    1f8e:	83 b7       	in	r24, 0x33	; 51
    1f90:	81 60       	ori	r24, 0x01	; 1
    1f92:	83 bf       	out	0x33, r24	; 51
	SET_BIT(TCCR0,CS01);
    1f94:	83 b7       	in	r24, 0x33	; 51
    1f96:	82 60       	ori	r24, 0x02	; 2
    1f98:	83 bf       	out	0x33, r24	; 51
	CLR_BIT(TCCR0,CS02);
    1f9a:	83 b7       	in	r24, 0x33	; 51
    1f9c:	8b 7f       	andi	r24, 0xFB	; 251
    1f9e:	83 bf       	out	0x33, r24	; 51
    1fa0:	08 95       	ret

Disassembly of section .text.Timer1_Initialize:

00001e22 <Timer1_Initialize>:
 *  Author: aliae
 */ 
#include "TIMER_1_Private.h"

void Timer1_Initialize(){
	Set_Global_Initialize(ON);
    1e22:	80 e8       	ldi	r24, 0x80	; 128
    1e24:	0e 94 bf 0e 	call	0x1d7e	; 0x1d7e <Set_Global_Initialize>
	TCCR1A = 0x00;
    1e28:	1f bc       	out	0x2f, r1	; 47
	TCCR1B = 0x0D;
    1e2a:	8d e0       	ldi	r24, 0x0D	; 13
    1e2c:	8e bd       	out	0x2e, r24	; 46
	OCR1A = 15625;
    1e2e:	89 e0       	ldi	r24, 0x09	; 9
    1e30:	9d e3       	ldi	r25, 0x3D	; 61
    1e32:	9b bd       	out	0x2b, r25	; 43
    1e34:	8a bd       	out	0x2a, r24	; 42
	SET_BIT(TIMSK,OCIE1A);
    1e36:	89 b7       	in	r24, 0x39	; 57
    1e38:	80 61       	ori	r24, 0x10	; 16
    1e3a:	89 bf       	out	0x39, r24	; 57
	SET_BIT(TIFR,OCF1A);
    1e3c:	88 b7       	in	r24, 0x38	; 56
    1e3e:	80 61       	ori	r24, 0x10	; 16
    1e40:	88 bf       	out	0x38, r24	; 56
    1e42:	08 95       	ret

Disassembly of section .text.libgcc.div:

00001dd2 <__divmodhi4>:
    1dd2:	97 fb       	bst	r25, 7
    1dd4:	07 2e       	mov	r0, r23
    1dd6:	16 f4       	brtc	.+4      	; 0x1ddc <__divmodhi4+0xa>
    1dd8:	00 94       	com	r0
    1dda:	07 d0       	rcall	.+14     	; 0x1dea <__divmodhi4_neg1>
    1ddc:	77 fd       	sbrc	r23, 7
    1dde:	09 d0       	rcall	.+18     	; 0x1df2 <__divmodhi4_neg2>
    1de0:	0e 94 fd 0e 	call	0x1dfa	; 0x1dfa <__udivmodhi4>
    1de4:	07 fc       	sbrc	r0, 7
    1de6:	05 d0       	rcall	.+10     	; 0x1df2 <__divmodhi4_neg2>
    1de8:	3e f4       	brtc	.+14     	; 0x1df8 <__divmodhi4_exit>

00001dea <__divmodhi4_neg1>:
    1dea:	90 95       	com	r25
    1dec:	81 95       	neg	r24
    1dee:	9f 4f       	sbci	r25, 0xFF	; 255
    1df0:	08 95       	ret

00001df2 <__divmodhi4_neg2>:
    1df2:	70 95       	com	r23
    1df4:	61 95       	neg	r22
    1df6:	7f 4f       	sbci	r23, 0xFF	; 255

00001df8 <__divmodhi4_exit>:
    1df8:	08 95       	ret

Disassembly of section .text.libgcc.mul:

00001ea2 <__umulhisi3>:
    1ea2:	a2 9f       	mul	r26, r18
    1ea4:	b0 01       	movw	r22, r0
    1ea6:	b3 9f       	mul	r27, r19
    1ea8:	c0 01       	movw	r24, r0
    1eaa:	a3 9f       	mul	r26, r19
    1eac:	70 0d       	add	r23, r0
    1eae:	81 1d       	adc	r24, r1
    1eb0:	11 24       	eor	r1, r1
    1eb2:	91 1d       	adc	r25, r1
    1eb4:	b2 9f       	mul	r27, r18
    1eb6:	70 0d       	add	r23, r0
    1eb8:	81 1d       	adc	r24, r1
    1eba:	11 24       	eor	r1, r1
    1ebc:	91 1d       	adc	r25, r1
    1ebe:	08 95       	ret

Disassembly of section .text.libgcc.div:

00001af6 <__moddi3>:
    1af6:	68 94       	set
    1af8:	01 c0       	rjmp	.+2      	; 0x1afc <__divdi3_moddi3>

00001afa <__divdi3>:
    1afa:	e8 94       	clt

00001afc <__divdi3_moddi3>:
    1afc:	f9 2f       	mov	r31, r25
    1afe:	f1 2b       	or	r31, r17
    1b00:	12 f0       	brmi	.+4      	; 0x1b06 <__divdi3_moddi3+0xa>
    1b02:	0c 94 63 0f 	jmp	0x1ec6	; 0x1ec6 <__udivdi3_umoddi3>
    1b06:	a0 e0       	ldi	r26, 0x00	; 0
    1b08:	b0 e0       	ldi	r27, 0x00	; 0
    1b0a:	e9 e8       	ldi	r30, 0x89	; 137
    1b0c:	fd e0       	ldi	r31, 0x0D	; 13
    1b0e:	0c 94 49 0e 	jmp	0x1c92	; 0x1c92 <__prologue_saves__+0xc>
    1b12:	09 2e       	mov	r0, r25
    1b14:	05 94       	asr	r0
    1b16:	22 f4       	brpl	.+8      	; 0x1b20 <__divdi3_moddi3+0x24>
    1b18:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <__negdi2>
    1b1c:	11 23       	and	r17, r17
    1b1e:	92 f4       	brpl	.+36     	; 0x1b44 <__divdi3_moddi3+0x48>
    1b20:	f0 e8       	ldi	r31, 0x80	; 128
    1b22:	0f 26       	eor	r0, r31
    1b24:	ff ef       	ldi	r31, 0xFF	; 255
    1b26:	e0 94       	com	r14
    1b28:	f0 94       	com	r15
    1b2a:	00 95       	com	r16
    1b2c:	10 95       	com	r17
    1b2e:	b0 94       	com	r11
    1b30:	c0 94       	com	r12
    1b32:	d0 94       	com	r13
    1b34:	a1 94       	neg	r10
    1b36:	bf 0a       	sbc	r11, r31
    1b38:	cf 0a       	sbc	r12, r31
    1b3a:	df 0a       	sbc	r13, r31
    1b3c:	ef 0a       	sbc	r14, r31
    1b3e:	ff 0a       	sbc	r15, r31
    1b40:	0f 0b       	sbc	r16, r31
    1b42:	1f 0b       	sbc	r17, r31
    1b44:	0e 94 32 0b 	call	0x1664	; 0x1664 <__udivmod64>
    1b48:	07 fc       	sbrc	r0, 7
    1b4a:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <__negdi2>
    1b4e:	cd b7       	in	r28, 0x3d	; 61
    1b50:	de b7       	in	r29, 0x3e	; 62
    1b52:	ec e0       	ldi	r30, 0x0C	; 12
    1b54:	0c 94 65 0e 	jmp	0x1cca	; 0x1cca <__epilogue_restores__+0xc>

Disassembly of section .text.libgcc.div:

00001ec0 <__umoddi3>:
    1ec0:	68 94       	set
    1ec2:	01 c0       	rjmp	.+2      	; 0x1ec6 <__udivdi3_umoddi3>

00001ec4 <__udivdi3>:
    1ec4:	e8 94       	clt

00001ec6 <__udivdi3_umoddi3>:
    1ec6:	8f 92       	push	r8
    1ec8:	9f 92       	push	r9
    1eca:	cf 93       	push	r28
    1ecc:	df 93       	push	r29
    1ece:	0e 94 32 0b 	call	0x1664	; 0x1664 <__udivmod64>
    1ed2:	df 91       	pop	r29
    1ed4:	cf 91       	pop	r28
    1ed6:	9f 90       	pop	r9
    1ed8:	8f 90       	pop	r8
    1eda:	08 95       	ret

Disassembly of section .text.libgcc.div:

00001664 <__udivmod64>:
    1664:	88 24       	eor	r8, r8
    1666:	99 24       	eor	r9, r9
    1668:	f4 01       	movw	r30, r8
    166a:	e4 01       	movw	r28, r8
    166c:	b0 e4       	ldi	r27, 0x40	; 64
    166e:	9f 93       	push	r25
    1670:	aa 27       	eor	r26, r26
    1672:	9a 15       	cp	r25, r10
    1674:	8b 04       	cpc	r8, r11
    1676:	9c 04       	cpc	r9, r12
    1678:	ed 05       	cpc	r30, r13
    167a:	fe 05       	cpc	r31, r14
    167c:	cf 05       	cpc	r28, r15
    167e:	d0 07       	cpc	r29, r16
    1680:	a1 07       	cpc	r26, r17
    1682:	98 f4       	brcc	.+38     	; 0x16aa <__udivmod64+0x46>
    1684:	ad 2f       	mov	r26, r29
    1686:	dc 2f       	mov	r29, r28
    1688:	cf 2f       	mov	r28, r31
    168a:	fe 2f       	mov	r31, r30
    168c:	e9 2d       	mov	r30, r9
    168e:	98 2c       	mov	r9, r8
    1690:	89 2e       	mov	r8, r25
    1692:	98 2f       	mov	r25, r24
    1694:	87 2f       	mov	r24, r23
    1696:	76 2f       	mov	r23, r22
    1698:	65 2f       	mov	r22, r21
    169a:	54 2f       	mov	r21, r20
    169c:	43 2f       	mov	r20, r19
    169e:	32 2f       	mov	r19, r18
    16a0:	22 27       	eor	r18, r18
    16a2:	b8 50       	subi	r27, 0x08	; 8
    16a4:	31 f7       	brne	.-52     	; 0x1672 <__udivmod64+0xe>
    16a6:	bf 91       	pop	r27
    16a8:	27 c0       	rjmp	.+78     	; 0x16f8 <__udivmod64+0x94>
    16aa:	1b 2e       	mov	r1, r27
    16ac:	bf 91       	pop	r27
    16ae:	bb 27       	eor	r27, r27
    16b0:	22 0f       	add	r18, r18
    16b2:	33 1f       	adc	r19, r19
    16b4:	44 1f       	adc	r20, r20
    16b6:	55 1f       	adc	r21, r21
    16b8:	66 1f       	adc	r22, r22
    16ba:	77 1f       	adc	r23, r23
    16bc:	88 1f       	adc	r24, r24
    16be:	99 1f       	adc	r25, r25
    16c0:	88 1c       	adc	r8, r8
    16c2:	99 1c       	adc	r9, r9
    16c4:	ee 1f       	adc	r30, r30
    16c6:	ff 1f       	adc	r31, r31
    16c8:	cc 1f       	adc	r28, r28
    16ca:	dd 1f       	adc	r29, r29
    16cc:	aa 1f       	adc	r26, r26
    16ce:	bb 1f       	adc	r27, r27
    16d0:	8a 14       	cp	r8, r10
    16d2:	9b 04       	cpc	r9, r11
    16d4:	ec 05       	cpc	r30, r12
    16d6:	fd 05       	cpc	r31, r13
    16d8:	ce 05       	cpc	r28, r14
    16da:	df 05       	cpc	r29, r15
    16dc:	a0 07       	cpc	r26, r16
    16de:	b1 07       	cpc	r27, r17
    16e0:	48 f0       	brcs	.+18     	; 0x16f4 <__udivmod64+0x90>
    16e2:	8a 18       	sub	r8, r10
    16e4:	9b 08       	sbc	r9, r11
    16e6:	ec 09       	sbc	r30, r12
    16e8:	fd 09       	sbc	r31, r13
    16ea:	ce 09       	sbc	r28, r14
    16ec:	df 09       	sbc	r29, r15
    16ee:	a0 0b       	sbc	r26, r16
    16f0:	b1 0b       	sbc	r27, r17
    16f2:	21 60       	ori	r18, 0x01	; 1
    16f4:	1a 94       	dec	r1
    16f6:	e1 f6       	brne	.-72     	; 0x16b0 <__udivmod64+0x4c>
    16f8:	2e f4       	brtc	.+10     	; 0x1704 <__udivmod64+0xa0>
    16fa:	94 01       	movw	r18, r8
    16fc:	af 01       	movw	r20, r30
    16fe:	be 01       	movw	r22, r28
    1700:	cd 01       	movw	r24, r26
    1702:	00 0c       	add	r0, r0
    1704:	08 95       	ret

Disassembly of section .text.libgcc:

00001e64 <__negdi2>:
    1e64:	60 95       	com	r22
    1e66:	70 95       	com	r23
    1e68:	80 95       	com	r24
    1e6a:	90 95       	com	r25
    1e6c:	30 95       	com	r19
    1e6e:	40 95       	com	r20
    1e70:	50 95       	com	r21
    1e72:	21 95       	neg	r18
    1e74:	3f 4f       	sbci	r19, 0xFF	; 255
    1e76:	4f 4f       	sbci	r20, 0xFF	; 255
    1e78:	5f 4f       	sbci	r21, 0xFF	; 255
    1e7a:	6f 4f       	sbci	r22, 0xFF	; 255
    1e7c:	7f 4f       	sbci	r23, 0xFF	; 255
    1e7e:	8f 4f       	sbci	r24, 0xFF	; 255
    1e80:	9f 4f       	sbci	r25, 0xFF	; 255
    1e82:	08 95       	ret

Disassembly of section .text.libgcc.prologue:

00001c86 <__prologue_saves__>:
    1c86:	2f 92       	push	r2
    1c88:	3f 92       	push	r3
    1c8a:	4f 92       	push	r4
    1c8c:	5f 92       	push	r5
    1c8e:	6f 92       	push	r6
    1c90:	7f 92       	push	r7
    1c92:	8f 92       	push	r8
    1c94:	9f 92       	push	r9
    1c96:	af 92       	push	r10
    1c98:	bf 92       	push	r11
    1c9a:	cf 92       	push	r12
    1c9c:	df 92       	push	r13
    1c9e:	ef 92       	push	r14
    1ca0:	ff 92       	push	r15
    1ca2:	0f 93       	push	r16
    1ca4:	1f 93       	push	r17
    1ca6:	cf 93       	push	r28
    1ca8:	df 93       	push	r29
    1caa:	cd b7       	in	r28, 0x3d	; 61
    1cac:	de b7       	in	r29, 0x3e	; 62
    1cae:	ca 1b       	sub	r28, r26
    1cb0:	db 0b       	sbc	r29, r27
    1cb2:	0f b6       	in	r0, 0x3f	; 63
    1cb4:	f8 94       	cli
    1cb6:	de bf       	out	0x3e, r29	; 62
    1cb8:	0f be       	out	0x3f, r0	; 63
    1cba:	cd bf       	out	0x3d, r28	; 61
    1cbc:	09 94       	ijmp

Disassembly of section .text.libgcc.prologue:

00001cbe <__epilogue_restores__>:
    1cbe:	2a 88       	ldd	r2, Y+18	; 0x12
    1cc0:	39 88       	ldd	r3, Y+17	; 0x11
    1cc2:	48 88       	ldd	r4, Y+16	; 0x10
    1cc4:	5f 84       	ldd	r5, Y+15	; 0x0f
    1cc6:	6e 84       	ldd	r6, Y+14	; 0x0e
    1cc8:	7d 84       	ldd	r7, Y+13	; 0x0d
    1cca:	8c 84       	ldd	r8, Y+12	; 0x0c
    1ccc:	9b 84       	ldd	r9, Y+11	; 0x0b
    1cce:	aa 84       	ldd	r10, Y+10	; 0x0a
    1cd0:	b9 84       	ldd	r11, Y+9	; 0x09
    1cd2:	c8 84       	ldd	r12, Y+8	; 0x08
    1cd4:	df 80       	ldd	r13, Y+7	; 0x07
    1cd6:	ee 80       	ldd	r14, Y+6	; 0x06
    1cd8:	fd 80       	ldd	r15, Y+5	; 0x05
    1cda:	0c 81       	ldd	r16, Y+4	; 0x04
    1cdc:	1b 81       	ldd	r17, Y+3	; 0x03
    1cde:	aa 81       	ldd	r26, Y+2	; 0x02
    1ce0:	b9 81       	ldd	r27, Y+1	; 0x01
    1ce2:	ce 0f       	add	r28, r30
    1ce4:	d1 1d       	adc	r29, r1
    1ce6:	0f b6       	in	r0, 0x3f	; 63
    1ce8:	f8 94       	cli
    1cea:	de bf       	out	0x3e, r29	; 62
    1cec:	0f be       	out	0x3f, r0	; 63
    1cee:	cd bf       	out	0x3d, r28	; 61
    1cf0:	ed 01       	movw	r28, r26
    1cf2:	08 95       	ret

Disassembly of section .text.libgcc:

00001f0c <__cmpdi2_s8>:
    1f0c:	00 24       	eor	r0, r0
    1f0e:	a7 fd       	sbrc	r26, 7
    1f10:	00 94       	com	r0
    1f12:	2a 17       	cp	r18, r26
    1f14:	30 05       	cpc	r19, r0
    1f16:	40 05       	cpc	r20, r0
    1f18:	50 05       	cpc	r21, r0
    1f1a:	60 05       	cpc	r22, r0
    1f1c:	70 05       	cpc	r23, r0
    1f1e:	80 05       	cpc	r24, r0
    1f20:	90 05       	cpc	r25, r0
    1f22:	08 95       	ret

Disassembly of section .text.libgcc.div:

00001dfa <__udivmodhi4>:
    1dfa:	aa 1b       	sub	r26, r26
    1dfc:	bb 1b       	sub	r27, r27
    1dfe:	51 e1       	ldi	r21, 0x11	; 17
    1e00:	07 c0       	rjmp	.+14     	; 0x1e10 <__udivmodhi4_ep>

00001e02 <__udivmodhi4_loop>:
    1e02:	aa 1f       	adc	r26, r26
    1e04:	bb 1f       	adc	r27, r27
    1e06:	a6 17       	cp	r26, r22
    1e08:	b7 07       	cpc	r27, r23
    1e0a:	10 f0       	brcs	.+4      	; 0x1e10 <__udivmodhi4_ep>
    1e0c:	a6 1b       	sub	r26, r22
    1e0e:	b7 0b       	sbc	r27, r23

00001e10 <__udivmodhi4_ep>:
    1e10:	88 1f       	adc	r24, r24
    1e12:	99 1f       	adc	r25, r25
    1e14:	5a 95       	dec	r21
    1e16:	a9 f7       	brne	.-22     	; 0x1e02 <__udivmodhi4_loop>
    1e18:	80 95       	com	r24
    1e1a:	90 95       	com	r25
    1e1c:	bc 01       	movw	r22, r24
    1e1e:	cd 01       	movw	r24, r26
    1e20:	08 95       	ret

Disassembly of section .text.__dummy_fini:

000020e2 <_fini>:
    20e2:	08 95       	ret

Disassembly of section .text.__dummy_funcs_on_exit:

000020e4 <__funcs_on_exit>:
    20e4:	08 95       	ret

Disassembly of section .text.__dummy_simulator_exit:

000020e6 <__simulator_exit>:
    20e6:	08 95       	ret

Disassembly of section .text.exit:

00001f50 <exit>:
    1f50:	ec 01       	movw	r28, r24
    1f52:	0e 94 72 10 	call	0x20e4	; 0x20e4 <__funcs_on_exit>
    1f56:	0e 94 71 10 	call	0x20e2	; 0x20e2 <_fini>
    1f5a:	ce 01       	movw	r24, r28
    1f5c:	0e 94 73 10 	call	0x20e6	; 0x20e6 <__simulator_exit>
    1f60:	ce 01       	movw	r24, r28
    1f62:	0e 94 6f 10 	call	0x20de	; 0x20de <_Exit>

Disassembly of section .text._Exit:

000020de <_Exit>:
    20de:	0e 94 6d 00 	call	0xda	; 0xda <_exit>
